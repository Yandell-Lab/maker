#!/usr/bin/perl

use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/../lib";
use lib "$FindBin::Bin/../perl/lib";
use Getopt::Long;
use File::Temp;
use File::Copy;
use URI::Escape;
use vars qw($JB $RS $G_CSS $M_CSS);

my $usage = '
USAGE:
     maker2jbrowse [OPTION] <gff3file1> <gff3file2> ...
     maker2jbrowse [OPTION] -d <datastore_index>

     This script takes MAKER produced GFF3 files and dumps them into a
     JBrowse for you using pre-configured JSON tracks.

OPTIONS:
     ds_index|d  <file>  Provide MAKER produced datastore index

     css|c       <file>  Provide alternate css for tracks
                         (DEFAULT: .../maker/GMOD/JBrowse/maker.css)

     help|?              Displays this usage statement

';

$JB = "./bin/flatfile-to-json.pl";
if (! -f $JB) {
    print $usage;
    die "FATAL: Can not find ./bin/flatfile-to-json.pl\n".
	"Make sure you are running inside the JBrowse directory\n";
    
}
else {
    $JB = [split("\n", $JB)]->[-1];
}

$RS = "./bin/prepare-refseqs.pl";
if (! -f $RS) {
    print $usage;
    die "FATAL: Can not find ./bin/prepare-refseqs.pl\n".
	"Make sure you are running inside the JBrowse directory.\n";
}
else {
    $RS = [split("\n", $RS)]->[-1];
}

$G_CSS = "./genome.css";
if (! -f $RS) {
    print $usage;
    die "FATAL: Can not find the ./genome.css file\n".
	"Make sure you are running inside the JBrowse directory.\n";
}

$M_CSS = "$FindBin::RealBin/../GMOD/JBrowse/maker.css";
my $dstore;

GetOptions("ds_index|d=s" => \$dstore,
	   "css|c=s" => \$M_CSS,
	   "help|?" => sub {print $usage; exit()}
	   );

my @files;

die "ERROR: The file ds_index\'$dstore\' does not exist\n" if ($dstore && ! -f $dstore);
die "ERROR: The css file \'$M_CSS\' does not exist\n" if (! -f $M_CSS);

if($dstore){
    my $base = $dstore;
    $base =~ s/(\/?)[^\/]+$/$1/;
    open(IN, "< $dstore");

    #uniq the entries
    my %seen;
    while(my $e = <IN>){
        next unless ($e =~ /FINISHED/);
        next if $seen{$e};
        $seen{$e}++;
        chomp $e;
        my ($id, $dir, $status) = split("\t", $e);
        $dir =~ s/\/$//;
        push(@files, $dir);
    }

    foreach my $file (@files){
        $file =~ /([^\/]+)$/;
	my $name = $1;
        my $gff = ($base) ? "$base/$file/$name.gff" : "$file/$name.gff";

	if(! -f $gff){
	    $name = uri_escape($name, '.');
	    $gff = ($base) ? "$base/$file/$name.gff" : "$file/$name.gff";
	}
	$file = $gff;
    }
}
else{
    @files = @ARGV;
    undef @ARGV;
}

if(!@files){
    print $usage;
    exit();
}

my $error;

foreach my $file (@files){
    if (! -f $file){
	$error .= "ERROR: The GFF3 file \'$file\' does not exist\n";
    }
}

die $error if $error;

my $comment;
my $maker;
open(IN, "<$G_CSS");
while(my $line = <IN>){
    $comment = 1 if($line =~ /\/\*/);
    $comment = 0 if($comment && $line =~ /\*\//);
    next if($comment);
    $maker = 1 if($line =~ /^\@import url\(\"maker\.css\"\)\;/);
}

unless($maker){
    File::Copy::copy($M_CSS, './maker.css') or die "Copy failed: $!";
    open(OUT, ">>$G_CSS") or die "Open failed: $!";
    print OUT "\@import url(\"maker.css\");\n" or die "Print failed: $!";
    close(OUT) or die "Close failed: $!";
}

#--build command lines
my %commands;

#MAKER anotations
$commands{gene}           = ' --tracklabel "Genes" --key "Genes" --getType --getLabel --autocomplete label --className feature5 --type gene';
$commands{maker}          = ' --tracklabel "Transcripts" --key "Transcripts" --getType --getSubfeatures --getLabel --autocomplete all --className transcript --subfeatureClasses \'{"exon": "exon", "CDS": "CDS", "five_prime_UTR": "five_prime_UTR", "three_prime_UTR": "three_prime_UTR"}\' --arrowheadClass transcript-arrowhead --type mRNA';

#ab initio gene predictions
$commands{snap}           = ' --tracklabel "SNAP" --key "SNAP" --getType --getSubfeatures --getLabel --className transcript --subfeatureClasses \'{"match_part": "snap-exon"}\' --arrowheadClass transcript-arrowhead --type match:snap';
$commands{snap_masked}    = ' --tracklabel "SNAP" --key "SNAP" --getType --getSubfeatures --getLabel --className transcript --subfeatureClasses \'{"match_part": "snap-exon"}\' --arrowheadClass transcript-arrowhead --type match:snap_masked';
$commands{augustus}       = ' --tracklabel "Augustus" --key "Augustus" --getType --getSubfeatures --getLabel --className transcript --subfeatureClasses \'{"match_part": "augustus-exon"}\' --arrowheadClass transcript-arrowhead --type match:augustus';
$commands{augustus_masked} = ' --tracklabel "Augustus" --key "Augustus" --getType --getSubfeatures --getLabel --className transcript --subfeatureClasses \'{"match_part": "augustus-exon"}\' --arrowheadClass transcript-arrowhead --type match:augustus_masked';
$commands{genemark}       = ' --tracklabel "GeneMark" --key "GeneMark" --getType --getSubfeatures --getLabel --className transcript --subfeatureClasses \'{"match_part": "genemark-exon"}\' --arrowheadClass transcript-arrowhead --type match:genemark';
$commands{genemark_masked} = ' --tracklabel "GeneMark" --key "GeneMark" --getType --getSubfeatures --getLabel --className transcript --subfeatureClasses \'{"match_part": "genemark-exon"}\' --arrowheadClass transcript-arrowhead --type match:genemark_masked';
$commands{fgenesh}        = ' --tracklabel "FGENESH" --key "FGENESH" --getType --getSubfeatures --getLabel --className transcript --subfeatureClasses \'{"match_part": "fgenesh-exon"}\' --arrowheadClass transcript-arrowhead --type match:fgenesh';
$commands{fgenesh_masked} = ' --tracklabel "FGENESH" --key "FGENESH" --getType --getSubfeatures --getLabel --className transcript --subfeatureClasses \'{"match_part": "fgenesh-exon"}\' --arrowheadClass transcript-arrowhead --type match:fgenesh_masked';

#evidence alignments
$commands{blastn}         = ' --tracklabel "BLASTN" --key "BLASTN" --getType --getSubfeatures --className generic_parent --subfeatureClasses \'{"match_part": "blastn_part"}\' --type expressed_sequence_match:blastn';
$commands{blastx}         = ' --tracklabel "BLASTX" --key "BLASTX" --getType --getSubfeatures --className generic_parent --subfeatureClasses \'{"match_part": "blastx_part"}\' --type protein_match:blastx';
$commands{tblastx}        = ' --tracklabel "TBLASTX" --key "TBLASTX" --getType --getSubfeatures --className generic_parent --subfeatureClasses \'{"match_part": "tblastx_part"}\' --type expressed_sequence_match:tblastx';
$commands{est2genome}     = ' --tracklabel "est2genome" --key "est2genome" --getType --getSubfeatures --className generic_parent --subfeatureClasses \'{"match_part": "est2genome_part"}\' --type expressed_sequence_match:est2genome';
$commands{protein2genome} = ' --tracklabel "protein2genome" --key "protein2genome" --getType --getSubfeatures --className generic_parent --subfeatureClasses \'{"match_part": "protein2genome_part"}\' --type protein_match:protein2genome';
$commands{cdna2genome} = ' --tracklabel "cdna2genome" --key "cdna2genome" --getType --getSubfeatures --className generic_parent --subfeatureClasses \'{"match_part": "cdna2genome_part"}\' --type expressed_sequence_match:cdna2genome';

#repeats
$commands{repeatmasker}   = ' --tracklabel "RepeatMasker" --key "RepeatMasker" --getType --getSubfeatures --className generic_parent --subfeatureClasses \'{"match_part": "repeat_part"}\' --type match:repeatmasker';
$commands{repeatrunner}  = ' --tracklabel "RepeatRunner" --key "RepeatRunner" --getType --getSubfeatures --className generic_parent --subfeatureClasses \'{"match_part": "repeat_part"}\' --type protein_match:repeatrunner';


foreach my $file (@files){
    my $gff;
    my $fasta;
    my %tracks;

    open(IN, "< $file");
    my $ff; #fasta flag
    my %seen;
    while(defined(my $line = <IN>)){
	if($ff){
	    $fasta .= $line;
	    next;
	}
	elsif($line =~ /^\#\#FASTA/){
	    $ff = 1;
	    next;
	}
	elsif($line =~ /[^\t]*\t[^\t]*\tcontig\t/){
	    next; #skip contig line
	}
	else{
	    if($line !~ /^\#/ && $line =~ /[^\t]*\t([^\t]*)\t/){
		$tracks{$1}++;
		$tracks{gene}++ if($1 eq 'maker'); #add gene locus track
	    }
	    if($line =~ /\tCDS\t|\tfive_prime_UTR\t|\tthree_prime_UTR\t/ && $line =~ /ID\=([^\;\n]+)/){
		my $id = $1;
		if($seen{$id}){
		    my $i = 0;
		    $i++ while($seen{"$id:$i"});
		    $id = "$id:$i";
		    $line =~ s/ID\=[^\;\n]+/ID\=$id/;
		}
		$seen{$id}++
	    }

	    $gff .= $line;
	    next;
	}
    }
    close(IN);

    if($fasta){
	my ($fh, $fname) = File::Temp::tempfile();
	print $fh $fasta;
	close($fh);

	my $command = $RS;
	$command .= " --fasta $fname";

	system ($command);
	unlink($fname);
    }

    if($gff){
	my ($fh, $fname) = File::Temp::tempfile();
	print $fh $gff;
	close($fh);

	while(my $track = each %tracks){
	    my $command = $JB;

	    if(! exists $commands{$track}){
		warn "ERROR: No track information for source \'$track\'\n\n";
		next;
	    }

	    $command .= $commands{$track};
	    $command .= " --gff $fname";

	    system ($command);
	}

	unlink($fname);
    }
}
