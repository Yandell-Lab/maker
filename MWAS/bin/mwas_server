#!/usr/bin/perl

#Maker server 2.0-------------------------------------------------
# is being run to serve maker queue. mwas_server is
# an inifinite loop to check the queue and execute maker jobs as
# soon as they are added to the maker queue.
#-------------------------------------------------------------hadi islam

use strict;
use warnings;
use DBI;
use Mail::Sender;
use vars qw($LOG %CTL_OPT $EXE $DEBUG $CWD);
use POSIX qw(:sys_wait_h setsid setuid setgid EAGAIN);
use Template;
use FindBin;
use lib "$FindBin::RealBin/../../lib"; #/maker/lib?
use lib "$FindBin::RealBin/../../perl/lib"; #/maker/perl/lib?
use lib "$FindBin::RealBin/../../maker/lib"; #/maker/lib?
use lib "$FindBin::RealBin/../../maker/perl/lib"; #/maker/perl/lib?
use lib "$FindBin::RealBin/../lib"; #/MWAS/lib
use lib "$FindBin::RealBin/../perl/lib"; #/MWAS/perl/lib
use Proc::Signal;
use File::NFSLock;
use File::Path qw(mkpath rmtree);
use IPC::Open3;
use Cwd;

BEGIN{
    if (not ($ENV{CGL_SO_SOURCE})) {
	$ENV{CGL_SO_SOURCE} = "$FindBin::RealBin/../../lib/CGL/so.obo";
    }
    if (not ($ENV{CGL_GO_SOURCE})) {
	$ENV{CGL_GO_SOURCE} = "$FindBin::RealBin/../../lib/CGL/gene_ontology.obo"
    }

    #get my own name
    $EXE = $FindBin::Script;

    #must give group members access i.e. apache group
    umask 0002;

    #set debugging mode
    $DEBUG=0;

    #current working directory
    $CWD = Cwd::cwd();
}

use GI;
use MWAS_util;

#stop signal subroutine
my $exit =  sub{die "STATUS: Caught @_ exiting.\t".MWAS_util::date_time()."\n";};

#Signals to trap and handle
$SIG{'INT' } = $exit;
$SIG{'ABRT'} = $exit; 
$SIG{'QUIT'} = $exit;
$SIG{'TRAP'} = $exit;
$SIG{'STOP'} = $exit;
$SIG{'TERM'} = $exit;
$SIG{'HUP'} = sub{print STDERR "STATUS: Signal @_ received, attempting to restart $EXE\t".MWAS_util::date_time()."\n";
		  close(STDERR);
		  exec(Cwd::abs_path($0), @ARGV);
	      };

my $usage = "
Usage:
     mwas_server [option]

     This is a daemon responsible for the operation of the MAKER Web Annotation
     Service (MWAS).  The daemon checks an SQL database for job submissions and
     then runs MAKER for those jobs.  You must supply an option when executing
     the mwas_server script otherwise it will just return the usage statement.

     Please note that you can also use maker with the -MWAS option to control
     the mwas_server daemon instead of using the mwas_server script directly
     (i.e. maker -MWAS START is the equivilent of mwas_server START).

     The behavior of the MAKER Web Annotation Service and mwas_server is
     dependant on control files found in the /etc/mwas directory. There are
     five files:  server.ctl, menus.ctl, maker_opts.ctl, maker_bopts.ctl, and
     maker_exe.ctl.  If these files are missing they can be regenerate by
     calling the CONFIG with mwas_server (i.e. mwas_server CONFIG).

     The server.ctl file is used to configure server specific and some web
     interface specific options.  The database used by mwas_server is
     configured here.  By default, mwas_server will create a database using
     SQLite, but you can designate any SQL database supported by the Perl DBI.

     The menus.ctl file in the etc/mwas directory is used to configure
     dropdown menus displayed by the web interface.  This file follows Perl
     syntax and is loaded and generated by Data::Dumper.

     The maker_opts.ctl, maker_bopts.ctl, and maker_exe.ctl files are
     equilvilent to the control files used by MAKER when running a job.  See
     the MAKER documentation for an explanation of the values.  The MAKER Web
     Annotation Service uses these files to define default values presented to
     users in the web interface.  These files also supports tags that configure
     how options are presented to users in the web interface.  Adding the tag 
     =STATIC to the end of a value makes it so the user can see but not alter
     a value in the web interface.  Adding the tag =DISABLED hides the value
     and related menu sections from the web interface.

     The MAKER Web Annotation Service has two parts.  A web interface front end
     that users access via a browser to configure a MAKER job, and a server
     backend that monitor for job submissions and executes MAKER.  The
     mwas_server script is responsible for the back end, but can be used to
     generate the front end CGI/HTML in the directory of your choosing (i.e a
     web accessible directy like /var/www/cgi-bin/maker for Apache).  To do 
     this use the CGI option (don't forget to specify the value for the
     directory in the server.ctl file afterward).


Options:

     STATUS      Checks the status of the MAKER server.

     START       Starts the daemon.

     RESTART     Shutsdown and then restarts the daemon.

     STOP        Shuts down the daemon. SHUTDOWN, QUIT, and KILL are also
                 accepted.

     PREP        Generates server control file in the /etc/mwas
                 directory, does not destroy existing files. Run before CONFIG
                 as some defaults are dependent on server settings.

     CONFIG      Generates default control files in the /etc/mwas
                 directory, does not destroy existing files.

     SETUP       Setup the GGI/HTML files needed to launch the web interface.
                 Also sets up the database that the web interface will use.
                 You  must set cgi_dir, html_dir, DBI, and dbname in
                 /etc/mwas/server.ctl before running SETUP.

     APOLLO      Setup a webstart version of Apollo for browsing job results. 
                 You must set APOLLO_ROOT in /etc/mwas/server.ctl first.

     GBROWSE     Configure GBrowse to view MWAS job results. You must set
                 GBROWSE_MASTER in /etc/mwas/server.ctl first.

     HELP        Prints this usage statement

";

#------------------------------------------------------------------------
#-------------------------------- MAIN ----------------------------------
#------------------------------------------------------------------------

#lets downstream maker libraries know this is the server app
$main::server = 1;

#proccess command line options
my $opt = uc($ARGV[0]) || 'HELP';
$opt =~ s/^\-+|^\=+//; #fix -'s or ='s in options
$opt = 'HELP' if($opt eq '?'); #also accept ?
$opt = 'STOP' if($opt =~ /^SHUTDOWN$|^KILL$|^QUIT$|^DIE$|^DIEDIE$/); #also accept SHUTDOWN, KILL, or QUIT

#find control files and load them
my $c_dir = MWAS_util::config_loc(); #configuration file directory
my @files = ("$c_dir/maker_opts.ctl",
	     "$c_dir/maker_bopts.ctl",
	     "$c_dir/maker_exe.ctl",
	     "$c_dir/server.ctl",
	     "$c_dir/menus.ctl",
	     );
my @exists = grep {-f $_} @files;

%CTL_OPT = GI::load_server_files(\@exists);


if($opt eq 'HELP'){
    print $usage;
    exit(1);
}
elsif($opt eq 'STATUS'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
        print STDERR "STATUS: $EXE is not currently running\n";
    }
    elsif(! $signalable){
        die "ERROR: $EXE is running but you do not have the correct ".
	    "permissions to manage it\n\n";
    }
    else{
        print STDERR "STATUS: $EXE is running\n";
    }
}
elsif($opt eq 'PREP'){
    GI::generate_control_files($c_dir,'server', \%CTL_OPT);
}
elsif($opt eq 'CONFIG' | $opt eq 'CTL'){
    GI::generate_control_files($c_dir,'all',\%CTL_OPT);
    GI::generate_control_files($c_dir,'server', \%CTL_OPT);
    GI::generate_control_files($c_dir,'menus', \%CTL_OPT);
}
elsif($opt eq 'SETUP'){
    #error checking
    if(@exists < @files){
	die "ERROR: You must run $EXE with the PREP and CONFIG options first to create\n".
	    "MAKER configuration files. Once you are finished building and editing these\n".
	    "files you can run $EXE with the SETUP option, to build the web interface.\n\n";
    }

    MWAS_util::mwas_setup(\%CTL_OPT);
}
elsif($opt eq 'APOLLO'){
    MWAS_util::apollo_setup(\%CTL_OPT);
}
elsif($opt eq 'GBROWSE'){
    MWAS_util::gbrowse_setup(\%CTL_OPT);
}
elsif($opt eq 'RESTART'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
	print STDERR "STATUS:  is not currently running\n";
	exec(Cwd::abs_path($0), 'START');
    }
    elsif(! $signalable){
	die "ERROR: you do not have the correct permissions to restart $EXE\n";
    }
    else{
	print STDERR "STATUS: Trying to restart $EXE\n";
	my $stat = Proc::Signal::killall('HUP', "$EXE");
	if($stat){
	    print STDERR "STATUS: $EXE was restarted successfully\n";
	}
	else{
	    print STDERR "ERROR: Could not restart $EXE!\n";
	}
    }
}
elsif($opt eq 'STOP'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
	print STDERR "STATUS: $EXE is not currently running\n";
    }
    elsif(! $signalable){
	die "ERROR: you do not have the correct permissions to stop $EXE\n";
    }
    else{
	print STDERR "STATUS: Trying to stop $EXE\n";
	my $stat = Proc::Signal::killall('QUIT', "$EXE");
	my $run = Proc::Signal::exists_proc_by_name("$EXE");
	if($stat && ! $run){
	    print STDERR "STATUS: $EXE was stopped successfully\n";
	    exit(0);
	}
	else{
	    print STDERR "ERROR: Could not stop $EXE!\n";
	}

	#server is still running try a more agressive approach
	print STDERR "STATUS: Agressively trying to stop $EXE\n";
	$stat = Proc::Signal::killall(9, "$EXE");
	$run = Proc::Signal::exists_proc_by_name("$EXE");
	if($stat && ! $run){
	    print STDERR "STATUS: $EXE was stopped successfully\n";
	    exit(0);
	}
	else{
	    print STDERR "ERROR: Could not stop $EXE!\n";
	}
    }
}
elsif($opt eq 'START'){
    my $exists = Proc::Signal::exists_proc_by_name("$EXE");

    if($exists){
	die "ERROR: $EXE is already running.\t".MWAS_util::date_time()."\n";
    }
    else{
	#set user id to be apache
	($ENV{USER}, my $usr_id, my $grp_id, $ENV{HOME}) = (getpwnam($CTL_OPT{apache_user}))[0,2,3,7];

	if($usr_id != $> && ! $DEBUG){
	    chdir("//"); #change directory just incase
	    if(! $grp_id){
		die "ERROR: Can not find group id for apache user.  Make sure\n".
		    "apache is installed and the correct value is set for\n".
		    "apache_user in the server_opt.ctl file.\n\n"
	    }
	    set_gid($grp_id);
	    setpgrp(0, $grp_id) &&
		die "ERROR: Could not attach the server to the apache user group.\n".
		"You may need to add your current user to the apache user group\n".
		"or start the server usginG sudo\n\n";
	    set_uid($usr_id);
	    chdir($ENV{HOME}); #change directory to apache home just incase

	    #launch with new user_id from data_dir copy
	    exec("$CTL_OPT{data_dir}/maker/MWAS/bin/$EXE", 'START');
	}

	print STDERR "STATUS: Now starting $EXE\!\n";
	    
	#error checking
	if(@exists < @files){
	    die "ERROR: Server control files are missing.  Run $EXE\n".
		"with the CONFIG option first to create the control files.\n".
		"Once you are finished building and editing these files\n".
		"run with the SETUP option to build all files necessary\n".
		"for client side web access to the server. Then you can\n".
		"start the server.\n\n";
	}


	#try to connect to the database as a test
	my $dsn = "DBI:$CTL_OPT{DBI}:dbname=";
	$dsn .= "$CTL_OPT{data_dir}/" if($CTL_OPT{DBI} eq 'SQLite');
        $dsn .= "$CTL_OPT{dbname};";
	$dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
	$dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});

	if(!$CTL_OPT{username}){ #warn if no db_username specified
	    warn "WARNING: No username for connecting to the database is specified\n".
		"without a username online requests to MWAS will fail because of\n".
		"permission issues. Please make the necessary changes to server.ctl.\n\n";
	}

	my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password})
	    or die "<br>Got error $DBI::errstr when connecting to database\n";
	$dbh->disconnect;

	#check permissions on data directory
	if(! -w $CTL_OPT{data_dir} || ! -r $CTL_OPT{data_dir} || ! -x $CTL_OPT{data_dir}){
	    die "ERROR: Current file permissions won't allow you to use $CTL_OPT{data_dir}\n".
		"as the ouput directory for the MAKER Web Annotation Service\n\n";
	}

	if($DEBUG){ #run server in forground for debugger
	    run_server();
	}
	else{#run server as a daemon
	    start_daemon();
	}
    }
}
else{
    print STDERR "ERROR: Invalid option: $opt\n\n";
    print $usage;
    exit(1);
}
#------------------------------------------------------------------------
#----------------------------- SUBROUTINES ------------------------------
#------------------------------------------------------------------------
sub start_daemon {
    unless(my $pid = fork()) {
	exit if $pid;
        setsid();
	my $date = MWAS_util::date_time();
	
	#rediret STDERR to the log file since there will be no terminal
	$LOG = "$CTL_OPT{data_dir}/mwas_error.log";
	close(STDERR);
	open(STDERR, ">> $LOG"); #append

        print STDERR "STATUS: Starting $EXE.\t$date\n";
	run_server();
    }
}
#------------------------------------------------------------------------
#sens messages via e-mail i.e. errors or status reports
sub send_message{
    my $address = shift @_;
    my $smtp    = shift @_;
    my $subject = shift @_;
    my $msg     = shift @_;

    my $sender = Mail::Sender->new({smtp => $smtp});
    
    my $sq = $sender->MailMsg({to      => $address,
			       from    => "no-reply\@$smtp",
			       subject => $subject,
			       msg     => $msg
			      });
}
#------------------------------------------------------------------------
sub run_server {
    #load the control files
    my $c_dir = MWAS_util::config_loc(); #configuration file direcdtory
    %CTL_OPT = GI::load_server_files(["$c_dir/maker_opts.ctl",
				      "$c_dir/maker_bopts.ctl",
				      "$c_dir/maker_exe.ctl",
				      "$c_dir/server.ctl",
				      "$c_dir/menus.ctl",
				      ]);

    #make sure required database values are setup
    if(! $CTL_OPT{DBI}){
	die "ERROR: You must specify a DBI connection method in: $c_dir/server.ctl\n\n";
    }

    if(! $CTL_OPT{dbname}){
	die "ERROR: You must specify a database to connecty to in: $c_dir/server.ctl\n\n";
    }

    if(! $CTL_OPT{cgi_dir} || ! $CTL_OPT{html_dir}){
	die "ERROR: You must specify the directory where web content is installed in: $c_dir/server.ctl\n\n";
    }

    #try to connect to the database as a test
    my $dsn = "DBI:$CTL_OPT{DBI}:dbname=";
    $dsn .= "$CTL_OPT{data_dir}/" if($CTL_OPT{DBI} eq 'SQLite');
    $dsn .= "$CTL_OPT{dbname};";
    $dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
    $dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});
    
    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password})
	or die "<br>Got error $DBI::errstr when connecting to database\n";

    #correct everything in db tables on startup
    MWAS_util::check_table_structure($dbh, \%CTL_OPT);
    MWAS_util::reset_queue($dbh, $CTL_OPT{data_dir});

    #update web interface to current configuration
    my $w_dir = $CTL_OPT{cgi_dir}; #web accessible directory

    $dbh->disconnect; #database found successfully

    #load environmental variables needed to run dependancies
    $ENV{APOLLO_ROOT} = $CTL_OPT{APOLLO_ROOT};
    $ENV{ZOE} = $CTL_OPT{ZOE};
    $ENV{AUGUSTUS_CONFIG_PATH} = $CTL_OPT{AUGUSTUS_CONFIG_PATH};

    #start continuous loop for constant server operation
    my %running; #holds ids of all forks associated with a job

    #connect to database

    while(1){
	my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password})
	    or die "<br>Got error $DBI::errstr when connecting to database\n";
	#========check on jobs and package data for finished jobs
	
	#look at all active jobs
	while(my $jid = each %running){
	    my @still_running;
	    foreach my $child (@{$running{$jid}}){
		my $stat = waitpid($child, WNOHANG); #nonblocking check of proccess id
		push(@still_running, $child) if($stat == 0); #keep those that aren't finished
	    }

	    #has there been a change in the number of active children?
	    next if(@still_running == @{$running{$jid}});

	    #update active children
	    $running{$jid} = \@still_running;
	    
	    #update cpus entry in table to reflect the true number of active children
	    dbh_do_commit($dbh, qq{UPDATE jobs SET cpus=}.@still_running.qq{ WHERE job_id=$jid}, $CTL_OPT{data_dir});

	    #if all children are inactive
	    if(!@still_running){
		#reset is_running to reflect cpu changes
		dbh_do_commit($dbh, qq{UPDATE jobs SET is_running=0, cpus=0 WHERE job_id=$jid}, $CTL_OPT{data_dir});

		#see if MAKER is really finished
		my ($finished) = $dbh->selectrow_array(qq{SELECT is_finished FROM jobs WHERE job_id=$jid});
		if(!$finished){
		    #not finished, put job back in queue as long as it's not failed
		    dbh_do_commit($dbh, qq{UPDATE jobs SET is_queued=1 WHERE job_id=$jid and is_error=0}, $CTL_OPT{data_dir});
		    delete($running{$jid}); #clear hash key
		}
		else{
		    #All finished, package data for user to download
		    clean_and_package($jid, $CTL_OPT{data_dir}, $dbh);
		    delete($running{$jid}); #clear hash key
		}
	    }
	}

	#========try and start or increase resources to new jobs

	#count all active cpus
	my $cpus = 0;
	grep {$cpus += $_} @{$dbh->selectcol_arrayref(qq{SELECT cpus FROM jobs WHERE is_running=1})}; #use grep to sum

	#if no resources are available just wait
	if($cpus >= $CTL_OPT{max_cpus}){
	    $dbh->disconnect;
	    sleep 20;
	    next;
	}
	
	#check for available jobs in queue
	my ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE is_queued=1 and admin_block=0 and is_error=0 and is_finished=0 ORDER BY submit_id LIMIT 1});
	
	if(! $job_id){ #no job in queue
	    #see if I can give extra cpus to existing jobs
	    ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE is_running=1 and cpus }.
					      qq{< $CTL_OPT{job_cpus} and is_finished=0 and admin_block=0 }.
					      qq{and is_error=0 ORDER BY submit_id LIMIT 1});

	    if($job_id){ #give more cpus to the job
		my $child = start_job($job_id, \%CTL_OPT, $dbh);
		push(@{$running{$job_id}}, $child) if($child);
		$dbh->disconnect;
		next;
	    }
	    else{#no free cpus, just wait
		$dbh->disconnect;
		sleep 10;
		next;
	    }
	}
	else{ #there's a job, run it
	    my $child = start_job($job_id, \%CTL_OPT, $dbh);
	    push(@{$running{$job_id}}, $child) if($child);
	    $dbh->disconnect;
	    next;
	}
	$dbh->disconnect;
    }
}
#------------------------------------------------------------------------
sub clean_and_package {
    my $job_id   = shift;
    my $data_dir = shift;
    my $dbh      = shift;

    my ($packaged) = $dbh->selectrow_array(qq{SELECT is_packaged FROM jobs WHERE job_id=$job_id});

    #already packaged, move on
    return if($packaged);

    #get job run directory
    my $job_dir = "$data_dir/jobs/$job_id/";

    #get result directory
    my $r_dir = "$job_id.maker.output";
    #where did the results go? run again
    if(! -d "$job_dir/$r_dir"){
	dbh_do_commit($dbh, qq{UPDATE jobs SET is_queued=1, is_finished=0 WHERE job_id=$job_id and is_error=0}, $CTL_OPT{data_dir});
	return;
    }

    #delete extra files from maker output directory
    my @to_delete = (<$job_dir/$r_dir/mpi_blastdb>, <$job_dir/$r_dir/seen.dbm>, <$job_dir/$r_dir/*.db>, <$job_dir/$r_dir/*lock*>);
    foreach my $f (@to_delete){
	unlink($f) if(-f $f);
	File::Path::rmtree($f) if(-d $f);
    }

    #build merged gff3 and fasta files
    system("cd $job_dir/$r_dir\n".
	   "$FindBin::RealBin/../../bin/gff3_merge -d $job_id\_master_datastore_index.log\n".
	   "$FindBin::RealBin/../../bin/fasta_merge -d $job_id\_master_datastore_index.log");

    #wrap everything up into a nice package
    system("cd $job_dir\n".
	   "tar --exclude \"theVoid\*\" --exclude \"seen.dbm\" --exclude \"mpi_blastdb\" -zcf $r_dir.tar.gz $r_dir") &&
	   die("ERROR: Building tarball for job '$job_id' failed\n");

    my $index = "$job_dir/$r_dir/$job_id\_master_datastore_index.log";
    open(my $IN, "< $index");
    while(my $line = <$IN>){
        chomp $line;
        my @data = split("\t", $line);

        #if($data[2] eq 'FINISHED'){
        #    my $val = "$job_dir/$r_dir/$data[1]";
        #    $val =~ s/[\/]+$//;
        #    my ($name) = $val =~ /([^\/]+)$/;
        #    my $gff = "$val/$name.gff";
	#    
	#    syste(); # something
        #}
    }
    close($IN);

    my $t_dir = "$job_dir/$r_dir/snap.training";
    my $t_file = "$t_dir/$job_id.hmm";
    if(-f $t_file){
	my ($user_id) = $dbh->selectrow_array(qq{SELECT user_id FROM jobs WHERE job_id=$job_id});
	my ($name) = $dbh->selectrow_array(qq{SELECT name FROM jobs WHERE job_id=$job_id});
	$name =~ s/\- Post Processing$//;
	File::Path::mkpath("$data_dir/users/$user_id");
	my $n_file = "$data_dir/users/$user_id/$job_id.hmm";
	system("cp $t_file $n_file");
	my $length = @{[stat($n_file)]}[7];

	dbh_do_commit($dbh, qq{INSERT INTO files (name, value, type, length, contig_count, user_id) }.
		      qq{VALUES ('$name job:$job_id', '$n_file', 'snaphmm', '$length', '0', $user_id)}, $CTL_OPT{data_dir});
    }

    my $date = MWAS_util::date_time();
    dbh_do_commit($dbh, qq{UPDATE jobs SET is_packaged=1, finish_time='$date' WHERE job_id=$job_id}, $CTL_OPT{data_dir});
}
#------------------------------------------------------------------------
#starts a maker process for a given job
sub start_job {
    my $job_id = shift @_;
    my %CTL_OPT = %{shift @_}; #makes a copy of the control options
    my $dbh = shift;

    #identify if the the user the job belongs to
    my ($user_id, $type) = $dbh->selectrow_array(qq{SELECT user_id, type FROM jobs WHERE job_id=$job_id});

    ####===lock the database so no changes are made until the job is started
    my $lock = lockDB($CTL_OPT{data_dir}) || ((print STDERR lock_error()) & (return 0));

    #identify if the the user the job belongs to is active
    my ($owner) = $dbh->selectrow_array(qq{SELECT user_id FROM users WHERE user_id=$user_id});
    
    if(! $owner){ #the user was deleted, so we need to clean up their job
	print STDERR "ERROR: Job '$job_id' from inactive user '$user_id' must be deleted.\t".MWAS_util::date_time();
	$dbh->do(qq{DELETE FROM jobs WHERE job_id=$job_id});
	$dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=$job_id});
	#$dbh->commit;
	$lock->unlock;
	return 0;
    }
    
    #make sure I can still start this job
    my ($status) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE (is_queued=1 or is_running=1) and is_finished=0 and is_error=0});
    
    if($status){ #job can be started
	my $date = MWAS_util::date_time();
	print STDERR "Starting job: $job_id for user: $user_id\t$date\n";

	$dbh->do(qq{UPDATE jobs SET start_time='$date' WHERE job_id=$job_id and is_started=0});	
	$dbh->do(qq{UPDATE jobs SET is_queued=0, is_started=1 WHERE job_id=$job_id}); #for existing jobs
	#$dbh->commit;
    }
    else{ #job is finished or deleted
	$lock->unlock;
	return 0;
    }

    $lock->unlock;
    ####===unlock
    
    #make directories for running maker
    my $user_dir = "$CTL_OPT{data_dir}/users/$user_id";
    my $job_dir = "$CTL_OPT{data_dir}/jobs/$job_id";
    File::Path::mkpath($user_dir) if(! -d $user_dir);
    File::Path::mkpath($job_dir) if(! -d $job_dir);
    
    #build control files for job
    my $job_ctl = $dbh->selectrow_hashref(qq{SELECT * FROM ctl_opt WHERE job_id=$job_id});

    #check if a finished job used these exact same settings
    if(my $other_job_id = MWAS_util::package_already_exists($dbh, $job_ctl, $user_id)){
	MWAS_util::copy_package($dbh, $other_job_id, $job_id);
	dbh_do_commit($dbh, qq{UPDATE jobs SET is_queued=0, is_finished=1, is_packaged=1 WHERE job_id=$job_id}, $CTL_OPT{data_dir});
	return;
    }

    %CTL_OPT = (%CTL_OPT, %{$job_ctl}); #override current defaults with user values
    GI::generate_control_files($job_dir, 'all', \%CTL_OPT) if(! -f "$job_dir/maker_opts.ctl" ||
							      ! -f "$job_dir/maker_bopts.ctl" ||
							      ! -f "$job_dir/maker_exe.ctl" );
    $dbh->disconnect; #disconnect before forking

    #rebuild connection string
    my $dsn = "DBI:$CTL_OPT{DBI}:dbname=";
    $dsn .= "$CTL_OPT{data_dir}/" if($CTL_OPT{DBI} eq 'SQLite');
    $dsn .= "$CTL_OPT{dbname};";
    $dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
    $dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});

    #fork off the MAKER proccess and return process id of the child
    FORK: { 
	my $pid;
	if (!$DEBUG && ($pid=fork())) { # this is the parent, so return the pid
			 # everything below here is either the child or a very major 
	                 # system failure

	    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password})
		or die "<br>Got error $DBI::errstr when connecting to database\n";	    

	    return $pid;
	}
	elsif ($DEBUG || defined $pid){ #this is the child
	    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password})
		or die "<br>Got error $DBI::errstr when connecting to database\n";

	    ####===lock the database so no changes are made until the job is started
	    my $lock = lockDB($CTL_OPT{data_dir}) || ((print STDERR lock_error()) && (exit(0)));

	    #get current cpu usage and increment
	    my ($job_cpus) = $dbh->selectrow_array(qq{SELECT cpus FROM jobs WHERE job_id=$job_id});
	    $job_cpus++;
	    $dbh->do(qq{UPDATE jobs SET is_queued=0, is_running=1, cpus=$job_cpus WHERE job_id=$job_id});
	    
	    my $job_log = "$job_dir/job.log";

	    #run maker
	    my $command;
	    if(! $type || $type eq 'maker'){
		$command = "$FindBin::RealBin/../../bin/maker -qq -base $job_id";
	    }
	    elsif($type eq 'functional'){
		my $args = "$job_id $CTL_OPT{domain} $CTL_OPT{function} $CTL_OPT{snap_train} $CTL_OPT{short_name}";
		$command = "$FindBin::RealBin/../../bin/maker_functional $args";
	    }

	    chdir($job_dir);
	    my $pid = open3(undef, undef, \*CHLD_ERR, $command);
	    open(my $OUT, "> $job_log");

	    #$dbh->commit;
	    $dbh->disconnect; #disconnect from DB while job runs
	    $lock->unlock;
    	    ####===unlock

	    #collect output and STDERR
	    while (my $line = <CHLD_ERR>){
		print $OUT $line;
	    }
	    close($OUT);
	    waitpid $pid, 0;
	    my $err = $?;
	    chdir($CWD);

	    #job is finished reconnect to DB to set values
	    $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password})
		or die "<br>Got error $DBI::errstr when connecting to database\n";

	    ####===lock the database so no changes are made while I'm writing
	    $lock = lockDB($CTL_OPT{data_dir}) || ((print STDERR lock_error()) & (exit(0)));

	    #get current cpu usage and increment
	    ($job_cpus) = $dbh->selectrow_array(qq{SELECT cpus FROM jobs WHERE job_id=$job_id});
	    $job_cpus--;
	    
	    if($err){
		$dbh->do(qq{UPDATE jobs SET is_error=1, cpus=$job_cpus WHERE job_id=$job_id});
		print STDERR "Failed job: $job_id for user: $user_id\t".MWAS_util::date_time()."\n";
	    }
	    else{
		my $date = MWAS_util::date_time();
		$dbh->do(qq{UPDATE jobs SET is_finished=1, cpus=$job_cpus WHERE job_id=$job_id});
		print STDERR "Finished job: $job_id for user: $user_id\t$date\n";
	    }

	    #$dbh->commit;
	    $dbh->disconnect;
	    $lock->unlock;
	    ####===unlock

	    return if($DEBUG);
	    exit(0); #finished
	}
	elsif ($! == EAGAIN)  {
	    #fork failed try again
	    sleep 3;
	    redo FORK;
	}
	else {
	    print STDERR "ERROR: Can not start fork for MAKER.\t".MWAS_util::date_time()."\n$!";

	    return 0;
	}
    }
}
#------------------------------------------------------------------------
#lock for updating the database
sub lockDB {
    return MWAS_util::lockDB(@_);
}
#------------------------------------------------------------------------
sub lock_error {
    print STDERR "ERROR: Could not get lock on database:\t".MWAS_util::date_time()."\n";
}
#------------------------------------------------------------------------
sub dbh_do_commit {
    return MWAS_util::dbh_do_commit(@_);
}
#------------------------------------------------------------------------
# from CPAN module Net::Server::Daemonize
# uses posix to avoid issues related to changing $> $< $) and $( in perl
sub set_uid {
    my $uid = get_uid( shift() );
    POSIX::setuid($uid);
    if ($< != $uid || $> != $uid) { # check $> also (rt #21262)
	$< = $> = $uid; # try again-needed by some 5.8.0 linux systems (rt #13450)
	if ($< != $uid) {
	    die "Couldn't become uid \"$uid\": $!\n";
	}
    }
    return 1;
}
#------------------------------------------------------------------------
# from CPAN module Net::Server::Daemonize
# uses posix to avoid issues related to changing $> $< $) and $( in perl
sub set_gid {
    my $gids = get_gid( @_ );
    my $gid  = (split /\s+/, $gids)[0];
    eval { $) = $gids }; # store all the gids - this is really sort of optional
    POSIX::setgid($gid);
    if (! grep {$gid == $_} split /\s+/, $() { # look for any valid id in list
	die "Couldn't become gid \"$gid\": $!\n";
    }
    return 1;
}
#------------------------------------------------------------------------
# from CPAN module Net::Server::Daemonize
# uses posix to avoid issues related to changing $> $< $) and $( in perl
sub get_uid ($) {
    my $user = shift;
    my $uid  = undef;

    if( $user =~ /^\d+$/ ){
	$uid = $user;
    }else{
	$uid = getpwnam($user);
    }

    die "No such user \"$user\"\n" unless defined $uid;

    return $uid;
}
#------------------------------------------------------------------------
# from CPAN module Net::Server::Daemonize
# uses posix to avoid issues related to changing $> $< $) and $( in perl
sub get_gid {
    my @gid  = ();

    foreach my $group ( split( /[, ]+/, join(" ",@_) ) ){
	if( $group =~ /^\d+$/ ){
	    push @gid, $group;
	}else{
	    my $id = getgrnam($group);
	    die "No such group \"$group\"\n" unless defined $id;
	    push @gid, $id;
	}
    }

    die "No group found in arguments.\n" unless @gid;

    return join(" ",$gid[0],@gid);
}
