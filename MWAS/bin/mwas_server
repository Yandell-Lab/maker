#!/usr/bin/env perl

#Maker server 2.0-------------------------------------------------
# is being run to serve maker queue. mwas_server is
# an inifinite loop to check the queue and execute maker jobs as
# soon as they are added to the maker queue.
#-------------------------------------------------------------hadi islam

use strict;
use warnings;
use DBI;
use Mail::Sender;
use vars qw($LOG %CTL_OPT $EXE $DEBUG $CWD);
use POSIX qw(:sys_wait_h setsid setuid setgid EAGAIN);
use Template;
use FindBin;
use lib "$FindBin::RealBin/../../lib"; #/maker/lib?
use lib "$FindBin::RealBin/../../perl/lib"; #/maker/perl/lib?
use lib "$FindBin::RealBin/../../maker/lib"; #/maker/lib?
use lib "$FindBin::RealBin/../../maker/perl/lib"; #/maker/perl/lib?
use lib "$FindBin::RealBin/../lib"; #/MWAS/lib
use lib "$FindBin::RealBin/../perl/lib"; #/MWAS/perl/lib
use Proc::Signal;
use File::NFSLock;
use File::Path qw(mkpath rmtree);
use IPC::Open3;
use Cwd;

BEGIN{
    if (not ($ENV{CGL_SO_SOURCE})) {
	$ENV{CGL_SO_SOURCE} = "$FindBin::RealBin/../../lib/CGL/so.obo";
    }
    if (not ($ENV{CGL_GO_SOURCE})) {
	$ENV{CGL_GO_SOURCE} = "$FindBin::RealBin/../../lib/CGL/gene_ontology.obo"
    }

    #get my own name
    $EXE = $FindBin::Script;

    #LOG file
    $LOG = "$FindBin::Bin/../MWAS.log";

    #must give group members access i.e. apache group
    umask 0002;

    #set debugging mode
    $DEBUG=0;

    #current working directory
    $CWD = Cwd::cwd();

    #stop signal subroutine
    my $exit =  sub{die "STATUS: Caught @_ exiting.\t".MWAS_util::date_time()."\n";};

    #Signals to trap and handle
    $SIG{'INT' } = $exit;
    $SIG{'ABRT'} = $exit; 
    $SIG{'QUIT'} = $exit;
    $SIG{'TRAP'} = $exit;
    $SIG{'STOP'} = $exit;
    $SIG{'TERM'} = $exit;
    $SIG{'HUP'} = sub{print STDERR "STATUS: Signal @_ received, attempting to restart $EXE\t".MWAS_util::date_time()."\n";
		      close(STDERR);
		      exec($FindBin::RealScript, @ARGV);
		     };
}

use GI;
use MWAS_util;


my $usage = "
Usage:
     mwas_server [option]

     This is a daemon responsible for the operation of the MAKER Web Annotation
     Service (MWAS).  The daemon checks an SQL database for job submissions and
     then runs MAKER for those jobs.  You must supply an option when executing
     the mwas_server script otherwise it will just return the usage statement.

     Please note that you can also use maker with the -MWAS option to control
     the mwas_server daemon instead of using the mwas_server script directly
     (i.e. maker -MWAS START is the equivilent of mwas_server START).

     The behavior of the MAKER Web Annotation Service and mwas_server is
     dependant on control files found in the /MWAS/config directory. There are
     five files:  server.ctl, menus.ctl, maker_opts.ctl, maker_bopts.ctl, and
     maker_exe.ctl.  If these files are missing they can be regenerate by
     calling the CONFIG with mwas_server (i.e. mwas_server CONFIG).

     The server.ctl file is used to configure server specific and some web
     interface specific options.  The database used by mwas_server is
     configured here.  By default, mwas_server will create a database using
     SQLite, but you can designate any SQL database supported by the Perl DBI.

     The menus.ctl file in the MWAS/config directory is used to configure
     dropdown menus displayed by the web interface.  This file follows Perl
     syntax and is loaded and generated by Data::Dumper.

     The maker_opts.ctl, maker_bopts.ctl, and maker_exe.ctl files are
     equilvilent to the control files used by MAKER when running a job.  See
     the MAKER documentation for an explanation of the values.  The MAKER Web
     Annotation Service uses these files to define default values presented to
     users in the web interface.  These files also supports tags that configure
     how options are presented to users in the web interface.  Adding the tag 
     =STATIC to the end of a value makes it so the user can see but not alter
     a value in the web interface.  Adding the tag =DISABLED hides the value
     and related menu sections from the web interface.

     The MAKER Web Annotation Service has two parts.  A web interface front end
     that users access via a browser to configure a MAKER job, and a server
     backend that monitor for job submissions and executes MAKER.  The
     mwas_server script is responsible for the back end, but can be used to
     generate the front end CGI/HTML in the directory of your choosing (i.e a
     web accessible directy like /var/www/cgi-bin/maker for Apache).  To do 
     this use the CGI option (don't forget to specify the value for the
     directory in the server.ctl file afterward).


Options:

     STATUS      Checks the status of the MAKER server.

     START       Starts the daemon.

     RESTART     Shutsdown and then restarts the daemon.

     STOP        Shuts down the daemon. SHUTDOWN, QUIT, and KILL are also
                 accepted.

     PREP        Generates server control file in the /MWAS/config
                 directory, does not destroy existing files. Run before CONFIG
                 as some defaults are dependent on server settings.

     CONFIG      Generates default control files in the /MWAS/config
                 directory, does not destroy existing files.

     SETUP       Setup the GGI/HTML files needed to launch the web interface.
                 Also sets up the database that the web interface will use.
                 You  must set cgi_dir, html_dir, DBI, and dbname in
                 MWAS/config/server.ctl before running SETUP.

     APOLLO      Setup a webstart version of Apollo for browsing job results. 
                 You must set APOLLO_ROOT in MWAS/config/server.ctl first.

     GBROWSE     Configure GBrowse to view MWAS job results. You must set
                 GBROWSE_MASTER in MWAS/config/server.ctl first.

     HELP        Prints this usage statement

";

#------------------------------------------------------------------------
#-------------------------------- MAIN ----------------------------------
#------------------------------------------------------------------------

#lets downstream maker libraries know this is the server app
$main::server = 1;

#proccess command line options
my $opt = uc($ARGV[0]) || 'HELP';
$opt =~ s/^\-+|^\=+//; #fix -'s or ='s in options
$opt = 'HELP' if($opt eq '?'); #also accept ?
$opt = 'STOP' if($opt =~ /^SHUTDOWN$|^KILL$|^QUIT$|^DIE$|^DIEDIE$/); #also accept SHUTDOWN, KILL, or QUIT

#find control files and load them
my $c_dir = "$FindBin::RealBin/../config/"; #configuration file directory
my @files = ("$c_dir/maker_opts.ctl",
	     "$c_dir/maker_bopts.ctl",
	     "$c_dir/maker_exe.ctl",
	     "$c_dir/server.ctl",
	     "$c_dir/menus.ctl",
	     );
my @exists = grep {-f $_} @files;

%CTL_OPT = GI::load_server_files(\@exists);


if($opt eq 'HELP'){
    print $usage;
    exit(1);
}
elsif($opt eq 'STATUS'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
        print STDERR "STATUS: $EXE is not currently running\n";
    }
    elsif(! $signalable){
        die "ERROR: $EXE is running but you do not have the correct ".
	    "permissions to manage it\n\n";
    }
    else{
        print STDERR "STATUS: $EXE is running\n";
     }
}
elsif($opt eq 'PREP'){
    GI::generate_control_files($c_dir,'server', \%CTL_OPT);
}
elsif($opt eq 'CONFIG' | $opt eq 'CTL'){
    GI::generate_control_files($c_dir,'all',\%CTL_OPT);
    GI::generate_control_files($c_dir,'server', \%CTL_OPT);
    GI::generate_control_files($c_dir,'menus', \%CTL_OPT);
}
elsif($opt eq 'SETUP'){
    #error checking
    if(@exists < @files){
	die "ERROR: You must run $EXE with the PREP and CONFIG options first to create\n".
	    "MAKER configuration files. Once you are finished building and editing these\n".
	    "files you can run $EXE with the SETUP option, to build the web interface.\n\n";
    }

    my $cgi_dir  = $CTL_OPT{cgi_dir};  #get directory to build CGI files
    my $html_dir = $CTL_OPT{html_dir}; #get directory to build HTML files
    my $data_dir = $CTL_OPT{data_dir}; #get directory for storing data

    #make directories if they don't exist
    foreach my $dir ($cgi_dir, $html_dir, $data_dir){
	my $base = $dir;
	$base =~ s/[^\/]+\/?$//;
	if(-d $base && ! -d $dir){
	    mkdir($dir) or warn "ERROR: Could not create directory. Do you have\n".
		"sufficient privileges to do this?\n\n";
	}
    }

    die "ERROR: You must supply a directory for cgi_dir\n".
	"to install CGI files\n" if(! $cgi_dir);
    die "ERROR: You must supply a directory for html_dir\n".
	"to install HTML files\n" if(! $html_dir);
    die "ERROR: You must supply a directory for data_dir\n".
	"to store user files and jobs\n" if(! $data_dir);

    die "ERROR: The directory '$cgi_dir' does not exist\n" if(! -d $cgi_dir);
    die "ERROR: The directory '$html_dir' does not exist\n" if(! -d $html_dir);
    die "ERROR: The directory '$data_dir' does not exist\n" if(! -d $data_dir);

    #set up correct ownership
    system("chown -R :$CTL_OPT{apache_user} $cgi_dir") &&
	die "ERROR: Could not establish ownership for $cgi_dir\n".
	"You may need to log in as 'root' for setup\n\n";
#	unless(getgrgid((stat $cgi_dir)[5]) eq $CTL_OPT{apache_user});

    system("chown -R :$CTL_OPT{apache_user} $html_dir") &&
	die "ERROR: Could not establish ownership for $html_dir\n".
	"You may need to log in as 'root' for setup\n\n";
#	unless(getgrgid((stat $html_dir)[5]) eq $CTL_OPT{apache_user});

    system("chown :$CTL_OPT{apache_user} $data_dir") &&
	die "ERROR: Could not establish ownership for $data_dir\n".
	"You may need to log in as 'root' for setup\n\n";
#	unless(getgrgid((stat $data_dir)[5]) eq $CTL_OPT{apache_user});

    #set directory guid to preserve permissions on new files in directory
    system("chmod 2775 $cgi_dir") &&
	die "ERROR: Could not establish permissions for $cgi_dir\n".
	"You may need to log in as 'root' for setup\n\n";
#	unless((sprintf "%04o", (stat $cgi_dir)[2] & 07777)  == 2775);
    
    system("chmod 2775 $html_dir") &&
	die "ERROR: Could not establish permissions for $html_dir\n".
	"You may need to log in as 'root' for setup\n\n";
#	unless((sprintf "%04o", (stat $html_dir)[2] & 07777)  == 2775);
    
    system("chmod 2775 $data_dir") &&
	die "ERROR: Could not establish permissions for $data_dir\n".
	"You may need to log in as 'root' for setup\n\n";
#	unless((sprintf "%04o", (stat $data_dir)[2] & 07777)  == 2775);

    #copy all cgi, html, and support files to a web accessible directory
    my $m_dir = "$FindBin::RealBin/../../"; #maker package base direcory
    my $co_dir = "$FindBin::RealBin/../cgi-bin/"; #original direcory
    my $ho_dir = "$FindBin::RealBin/../html/"; #original direcory
    my $m_lib = "$FindBin::RealBin/../../lib/"; #/maker/lib
    my $p_lib = "$FindBin::RealBin/../../perl/lib/"; #/maker/perl/lib
    mkdir("$cgi_dir/config/") if(! -d "$cgi_dir/config/");
    system("cp -R $co_dir/* $cgi_dir/") && die("ERROR: Copying files to $cgi_dir failed\n");
    system("cp -R $ho_dir/* $html_dir/") && die("ERROR: Copying files to $html_dir failed\n");
    system("cp -R $c_dir/* $cgi_dir/config/") && die("ERROR: Copying files to $cgi_dir failed\n");
    system("cp -R $m_lib/* $cgi_dir/lib/") && die("ERROR: Copying files to $cgi_dir failed\n");
    if(-d $p_lib){ #only exists when MPI is installed
	system("cp -R $p_lib/* $cgi_dir/lib/") && die("ERROR: Copying files to $cgi_dir failed\n");
    }

    #copy maker executables
    mkdir("$data_dir/maker") if(! -d "$data_dir/maker");
    system("cp -R $m_dir/* $data_dir/maker/") && die("ERROR: Copying files to $data_dir/maker/ failed\n");

    #recursively set group permission to write for all files in the directory
    system("chmod -R g+w $cgi_dir") &&
	die "ERROR: Could not establish permissions for $cgi_dir\n".
	    "You may need to log in as 'root' for setup\n\n";

    system("chmod -R g+w $html_dir") &&
	die "ERROR: Could not establish permissions for $html_dir\n".
	    "You may need to log in as 'root' for setup\n\n";

    system("chmod -R g+w $data_dir/maker") &&
	die "ERROR: Could not establish permissions for $data_dir\n".
	    "You may need to log in as 'root' for setup\n\n";

    #build redirection page (so user can see directories if apache is not configured)
    open(OUT, "> $html_dir/index.html");
    my $url = ($CTL_OPT{cgi_web} =~ /\:\/\//) ?  $CTL_OPT{cgi_web} : "$CTL_OPT{web_address}/$CTL_OPT{cgi_web}";
    $url .= "/maker.cgi";
    $url =~ s/([^:])\/\//$1\//g;
    print OUT "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n".
	      "<HTML>\n".
	      "<meta http-equiv=\"REFRESH\" content=\"0;url=$url\">\n".
	      "</HTML>";
    close(OUT);

    #DB error checking
    if($CTL_OPT{DBI} && $CTL_OPT{dbname}){
	#try to connect to the database as a test
	my $dsn = "DBI:$CTL_OPT{DBI}:dbname=";
	$dsn .= "$CTL_OPT{data_dir}/" if($CTL_OPT{DBI} eq 'SQLite');
	$dsn .= "$CTL_OPT{dbname};";
	$dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
	$dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});

	if(!$CTL_OPT{username}){ #warn if no db_username specified
	    warn "WARNING: No username for connecting to the database is specified.\n".
		"Without a username, online requests to MWAS will fail because of\n".
		"permission issues. Please make the necessary changes to server.ctl.\n\n";
	}

	my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0, RaiseError => 1})
	    or die "<br>Got error $DBI::errstr when connecting to database\n";

	#fix permissions on SQLite database
	if($CTL_OPT{DBI} eq 'SQLite'){
	    my $db = "$CTL_OPT{data_dir}/$CTL_OPT{dbname}";
	    unless((sprintf "%04o", (stat $db)[2] & 07777)  == 0774){
		system("chmod 774 $db") &&
		    die "ERROR: Could not establish permissions for $db\n".
		    "You may need to log in as 'root' for setup\n\n";
	    }
	}

	#setup the database
	check_table_structure($dbh);
	reset_queue($dbh);
	$dbh->disconnect;

	#set up correct ownership
	system("chown -R :$CTL_OPT{apache_user} $cgi_dir") &&
	    die "ERROR: Could not establish ownership for $cgi_dir\n".
	    "You may need to log in as 'root' for setup\n\n";
	
	system("chown -R :$CTL_OPT{apache_user} $html_dir") &&
	    die "ERROR: Could not establish ownership for $html_dir\n".
	    "You may need to log in as 'root' for setup\n\n";

	system("chown -R :$CTL_OPT{apache_user} $data_dir/maker") &&
	    die "ERROR: Could not establish ownership for $data_dir/maker\n".
	    "You may need to log in as 'root' for setup\n\n";

	system("chown -R :$CTL_OPT{apache_user} $data_dir/maker") &&
	    die "ERROR: Could not establish ownership for $data_dir/maker\n".
	    "You may need to log in as 'root' for setup\n\n";
    }
    else{
	die "ERROR: Could not setup the database structure because no database\n".
	    "or database interface is specified in server.ctl.  Please finish\n".
	    "editing the control files and run SETUP again.\n\n";
    }
}
elsif($opt eq 'APOLLO'){
    #go the extra mile and try and setup apollo webstart
    if($CTL_OPT{APOLLO_ROOT}){
	my $html_dir = $CTL_OPT{html_dir};

	#set up directory for web
	my (undef, $t_xml) = File::Temp::tempfile();
	mkdir("$html_dir/jars") if(! -d "$html_dir/jars");

	#create generate Apollo webstart
	my $tt_xml = "$FindBin::RealBin/../cgi-bin/tt_templates/apollo_webstart.tt";
	$ENV{APOLLO_ROOT} = $CTL_OPT{APOLLO_ROOT};
	system("$CTL_OPT{APOLLO_ROOT}/bin/webstart_generator.pl -i $tt_xml -d ".
	       "$CTL_OPT{APOLLO_ROOT}/jars -o $c_dir/apollo.jnlp -D $html_dir/jars") &&
	       die "ERROR: Generating Apollo webstart jars and jnlp file failed\n";
    }
    else{
	die "ERROR: You must suply a value for APOLLO_ROOT in server.ctl to\n".
	    "setup Apollo for use with the MAKER web interface\n\n";
    }
}
elsif($opt eq 'GBROWSE'){
    #go the extra mile and try and configure GBROWSE
    if($CTL_OPT{GBROWSE_MASTER}){
	my $old = $CTL_OPT{GBROWSE_MASTER};
	my $new = "$CTL_OPT{GBROWSE_MASTER}.new";

	die "ERROR: The file specified in GBROWSE_MASTER '$old' does not exist\n"
	    if(! -e $old);

	#make a new configuration file
	open(IN, "< $old") or die "ERROR: Could not open $old\n";
	open(OUT, "> $new") or die "ERROR: Could not open $new\n";

	my $section = ''; #keeps track of what section in the config file I am in
	while(my $line = <IN>){
	    #identify section header
	    if($line =~ /^[^\#\=]*\[([^\]]+)\][^\=]*$/){
		$section = $1;
	    }

	    print OUT $line unless($section =~ /^\=\~MWAS_/); #skip MAKER section
	}

	close(IN);

	#now add the MAKER section to GBrowse config file
	print OUT "\n[=~MWAS_(\\d+)_(\\d+)]\n";
	print OUT "description = MAKER Web Annotation Service\n";
	print OUT "path        = $CTL_OPT{cgi_dir}/stream.cgi type gbrowse user_id \$1 job_id \$2 |\n";
	close(OUT);

	#now replace old file
	system("mv $new $old") && die "ERROR: Could not replace existing GBrowse configuration file\n";
    }
    else{
	die "ERROR: You must suply a value for GBROWSE_MASTER in server.ctl to\n".
	    "setup GBROWSE for use with the MAKER web interface\n\n";
    }
}
elsif($opt eq 'RESTART'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
	print STDERR "STATUS:  is not currently running\n";
	exec($FindBin::RealScript, 'START');
    }
    elsif(! $signalable){
	die "ERROR: you do not have the correct permissions to restart $EXE\n";
    }
    else{
	print STDERR "STATUS: Trying to restart $EXE\n";
	my $stat = Proc::Signal::killall('HUP', "$EXE");
	if($stat){
	    print STDERR "STATUS: $EXE was restarted successfully\n";
	}
	else{
	    print STDERR "ERROR: Could not restart $EXE!\n";
	}
    }
}
elsif($opt eq 'STOP'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
	print STDERR "STATUS: $EXE is not currently running\n";
    }
    elsif(! $signalable){
	die "ERROR: you do not have the correct permissions to stop $EXE\n";
    }
    else{
	print STDERR "STATUS: Trying to stop $EXE\n";
	my $stat = Proc::Signal::killall('QUIT', "$EXE");
	my $run = Proc::Signal::exists_proc_by_name("$EXE");
	if($stat && ! $run){
	    print STDERR "STATUS: $EXE was stopped successfully\n";
	    exit(0);
	}
	else{
	    print STDERR "ERROR: Could not stop $EXE!\n";
	}

	#server is still running try a more agressive approach
	print STDERR "STATUS: Agressively trying to stop $EXE\n";
	$stat = Proc::Signal::killall(9, "$EXE");
	$run = Proc::Signal::exists_proc_by_name("$EXE");
	if($stat && ! $run){
	    print STDERR "STATUS: $EXE was stopped successfully\n";
	    exit(0);
	}
	else{
	    print STDERR "ERROR: Could not stop $EXE!\n";
	}
    }
}
elsif($opt eq 'START'){
    my $exists = Proc::Signal::exists_proc_by_name("$EXE");

    if($exists){
	die "ERROR: $EXE is already running.\t".MWAS_util::date_time()."\n";
    }
    else{
	#set user id to be apache
	my ($usr_id, $grp_id) = (getpwnam($CTL_OPT{apache_user}))[2..3];

	if($usr_id != $> && ! $DEBUG){
	    chdir("//"); #change directory just incase
	    if(! $grp_id){
		die "ERROR: Can not find group id for apache user.  Make sure\n".
		    "apache is installed and the correct value is set for\n".
		    "apache_user in the server_opt.ctl file.\n\n"
	    }
	    set_gid($grp_id);
	    setpgrp(0, $grp_id) &&
		die "ERROR: Could not attach the server to the apache user group.\n".
		"You may need to add your current user to the apache user group\n".
		"or start the server usginG sudo\n\n";
	    set_uid($usr_id);

	    #launch with new user_id from data_dir copy
	    exec("$CTL_OPT{data_dir}/maker/MWAS/bin/$EXE", 'START');
	}

	print STDERR "STATUS: Now starting $EXE\!\n";
	    
	#error checking
	if(@exists < @files){
	    die "ERROR: Server control files are missing.  Run $EXE\n".
		"with the CONFIG option first to create the control files.\n".
		"Once you are finished building and editing these files\n".
		"run with the SETUP option to build all files necessary\n".
		"for client side web access to the server. Then you can\n".
		"start the server.\n\n";
	}


	#try to connect to the database as a test
	my $dsn = "DBI:$CTL_OPT{DBI}:dbname=";
	$dsn .= "$CTL_OPT{data_dir}/" if($CTL_OPT{DBI} eq 'SQLite');
        $dsn .= "$CTL_OPT{dbname};";
	$dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
	$dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});

	if(!$CTL_OPT{username}){ #warn if no db_username specified
	    warn "WARNING: No username for connecting to the database is specified\n".
		"without a username online requests to MWAS will fail because of\n".
		"permission issues. Please make the necessary changes to server.ctl.\n\n";
	}

	my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
	    or die "<br>Got error $DBI::errstr when connecting to database\n";
	$dbh->disconnect;

	#check permissions on data directory
	if(! -w $CTL_OPT{data_dir} || ! -r $CTL_OPT{data_dir} || ! -x $CTL_OPT{data_dir}){
	    die "ERROR: Current file permissions won't allow you to use $CTL_OPT{data_dir}\n".
		"as the ouput directory for the MAKER Web Annotation Service\n\n";
	}

	if($DEBUG){ #run server in forground for debugger
	    run_server();
	}
	else{#run server as a daemon
	    start_daemon();
	}
    }
}
else{
    print STDERR "ERROR: Invalid option: $opt\n\n";
    print $usage;
    exit(1);
}
#------------------------------------------------------------------------
#----------------------------- SUBROUTINES ------------------------------
#------------------------------------------------------------------------
sub start_daemon {
    unless(my $pid = fork()) {
	exit if $pid;
        setsid();
	my $date = MWAS_util::date_time();
	
	#rediret STDERR to the log file since there will be no terminal
	close(STDERR);
	open(STDERR, ">> $LOG"); #append

        print STDERR "STATUS: Starting $EXE.\t$date\n";
	run_server();
    }
}
#------------------------------------------------------------------------
#sens messages via e-mail i.e. errors or status reports
sub send_message{
    my $address = shift @_;
    my $smtp    = shift @_;
    my $subject = shift @_;
    my $msg     = shift @_;

    my $sender = Mail::Sender->new({smtp => $smtp});
    
    my $sq = $sender->MailMsg({to      => $address,
			       from    => "no-reply\@$smtp",
			       subject => $subject,
			       msg     => $msg
			      });
}
#------------------------------------------------------------------------
sub run_server {
    #load the control files
    my $c_dir = "$FindBin::RealBin/../config/"; #configuration file direcdtory
    %CTL_OPT = GI::load_server_files(["$c_dir/maker_opts.ctl",
				      "$c_dir/maker_bopts.ctl",
				      "$c_dir/maker_exe.ctl",
				      "$c_dir/server.ctl",
				      "$c_dir/menus.ctl",
				      ]);

    #make sure required database values are setup
    if(! $CTL_OPT{DBI}){
	die "ERROR: You must specify a DBI connection method in: $FindBin::RealBin/../config/server.ctl\n\n";
    }

    if(! $CTL_OPT{dbname}){
	die "ERROR: You must specify a database to connecty to in: $FindBin::RealBin/../config/server.ctl\n\n";
    }

    if(! $CTL_OPT{cgi_dir} || ! $CTL_OPT{html_dir}){
	die "ERROR: You must specify the directory where web content is installed in: $FindBin::RealBin/../config/server.ctl\n\n";
    }

    #try to connect to the database as a test
    my $dsn = "DBI:$CTL_OPT{DBI}:dbname=";
    $dsn .= "$CTL_OPT{data_dir}/" if($CTL_OPT{DBI} eq 'SQLite');
    $dsn .= "$CTL_OPT{dbname};";
    $dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
    $dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});
    
    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
	or die "<br>Got error $DBI::errstr when connecting to database\n";

    #correct everrything in db tables on startup 
    check_table_structure($dbh);
    reset_queue($dbh);

    #update web interface to current configuration
    my $w_dir = $CTL_OPT{cgi_dir}; #web accessible directory
    mkdir("$w_dir/config") if(! -d "$w_dir/config");
    system("cp -R $c_dir/* $w_dir/config/") && die("ERROR: Copying files to $w_dir failed\n");

    $dbh->disconnect; #database found successfully

    #load environmental variables needed to run dependancies
    $ENV{APOLLO_ROOT} = $CTL_OPT{APOLLO_ROOT};
    $ENV{ZOE} = $CTL_OPT{ZOE};
    $ENV{AUGUSTUS_CONFIG_PATH} = $CTL_OPT{AUGUSTUS_CONFIG_PATH};

    #start continuous loop for constant server operation
    my %running; #holds ids of all forks associated with a job

    #connect to database

    while(1){
	my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
	    or die "<br>Got error $DBI::errstr when connecting to database\n";
	#========check on jobs and package data for finished jobs
	
	#look at all active jobs
	while(my $jid = each %running){
	    my @still_running;
	    foreach my $child (@{$running{$jid}}){
		my $stat = waitpid($child, WNOHANG); #nonblocking check of proccess id
		push(@still_running, $child) if($stat == 0); #keep those that aren't finished
	    }

	    #has there been a change in the number of active children?
	    next if(@still_running == @{$running{$jid}});

	    #update active children
	    $running{$jid} = \@still_running;
	    
	    #update cpus entry in table to reflect the true number of active children
	    dbh_do_commit($dbh, qq{UPDATE jobs SET cpus=}.@still_running.qq{ WHERE job_id=$jid});

	    #if all children are inactive
	    if(!@still_running){
		#reset is_running to reflect cpu changes
		dbh_do_commit($dbh, qq{UPDATE jobs SET is_running=0, cpus=0 WHERE job_id=$jid});

		#see if MAKER is really finished
		my ($finished) = $dbh->selectrow_array(qq{SELECT is_finished FROM jobs WHERE job_id=$jid});
		if(!$finished){
		    #not finished, put job back in queue as long as it's not failed
		    dbh_do_commit($dbh, qq{UPDATE jobs SET is_queued=1 WHERE job_id=$jid and is_error=0});
		    delete($running{$jid}); #clear hash key
		}
		else{
		    #All finished, package data for user to download
		    clean_and_package($jid, $CTL_OPT{data_dir}, $dbh);
		    delete($running{$jid}); #clear hash key
		}
	    }
	}

	#========try and start or increase resources to new jobs

	#count all active cpus
	my $cpus = 0;
	grep {$cpus += $_} @{$dbh->selectcol_arrayref(qq{SELECT cpus FROM jobs WHERE is_running=1})}; #use grep to sum

	#if no resources are available just wait
	if($cpus >= $CTL_OPT{max_cpus}){
	    sleep 20;
	    $dbh->disconnect;
	    next;
	}
	
	#check for available jobs in queue
	my ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE is_queued=1 and admin_block=0 and is_error=0 and is_finished=0 ORDER BY submit_id LIMIT 1});
	
	if(! $job_id){ #no job in queue
	    #see if I can give extra cpus to existing jobs
	    ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE is_running=1 and cpus }.
					      qq{< $CTL_OPT{job_cpus} and is_finished=0 and admin_block=0 }.
					      qq{and is_error=0 ORDER BY submit_id LIMIT 1});

	    if($job_id){ #give more cpus to the job
		my $child = start_job($job_id, \%CTL_OPT, $dbh);
		push(@{$running{$job_id}}, $child) if($child);
		$dbh->disconnect;
		next;
	    }
	    else{#no free cpus, just wait
		$dbh->disconnect;
		sleep 10;
		next;
	    }
	}
	else{ #there's a job, run it
	    my $child = start_job($job_id, \%CTL_OPT, $dbh);
	    push(@{$running{$job_id}}, $child) if($child);
	    $dbh->disconnect;
	    next;
	}
	$dbh->disconnect;
    }
}
#------------------------------------------------------------------------
sub clean_and_package {
    my $job_id   = shift;
    my $data_dir = shift;
    my $dbh      = shift;

    my ($packaged) = $dbh->selectrow_array(qq{SELECT is_packaged FROM jobs WHERE job_id=$job_id});

    #already packaged, move on
    return if($packaged);

    #get job run directory
    my $job_dir = "$data_dir/jobs/$job_id/";

    #get result directory
    my $r_dir = "$job_id.maker.output";
    #where did the results go? run again
    if(! -d "$job_dir/$r_dir"){
	dbh_do_commit($dbh, qq{UPDATE jobs SET is_queued=1, is_finished=0 WHERE job_id=$job_id and is_error=0});
	return;
    }

    #delete extra files from maker output directory
    my @to_delete = (<$job_dir/$r_dir/mpi_blastdb>, <$job_dir/$r_dir/seen.dbm>, <$job_dir/$r_dir/*.db>, <$job_dir/$r_dir/*lock*>);
    foreach my $f (@to_delete){
	unlink($f) if(-f $f);
	File::Path::rmtree($f) if(-d $f);
    }

    #build merged gff3 and fasta files
    system("cd $job_dir/$r_dir\n".
	   "$FindBin::RealBin/../../bin/gff3_merge -d $job_id\_master_datastore_index.log\n".
	   "$FindBin::RealBin/../../bin/fasta_merge -d $job_id\_master_datastore_index.log");

    #wrap everything up into a nice package
    system("cd $job_dir\n".
	   "tar --exclude \"theVoid\*\" --exclude \"seen.dbm\" --exclude \"mpi_blastdb\" -zcf $r_dir.tar.gz $r_dir") &&
	   die("ERROR: Building tarball for job '$job_id' failed\n");

    my $index = "$job_dir/$r_dir/$job_id\_master_datastore_index.log";
    open(my $IN, "< $index");
    while(my $line = <$IN>){
        chomp $line;
        my @data = split("\t", $line);

        #if($data[2] eq 'FINISHED'){
        #    my $val = "$job_dir/$r_dir/$data[1]";
        #    $val =~ s/[\/]+$//;
        #    my ($name) = $val =~ /([^\/]+)$/;
        #    my $gff = "$val/$name.gff";
	#    
	#    syste(); # something
        #}
    }
    close($IN);


    my $date = MWAS_util::date_time();
    dbh_do_commit($dbh, qq{UPDATE jobs SET is_packaged=1, finish_time='$date' WHERE job_id=$job_id});
}
#------------------------------------------------------------------------
#starts a maker process for a given job
sub start_job {
    my $job_id = shift @_;
    my %CTL_OPT = %{shift @_}; #makes a copy of the control options
    my $dbh = shift;

    #identify if the the user the job belongs to
    my ($user_id, $type) = $dbh->selectrow_array(qq{SELECT user_id, type FROM jobs WHERE job_id=$job_id});

    ####===lock the database so no changes are made until the job is started
    my $lock = lockDB() || ((print STDERR lock_error()) & (return 0));

    #identify if the the user the job belongs to is active
    my ($owner) = $dbh->selectrow_array(qq{SELECT user_id FROM users WHERE user_id=$user_id});
    
    if(! $owner){ #the user was deleted, so we need to clean up their job
	print STDERR "ERROR: Job '$job_id' from inactive user '$user_id' must be deleted.\t".MWAS_util::date_time();
	$dbh->do(qq{DELETE FROM jobs WHERE job_id=$job_id});
	$dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=$job_id});
	$dbh->commit;
	return 0;
    }
    
    #make sure I can still start this job
    my ($status) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE (is_queued=1 or is_running=1) and is_finished=0 and is_error=0});
    
    if($status){ #job can be started
	my $date = MWAS_util::date_time();
	print STDERR "Starting job: $job_id for user: $user_id\t$date\n";

	$dbh->do(qq{UPDATE jobs SET start_time='$date' WHERE job_id=$job_id and is_started=0});	
	$dbh->do(qq{UPDATE jobs SET is_queued=0, is_started=1 WHERE job_id=$job_id}); #for existing jobs
	$dbh->commit;
    }
    else{ #job is finished or deleted
	return 0;
    }

    $lock->unlock;
    ####===unlock
    
    #make directories for running maker
    my $user_dir = "$CTL_OPT{data_dir}/users/$user_id";
    my $job_dir = "$CTL_OPT{data_dir}/jobs/$job_id";
    File::Path::mkpath($user_dir) if(! -d $user_dir);
    File::Path::mkpath($job_dir) if(! -d $job_dir);
    
    #build control files for job
    my $job_ctl = $dbh->selectrow_hashref(qq{SELECT * FROM ctl_opt WHERE job_id=$job_id});

    #check if a finished job used these exact same settings
    if(my $other_job_id = MWAS_util::package_already_exists($dbh, $job_ctl, $user_id)){
	$dbh->do(qq{UPDATE jobs SET is_queued=0, is_finished=1, is_packaged=1 WHERE job_id=$job_id});
	MWAS_util::copy_package($dbh, $other_job_id, $job_id);
	$dbh->commit;
	return;
    }

    %CTL_OPT = (%CTL_OPT, %{$job_ctl}); #override current defaults with user values
    GI::generate_control_files($job_dir, 'all', \%CTL_OPT) if(! -f "$job_dir/maker_opts.ctl" ||
							      ! -f "$job_dir/maker_bopts.ctl" ||
							      ! -f "$job_dir/maker_exe.ctl" );
    $dbh->disconnect; #disconnect before forking

    #rebuild connection string
    my $dsn = "DBI:$CTL_OPT{DBI}:dbname=";
    $dsn .= "$CTL_OPT{data_dir}/" if($CTL_OPT{DBI} eq 'SQLite');
    $dsn .= "$CTL_OPT{dbname};";
    $dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
    $dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});

    #fork off the MAKER proccess and return process id of the child
    FORK: { 
	my $pid;
	if (!$DEBUG && ($pid=fork())) { # this is the parent, so return the pid
			 # everything below here is either the child or a very major 
	                 # system failure

	    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
		or die "<br>Got error $DBI::errstr when connecting to database\n";	    

	    return $pid;
	}
	elsif ($DEBUG || defined $pid){ #this is the child
	    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
		or die "<br>Got error $DBI::errstr when connecting to database\n";

	    ####===lock the database so no changes are made until the job is started
	    my $lock = lockDB() || ((print STDERR lock_error()) && (exit(0)));

	    #get current cpu usage and increment
	    my ($job_cpus) = $dbh->selectrow_array(qq{SELECT cpus FROM jobs WHERE job_id=$job_id});
	    $job_cpus++;
	    $dbh->do(qq{UPDATE jobs SET is_queued=0, is_running=1, cpus=$job_cpus WHERE job_id=$job_id});
	    
	    my $job_log = "$job_dir/job.log";

	    #run maker
	    my $command;
	    if(! $type || $type eq 'maker'){
		$command = "$FindBin::RealBin/../../bin/maker -qq -base $job_id";
	    }
	    elsif($type eq 'functional'){
		my $args = "$job_id $CTL_OPT{domain} $CTL_OPT{function} $CTL_OPT{short_name}";
		$command = "$FindBin::RealBin/../../bin/maker_functional $args";
	    }

	    chdir($job_dir);
	    my $pid = open3(undef, undef, \*CHLD_ERR, $command);
	    open(my $OUT, "> $job_log");

	    $dbh->commit;
	    $dbh->disconnect; #disconnect from DB while job runs
	    $lock->unlock;
    	    ####===unlock

	    #collect output and STDERR
	    while (my $line = <CHLD_ERR>){
		print $OUT $line;
	    }
	    close($OUT);
	    waitpid $pid, 0;
	    my $err = $?;
	    chdir($CWD);

	    #job is finished reconnect to DB to set values
	    $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
		or die "<br>Got error $DBI::errstr when connecting to database\n";

	    ####===lock the database so no changes are made while I'm writing
	    $lock = lockDB() || ((print STDERR lock_error()) & (exit(0)));

	    #get current cpu usage and increment
	    ($job_cpus) = $dbh->selectrow_array(qq{SELECT cpus FROM jobs WHERE job_id=$job_id});
	    $job_cpus--;
	    
	    if($err){
		$dbh->do(qq{UPDATE jobs SET is_error=1, cpus=$job_cpus WHERE job_id=$job_id});
		print STDERR "Failed job: $job_id for user: $user_id\t".MWAS_util::date_time()."\n";
	    }
	    else{
		my $date = MWAS_util::date_time();
		$dbh->do(qq{UPDATE jobs SET is_finished=1, cpus=$job_cpus WHERE job_id=$job_id});
		print STDERR "Finished job: $job_id for user: $user_id\t$date\n";
	    }

	    $dbh->commit;
	    $dbh->disconnect;
	    $lock->unlock;
	    ####===unlock

	    exit(0); #finished
	}
	elsif ($! == EAGAIN)  {
	    #fork failed try again
	    sleep 3;
	    redo FORK;
	}
	else {
	    print STDERR "ERROR: Can not start fork for MAKER.\t".MWAS_util::date_time()."\n$!";

	    return 0;
	}
    }
}
#------------------------------------------------------------------------
#will verify the existance of all tables and columns and create them if necessary
sub check_table_structure {
    my $dbh = shift;

    #checking if CTL_OPT is loaded
    my %def_opt = (GI::set_defaults('opts'), GI::set_defaults('bopts')); #get system produced CTL_OPT
    die "ERROR: CTL_OPT must be loaded before calling main::check_table_structure\n"
	if(@{[keys %def_opt]} > @{[keys %CTL_OPT]});

    my @tables = $dbh->tables;

    #list of expected tables
    my @expected = qw(users
		      menus
		      files
		      jobs
		      ctl_opt
		      all_default_opt
		      stat
		      id_store
		     );

    #if an expected table is not found, create it
    ####===lock the database so no changes are made until all tables are in place
    my $lock = lockDB() || die lock_error();
    
    #use different datatypes depending on type of SQL used in DBI
    my $t_type = ($dbh->{Driver}->{Name} =~ /mysql/i) ? 'VARCHAR(100)' : 'TEXT';

    #weird extra tables in Pg
    @tables = grep {/^public\./} @tables if($dbh->{Driver}->{Name} =~ /^pg$/i);

    #create users table
    my $dsn = (qq{CREATE TABLE users (user_id INTEGER PRIMARY KEY, login $t_type UNIQUE, }.
	       qq{password $t_type, first $t_type, last $t_type, e_mail $t_type, }.
	       qq{institution $t_type, is_guest INTEGER, is_admin INTEGER, }.
	       qq{date_created $t_type, last_login $t_type)});
    $dbh->do($dsn) if(! grep {/users/} @tables);
    add_missing_columns($dbh, $dsn, 'users');

    #create files table
    $dsn = (qq{CREATE TABLE files (name $t_type, value $t_type UNIQUE, contig_count $t_type, }.
	    qq{type $t_type, length $t_type, user_id INTEGER, description $t_type)});
    $dbh->do($dsn) if(! grep {/files/} @tables);
    add_missing_columns($dbh, $dsn, 'files');

    #create jobs table
    $dsn = (qq{CREATE TABLE jobs (job_id INTEGER PRIMARY KEY, user_id INTEGER, submit_id INTEGER, length $t_type, }.
	    qq{type $t_type, old_id INTEGER, is_queued INTEGER, is_started INTEGER, is_running INTEGER, }.
	    qq{is_finished INTEGER, is_error INTEGER, is_packaged INTEGER, is_saved INTEGER, admin_block INTEGER, }.
	    qq{is_tutorial INTEGER, cpus INTEGER, start_time $t_type, finish_time $t_type, name $t_type, note $t_type)});
    $dbh->do($dsn) if(! grep {/jobs/} @tables);
    add_missing_columns($dbh, $dsn, 'jobs');

    #create ctl_opt table
    my @defaults = map {lc($_)." $t_type"} keys %def_opt; #get table column names and datatype
    $dsn = 'CREATE TABLE ctl_opt (job_id INTEGER UNIQUE, '.join(', ', @defaults).')';
    $dbh->do($dsn) if(! grep {/ctl_opt/} @tables);
    add_missing_columns($dbh, $dsn, 'ctl_opt');

    #create/re-create menus table (always)
    $dbh->do(qq{DROP TABLE menus}) if(grep {/menus/} @tables);
    $dbh->do(qq{CREATE TABLE menus (name $t_type, value $t_type, contig_count $t_type,}.
	     qq{type $t_type, length $t_type, is_tutorial INTEGER, description $t_type)});

    while(my $type = each %{$CTL_OPT{menus}}){
	while(my $name = each %{$CTL_OPT{menus}{$type}}){
	    my $value = $CTL_OPT{menus}{$type}{$name};
	    my $is_tutorial = 0;

	    if($value =~ /\/dpp_contig.fasta$/ ||
	       $value =~ /\/dpp_proteins.fasta$/ ||
	       $value =~ /\/dpp_transcripts.fasta$/ ||
	       $value =~ /\/pyu-contig.fasta$/ ||
	       $value =~ /\/pyu-est.fasta$/ ||
	       $value =~ /\/pyu-protein.fasta$/ ||
	       $value =~ /\/pyu.hmm$/ ||
	       $value =~ /\/pyu.mod$/ ||
	       $value =~ /\/legacy-contig.fasta$/ ||
	       $value =~ /\/legacy-set1.gff$/ ||
	       $value =~ /\/legacy-set2.gff$/ ||
	       $value =~ /\/pass-contig.fasta$/ ||
	       $value =~ /\/pass-mRNAseq.gff$/ ||
	       $value =~ /\/ecoli-contig.fasta$/ ||
	       $value =~ /\/ecoli-est.fasta$/ ||
	       $value =~ /\/ecoli-protein.fasta$/ ||
	       $value =~ /\/ecoli.mod$/
	       ){
		 $is_tutorial++;
	     }

	    if(! -e $value && $type !~ /^augustus_species$|^model_org$/){
		warn "WARNING: The menu option '$name => $value'\n".
		     "is not a valid file and will be ignored";
		next;
	    }

	    my $length = @{[stat($value)]}[7] || 0;
	    my $c_count = 0;
	    if($type =~ /^fasta$|^est$|^protein$|^repeat_protein$|^altest$|^genome$/){
		$length = MWAS_util::fasta_length($value);
		$c_count = `grep -c ">" $value`;
	    }

	    my ($check) = $dbh->selectrow_array(qq{SELECT value FROM menus WHERE type='$type' AND value='$value'});

	    $dbh->do(qq{INSERT INTO menus (name, value, type, length, contig_count, is_tutorial) }.
		     qq{VALUES ('$name', '$value', '$type', '$length', '$c_count', $is_tutorial)}) unless($check);
	}
    }    

    #log/re-log last unique key ids used (this is to help generate new keys)
    #Most versions of SQL can do this automatically but not all, so I will handle it in perl
    #please note that job_ids 1-5 aare reserved for tutorial data and user_id 1 for administrator
    #$dbh->do(qq{DROP TABLE id_store}) if(grep {/id_store/} @tables);
    $dsn = (qq{CREATE TABLE id_store (last_user_id INTEGER, last_job_id INTEGER, last_submit_id INTEGER)});
    if(! grep {/id_store/} @tables){
	$dbh->do($dsn);
	
	#fix value if null
	my ($last_user_id) = $dbh->selectrow_array(qq{SELECT user_id FROM users ORDER BY user_id DESC LIMIT 1}) || 1;
	my ($last_job_id)  = $dbh->selectrow_array(qq{SELECT job_id FROM jobs ORDER BY job_id DESC LIMIT 1}) || 1;
	my ($last_submit_id)  = $dbh->selectrow_array(qq{SELECT submit_id FROM jobs ORDER BY submit_id DESC LIMIT 1}) || 1;
	$last_job_id = 6 if($last_job_id < 6);
	$last_submit_id = $last_job_id if(! $last_submit_id);
	$dbh->do(qq{INSERT INTO id_store (last_user_id, last_job_id, last_submit_id) VALUES ($last_user_id, $last_job_id, $last_submit_id)});
    }
    add_missing_columns($dbh, $dsn, 'id_store');

    #add administrator to database
    my ($user_id) = $dbh->selectrow_array(qq{SELECT user_id FROM users WHERE user_id=1});
    $dbh->do(qq{INSERT INTO users (user_id, login, password, first, last, e_mail, is_guest, is_admin, date_created) }.
	     qq{VALUES (1, 'admin', 'password', 'Server', 'Administrator', '', 0, 1, \'}.MWAS_util::date_time().qq{\')}) if(! $user_id);

    #update administrator e-mail
    if($dbh->selectrow_array(qq{SELECT e_mail FROM users WHERE e_mail='$CTL_OPT{admin_email}' and user_id != 1})){
	warn "WARNING:  The administrative e-mail address provided in the server.ctl file is already\n".
	     "registered to another user.  The e-mail address will be set to empty and the control files\n".
	     "will be updated accordingly\n";

	$CTL_OPT{admin_email} = '';
	GI::generate_control_files("$FindBin::RealBin/../config/", 'server', \%CTL_OPT)
    }
    else{
	$dbh->do(qq{UPDATE users SET e_mail='$CTL_OPT{admin_email}' WHERE user_id=1}); #update admin e-mail address
    }

    #create/re-create all_default_opt table
    $dbh->do(qq{DROP TABLE all_default_opt}) if(grep {/all_default_opt/} @tables); #drop table
    @defaults = map {lc($_)." $t_type"} grep {!/^menus$|^stat$/i} keys %CTL_OPT; #get table column names and datatype
    $dsn = 'CREATE TABLE all_default_opt ('.join(', ', @defaults).')';
    $dbh->do($dsn);
    @defaults = grep {!/^menus$|^stat$/i} keys %CTL_OPT; #keys to add
    my @lc_defaults = map {lc($_)}  @defaults;
    $dsn = "INSERT INTO all_default_opt (".join(", ", @lc_defaults).") VALUES ('".join("', '", @CTL_OPT{@defaults})."')";
    $dbh->do($dsn); #add ctl_opt

    #create/re-create stat table
    my %stat = %{$CTL_OPT{STAT}};
    $dbh->do(qq{DROP TABLE stat}) if(grep {/stat/} @tables); #drop table
    @defaults = map {lc($_)." $t_type"}  keys %stat; #get table column names and datatype
    $dsn = 'CREATE TABLE stat ('.join(', ', @defaults).')';
    $dbh->do($dsn);
    @defaults = keys %stat; #keys to add
    @lc_defaults = map {lc($_)}  @defaults;
    $dsn = "INSERT INTO stat (".join(", ", @lc_defaults).") VALUES ('".join("', '", @stat{@defaults})."')";
    $dbh->do($dsn); #add ctl_opt

    #update values for possible null columns
    $dbh->do("UPDATE jobs SET type = 'maker' WHERE type IS NULL");
    $dbh->do("UPDATE jobs SET submit_id = job_id WHERE submit_id IS NULL");

    #--add tutorial jobs (always adds/re-adds)
    if($CTL_OPT{tutorials}){
	### JOB 1 ###
	my $id = 1;
	my $t_message = "This example job will annotate the region of Drosophila melanogaster ".
	    "chromosome 2L that encodes the gene decapentaplegic.  This is a gene ".
	    "with multiple confirmed alternately spliced transcripts, and it ".
	    "illustrates how EST evidence can suggest differtent splice forms ".
	    "and UTR variation";
	
	#drop job from table
	$dbh->do(qq{DELETE FROM jobs WHERE job_id=$id}); #drop
	$dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=$id}); #drop
    
	#add/re-add control file options	
	my @files = @{$dbh->selectcol_arrayref(qq{SELECT value FROM menus WHERE is_tutorial=1 and }.
					       qq{(value LIKE '%dpp_contig.fasta' or }.
						      qq{value LIKE '%dpp_transcripts.fasta' or }.
						      qq{value LIKE '%dpp_proteins.fasta')}
					       )};	
	if(@files == 3 && -f $files[0] && -f $files[1] && -f $files[2]){ #re-add here
	    my %job_opt = %CTL_OPT; #make a copy of control file settings
	    
	    #add needed values
	    ($job_opt{genome})  = grep {/dpp_contig.fasta/} @files;
	    ($job_opt{est})     = grep {/dpp_transcripts.fasta/} @files;
	    ($job_opt{protein}) = grep {/dpp_proteins.fasta/} @files;
	    $job_opt{organism_type} = 'eukaryotic';
	    $job_opt{predictor} = 'est2genome';
	    
	    #add to ctl_opt table
	    @defaults = (keys %def_opt); #keys to add
	    my @lc_defaults = map {lc($_)}  @defaults;
	    $dsn = "INSERT INTO ctl_opt (job_id, ".join(", ", @lc_defaults).") VALUES ($id, '".join("', '", @job_opt{@defaults})."')";
	    $dbh->do($dsn); #add ctl_opt
	}
	
	#add job but only if control file options were ok
	my ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM ctl_opt WHERE job_id=$id});
	if($job_id){
	    my $genome = $dbh->selectrow_array(qq{SELECT genome FROM ctl_opt WHERE job_id=$id});
	    ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE job_id=$id});
	    $dbh->do(qq{INSERT INTO jobs (job_id, user_id, length, type, is_queued, is_started, }.
		     qq{is_running, is_finished, is_error, is_packaged, is_saved, admin_block, }.
		     qq{is_tutorial,  cpus, start_time, finish_time, name, note)}.
		     qq{VALUES($id, 1, \'}.MWAS_util::get_length_for_value($dbh, $genome).
		     qq{\', 'maker', 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, '}.MWAS_util::date_time.qq{', '}.
		     MWAS_util::date_time . qq{', 'D. melanogaster : Dpp','$t_message')}
		     ) if(! $job_id); #add job
	}
	
	### JOB 2 ###
	$id = 2;
	$t_message = "This example job will annotate a region of the Pythium ultimum genome. ".
	    "P. ultimum is an emerging model organism genome and this example illustrates ".
	    "how to perform de novo annotaion on a new genome";
	
	#drop job from table
    $dbh->do(qq{DELETE FROM jobs WHERE job_id=$id}); #drop
	$dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=$id}); #drop
	
	#add/re-add control file options	
	@files = @{$dbh->selectcol_arrayref(qq{SELECT value FROM menus WHERE is_tutorial=1 and }.
					    qq{(value LIKE '%pyu-contig.fasta' or }.
					    qq{value LIKE '%pyu-est.fasta' or }.
					    qq{value LIKE '%pyu-protein.fasta' or }.
					    qq{value LIKE '%pyu.hmm' or }.
					    qq{value LIKE '%pyu.mod')}
					    )};
	if(@files >= 3 && -f $files[0] && -f $files[1] && -f $files[2]){ #re-add here
	    my %job_opt = %CTL_OPT; #make a copy of control file settings
	    
	    #add needed values
	    ($job_opt{genome})  = grep {/pyu-contig.fasta/} @files;
	    ($job_opt{est})     = grep {/pyu-est.fasta/} @files;
	    ($job_opt{protein}) = grep {/pyu-protein.fasta/} @files;
	    ($job_opt{snaphmm}) = grep {/pyu.hmm/} @files;
	    ($job_opt{gmhmm}) = grep {/pyu.mod/} @files;
	    $job_opt{organism_type} = 'eukaryotic';
	    $job_opt{predictor} = '';
	    
	    my @predictors;
	    push(@predictors, 'snap') if($job_opt{'snap'});
	    push(@predictors, 'genemark') if($job_opt{'gmhmme3'});
	    push(@predictors, 'est2genome') if(!@predictors);
	    $job_opt{predictor} .= join(',', @predictors);
	    
	    #add to ctl_opt table
	    @defaults = (keys %def_opt); #keys to add
	    my @lc_defaults = map {lc($_)}  @defaults;
	    $dsn = "INSERT INTO ctl_opt (job_id, ".join(", ", @lc_defaults).") VALUES ($id, '".join("', '", @job_opt{@defaults})."')";
	    $dbh->do($dsn); #add ctl_opt
	}
	
	#add job but only if control file options were ok
	($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM ctl_opt WHERE job_id=$id});
	if($job_id){
	    my $genome = $dbh->selectrow_array(qq{SELECT genome FROM ctl_opt WHERE job_id=$id});
	    ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE job_id=$id});
	    $dbh->do(qq{INSERT INTO jobs (job_id, user_id, length, type, is_queued, is_started, }.
		     qq{is_running, is_finished, is_error, is_packaged, is_saved, admin_block, }.
		     qq{is_tutorial,  cpus, start_time, finish_time, name, note)}.
		     qq{VALUES($id, 1, \'}.MWAS_util::get_length_for_value($dbh, $genome).
		     qq{\', 'maker', 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, '}.MWAS_util::date_time.qq{', '}.
		     MWAS_util::date_time . qq{', 'P. ultimum : De Novo Annotation','$t_message')}
		     ) if(! $job_id); #add job
	}
	
	### JOB 3 ###
	$id = 3;
	$t_message = "This example job will annotate a region of the Pythium ultimum genome. ".
	    "In the example mRNAseq data crossing spice site junctions is integrated ".
	    "into a MAKER run. The data data was processed and aligned by an external ".
	    "program and will be passed to MAKER in a GFF3 formated file. This example ".
	    "demonstrates how you might use the GFF3 pass-through capability of MAKER.";
	
	#drop job from table
	$dbh->do(qq{DELETE FROM jobs WHERE job_id=$id}); #drop
	$dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=$id}); #drop
	
	#add/re-add control file options	
	@files = @{$dbh->selectcol_arrayref(qq{SELECT value FROM menus WHERE is_tutorial=1 and }.
					    qq{(value LIKE '%pass-contig.fasta' or }.
					    qq{value LIKE '%pyu-est.fasta' or }.
					    qq{value LIKE '%pyu-protein.fasta' or }.
					    qq{value LIKE '%pass-mRNAseq.gff' or }.
					    qq{value LIKE '%pyu.hmm' or }.
					    qq{value LIKE '%pyu.mod')}
					    )};
	if(@files >= 4 && -f $files[0] && -f $files[1] && -f $files[2] && -f $files[3]){ #re-add here
	    my %job_opt = %CTL_OPT; #make a copy of control file settings
	    
	    #add needed values
	    ($job_opt{genome})  = grep {/pass-contig.fasta/} @files;
	    ($job_opt{est})     = grep {/pyu-est.fasta/} @files;
	    ($job_opt{protein}) = grep {/pyu-protein.fasta/} @files;
	    ($job_opt{est_gff}) = grep {/pass-mRNAseq.gff/} @files;
	    ($job_opt{snaphmm}) = grep {/pyu.hmm/} @files;
	    ($job_opt{gmhmm}) = grep {/pyu.mod/} @files;
	    $job_opt{organism_type} = 'eukaryotic';
	    $job_opt{predictor} = '';
	    
	    my @predictors;
	    push(@predictors, 'snap') if($job_opt{'snap'});
	    push(@predictors, 'genemark') if($job_opt{'gmhmme3'});
	    push(@predictors, 'est2genome') if(!@predictors);
	    $job_opt{predictor} .= join(',', @predictors);
	    
	    #add to ctl_opt table
	    @defaults = (keys %def_opt); #keys to add
	    my @lc_defaults = map {lc($_)}  @defaults;
	    $dsn = "INSERT INTO ctl_opt (job_id, ".join(", ", @lc_defaults).") VALUES ($id, '".join("', '", @job_opt{@defaults})."')";
	    $dbh->do($dsn); #add ctl_opt
	}
	
	#add job but only if control file options were ok
	($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM ctl_opt WHERE job_id=$id});
	if($job_id){
	    my $genome = $dbh->selectrow_array(qq{SELECT genome FROM ctl_opt WHERE job_id=$id});
	    ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE job_id=$id});
	    $dbh->do(qq{INSERT INTO jobs (job_id, user_id, length, type, is_queued, is_started, }.
		     qq{is_running, is_finished, is_error, is_packaged, is_saved, admin_block, }.
		     qq{is_tutorial,  cpus, start_time, finish_time, name, note)}.
		     qq{VALUES($id, 1, \'}.MWAS_util::get_length_for_value($dbh, $genome).
		     qq{\', 'maker', 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, '}.MWAS_util::date_time.qq{', '}.
		     MWAS_util::date_time . qq{', 'P. ultimum : Data Pass-through','$t_message')}
		     ) if(! $job_id); #add job
	}
	
	### JOB 4 ###
	$id = 4;
	$t_message = "This example job will annotate a region of the Pythium ultimum genome. ".
	    "In this example two pre-existing legacy annotation sets will be merged ".
	    "and integrated with EST and protein homology data to produce a consensus ".
	    "set of annotations.  This example demonstrates how legacy annotations can be ".
	    "integrated into a MAKER run. Legacy annotation sets are passed to MAKER in ".
	    "GFF3 format.";
	
	#drop job from table
	$dbh->do(qq{DELETE FROM jobs WHERE job_id=$id}); #drop
	$dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=$id}); #drop
	
	#add/re-add control file options	
	@files = @{$dbh->selectcol_arrayref(qq{SELECT value FROM menus WHERE is_tutorial=1 and }.
					    qq{(value LIKE '%legacy-contig.fasta' or }.
					    qq{value LIKE '%pyu-est.fasta' or }.
					    qq{value LIKE '%pyu-protein.fasta' or }.
					    qq{value LIKE '%legacy-set1.gff' or }.
					    qq{value LIKE '%legacy-set2.gff' or }.
					    qq{value LIKE '%pyu.hmm' or }.
					    qq{value LIKE '%pyu.mod')}
					    )};
	if(@files >= 5 && -f $files[0] && -f $files[1] && -f $files[2] && -f $files[3] && -f $files[4]){ #re-add here
	    my %job_opt = %CTL_OPT; #make a copy of control file settings
	    
	    #add needed values
	    ($job_opt{genome})  = grep {/legacy-contig.fasta/} @files;
	    ($job_opt{est})     = grep {/pyu-est.fasta/} @files;
	    ($job_opt{protein}) = grep {/pyu-protein.fasta/} @files;
	    ($job_opt{model_gff}) = grep {/legacy-set1.gff/} @files;
	    ($job_opt{model_gff}) .= ",".grep {/legacy-set2.gff/} @files;
	    ($job_opt{snaphmm}) = grep {/pyu.hmm/} @files;
	    ($job_opt{gmhmm}) = grep {/pyu.mod/} @files;
	    $job_opt{organism_type} = 'eukaryotic';
	    $job_opt{predictor} = '';
	    
	    my @predictors;
	    push(@predictors, 'snap') if($job_opt{'snap'});
	    push(@predictors, 'genemark') if($job_opt{'gmhmme3'});
	    push(@predictors, 'est2genome') if(!@predictors);
	    $job_opt{predictor} .= join(',', @predictors);
	    
	    #add to ctl_opt table
	    @defaults = (keys %def_opt); #keys to add
	    my @lc_defaults = map {lc($_)}  @defaults;
	    $dsn = "INSERT INTO ctl_opt (job_id, ".join(", ", @lc_defaults).") VALUES ($id, '".join("', '", @job_opt{@defaults})."')";
	    $dbh->do($dsn); #add ctl_opt
	}
	
	#add job but only if control file options were ok
	($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM ctl_opt WHERE job_id=$id});
	if($job_id){
	    my $genome = $dbh->selectrow_array(qq{SELECT genome FROM ctl_opt WHERE job_id=$id});
	    ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE job_id=$id});
	    $dbh->do(qq{INSERT INTO jobs (job_id, user_id, length, type, is_queued, is_started, }.
		     qq{is_running, is_finished, is_error, is_packaged, is_saved, admin_block, }.
		     qq{is_tutorial,  cpus, start_time, finish_time, name, note)}.
		     qq{VALUES($id, 1, \'}.MWAS_util::get_length_for_value($dbh, $genome).
		     qq{\', 'maker', 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, '}.MWAS_util::date_time.qq{', '}.
		     MWAS_util::date_time . qq{', 'P. ultimum : Legacy Annotations','$t_message')}
		     ) if(! $job_id); #add job
	}    
	
	### JOB 5 ###
	$id = 5;
	$t_message = "This example job will annotate a region of the Escherichia coli genome. ".
	    "This is an example of how to use MAKER for annotating prokaryotic genomes";
	
	#drop job from table
	$dbh->do(qq{DELETE FROM jobs WHERE job_id=$id}); #drop
	$dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=$id}); #drop
	
	#add/re-add control file options	
	@files = @{$dbh->selectcol_arrayref(qq{SELECT value FROM menus WHERE is_tutorial=1 and }.
					    qq{(value LIKE '%ecoli-contig.fasta' or }.
					    qq{value LIKE '%ecoli-est.fasta' or }.
					    qq{value LIKE '%ecoli-protein.fasta' or }.
					    qq{value LIKE '%ecoli.mod')}
					    )};
	if(@files >= 4 && -f $files[0] && -f $files[1] && -f $files[2] && -f $files[3]){ #re-add here
	    my %job_opt = %CTL_OPT; #make a copy of control file settings
	    
	    #add needed values
	    ($job_opt{genome})  = grep {/ecoli-contig.fasta/} @files;
	    ($job_opt{est})     = grep {/ecoli-est.fasta/} @files;
	    ($job_opt{protein}) = grep {/ecoli-protein.fasta/} @files;
	    ($job_opt{gmhmm}) = grep {/ecoli.mod/} @files;
	    $job_opt{organism_type} = 'prokaryotic';
	    
	    my @predictors;
	    push(@predictors, 'protein2genome');
	    push(@predictors, 'genemark') if($job_opt{'gmhmmp'});
	    $job_opt{predictor} .= join(',', @predictors);
	    
	    #add to ctl_opt table
	    @defaults = (keys %def_opt); #keys to add
	    my @lc_defaults = map {lc($_)}  @defaults;
	    $dsn = "INSERT INTO ctl_opt (job_id, ".join(", ", @lc_defaults).") VALUES ($id, '".join("', '", @job_opt{@defaults})."')";
	    $dbh->do($dsn); #add ctl_opt
	}
	
	#add job but only if control file options were ok
	($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM ctl_opt WHERE job_id=$id});
	if($job_id){
	    my $genome = $dbh->selectrow_array(qq{SELECT genome FROM ctl_opt WHERE job_id=$id});
	    ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE job_id=$id});
	    $dbh->do(qq{INSERT INTO jobs (job_id, user_id, length, type, is_queued, is_started, }.
		     qq{is_running, is_finished, is_error, is_packaged, is_saved, admin_block, }.
		     qq{is_tutorial,  cpus, start_time, finish_time, name, note)}.
		     qq{VALUES($id, 1, \'}.MWAS_util::get_length_for_value($dbh, $genome).
		     qq{\', 'maker', 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, '}.MWAS_util::date_time.qq{', '}.
		     MWAS_util::date_time . qq{', 'E. coli : De Novo Annotation','$t_message')}
		     ) if(! $job_id); #add job
	}    
    }
    ### END ADD TUTORIAL JOBS ###

    #commit changes
    $dbh->commit;
    $lock->unlock;
    ####===unlock
}
#------------------------------------------------------------------------
sub add_missing_columns {
    my $dbh = shift;
    my $dsn = shift; # must be the statement used to build table
    my $table = shift;
    
    #check that all columns are present
    my $bak = $dsn;
    ($dsn) = $dsn =~ /\((.*)\)/;
    my %columns = map {/^([^\s]+)\s+(.*)/} split(/,\s*/, $dsn);
    
    my $sth = $dbh->prepare("SELECT * FROM $table LIMIT 1");
    $sth->execute;
    my @missing = ();
    my @found = map {lc($_)} @{$sth->{NAME}}; #make all lower case for any DBI
    my %found;
    @found{@found} = (); #build indexing hash

    #no columns were found to add, so delete table and rebuild
    if(! @found){
	$dbh->do("DROP TABLE $table");
	$dbh->do($bak); #create new table
    }

    foreach my $key (keys %columns){
	push(@missing, $key) if(! exists $found{$key});
    }
    
    #add missing columns
    foreach my $key (@missing){
	my $def = $columns{$key};
	$dbh->do("ALTER TABLE $table ADD $key $def");
    }
}
#------------------------------------------------------------------------
#puts jobs back into queue on server restart
sub reset_queue {
    my $dbh = shift;

    dbh_do_commit($dbh, qq{UPDATE jobs SET is_running=0, is_queued=1, is_finished=0, cpus=0 }.
		  qq{WHERE is_started=1 and is_packaged=0 and is_error=0});
}
#------------------------------------------------------------------------
#lock for updating the database
sub lockDB {
    return File::NFSLock->new("$CTL_OPT{data_dir}/.dblock", 'EX', 300, 300);
}
#------------------------------------------------------------------------
#standard message for not getting the lock
sub lock_error {
    print STDERR "ERROR: Could not get lock on database:\t".MWAS_util::date_time()."\n";
}
#------------------------------------------------------------------------
#standard message for not getting the lock
sub dbh_do_commit {
    my $dbh = shift || return;
    my $dsn = shift || return;

    my $lock = lockDB() || ((print STDERR lock_error()) && (return));
    $dbh->do($dsn);
    $dbh->commit;

    return 1;
}
#------------------------------------------------------------------------
# from CPAN module Net::Server::Daemonize
# uses posix to avoid issues related to changing $> $< $) and $( in perl
sub set_uid {
    my $uid = get_uid( shift() );
    POSIX::setuid($uid);
    if ($< != $uid || $> != $uid) { # check $> also (rt #21262)
	$< = $> = $uid; # try again-needed by some 5.8.0 linux systems (rt #13450)
	if ($< != $uid) {
	    die "Couldn't become uid \"$uid\": $!\n";
	}
    }
    return 1;
}
#------------------------------------------------------------------------
# from CPAN module Net::Server::Daemonize
# uses posix to avoid issues related to changing $> $< $) and $( in perl
sub set_gid {
    my $gids = get_gid( @_ );
    my $gid  = (split /\s+/, $gids)[0];
    eval { $) = $gids }; # store all the gids - this is really sort of optional
    POSIX::setgid($gid);
    if (! grep {$gid == $_} split /\s+/, $() { # look for any valid id in list
	die "Couldn't become gid \"$gid\": $!\n";
    }
    return 1;
}
#------------------------------------------------------------------------
# from CPAN module Net::Server::Daemonize
# uses posix to avoid issues related to changing $> $< $) and $( in perl
sub get_uid ($) {
    my $user = shift;
    my $uid  = undef;

    if( $user =~ /^\d+$/ ){
	$uid = $user;
    }else{
	$uid = getpwnam($user);
    }

    die "No such user \"$user\"\n" unless defined $uid;

    return $uid;
}
#------------------------------------------------------------------------
# from CPAN module Net::Server::Daemonize
# uses posix to avoid issues related to changing $> $< $) and $( in perl
sub get_gid {
    my @gid  = ();

    foreach my $group ( split( /[, ]+/, join(" ",@_) ) ){
	if( $group =~ /^\d+$/ ){
	    push @gid, $group;
	}else{
	    my $id = getgrnam($group);
	    die "No such group \"$group\"\n" unless defined $id;
	    push @gid, $id;
	}
    }

    die "No group found in arguments.\n" unless @gid;

    return join(" ",$gid[0],@gid);
}
