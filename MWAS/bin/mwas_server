#! /usr/bin/perl -w

#Maker server 2.0-------------------------------------------------
# is being run to serve maker queue. mwas_server is
# an inifinite loop to check the queue and execute maker jobs as
# soon as they are added to the maker queue.
#-------------------------------------------------------------hadi islam

use strict;
use DBI;
use DateTime;
use Mail::Sender;
use vars qw($LOG %CTL_OPT $EXE $DEBUG);
use POSIX qw(:sys_wait_h setsid EAGAIN);
use Template;
use FindBin;
use lib "$FindBin::Bin/../../lib"; #/maker/lib?
use lib "$FindBin::Bin/../../perl/lib"; #/maker/perl/lib?
use lib "$FindBin::Bin/../../maker/lib"; #/maker/lib?
use lib "$FindBin::Bin/../../maker/perl/lib"; #/maker/perl/lib?
use lib "$FindBin::Bin/../lib"; #/MWAS/lib
use lib "$FindBin::Bin/../perl/lib"; #/MWAS/perl/lib
use Proc::Signal;
use File::NFSLock;
use GI;
use MWAS_util;
use File::Path qw(mkpath rmtree);

BEGIN{
    #get my own name
    $EXE = $FindBin::Script;

    #LOG file
    $LOG = "$FindBin::Bin/../MWAS.log";
    umask 0;

    #set debugging mode
    $DEBUG=1;

    #exit subroutine for signals
    my $exit = sub{die "SIGNAL: Caught @_ exiting\n\n";};

    #Signals to trap and handle
    $SIG{'INT' } = $exit;
    $SIG{'ABRT'} = $exit;
    $SIG{'QUIT'} = $exit;
    $SIG{'TRAP'} = $exit;
    $SIG{'STOP'} = $exit;
    $SIG{'TERM'} = $exit;
    $SIG{'HUP'} = sub{print STDERR "STATUS: Signal received, attempting to restart $EXE\n";
		      exec($0, @ARGV);
		     };
}

my $usage = "
Usage:
     mwas_server [option]

     This is a daemon responsible for the operation of the MAKER Web Annotation
     Service (MWAS).  The daemon checks an SQL database for job submissions and
     then runs MAKER for those jobs.  You must supply an option when executing
     the mwas_server script otherwise it will just return the usage statement.

     Please note that you can also use maker with the -MWAS option to control
     the mwas_server daemon instead of using the mwas_server script directly
     (i.e. maker -MWAS START is the equivilent of mwas_server START).

     The behavior of the MAKER Web Annotation Service and mwas_server is
     dependant on control files found in the /maker/config directory. There are
     five files:  server.ctl, menus.ctl, maker_opts.ctl, maker_bopts.ctl, and
     maker_exe.ctl.  If these files are missing they can be regenerate by
     calling the CTL with mwas_server (i.e. mwas_server CTL).

     The server.ctl file is used to configure server specific and some web
     interface specific options.  The database used by mwas_server is
     configured here.  By default, mwas_server will create a database using
     SQLite, but you can designate any SQL database supported by the Perl DBI.

     The menus.ctl file in the maker/config directory is used to configure
     dropdown menus displayed by the web interface.  This file follows Perl
     syntax and is loaded and generated by Data::Dumper.

     The maker_opts.ctl, maker_bopts.ctl, and maker_exe.ctl files are
     equilvilent to the control files used by MAKER when running a job.  See
     the MAKER documentation for an explanation of the values.  The MAKER Web
     Annotation Service uses these files to define default values presented to
     users in the web interface.  These files also supports tags that configure
     how options are presented to users in the web interface.  Adding the tag 
     =STATIC to the end of a value makes it so the user can see but not alter
     a value in the web interface.  Adding the tag =DISABLED hides the value
     and related menu sections from the web interface.

     The MAKER Web Annotation Service has two parts.  A web interface front end
     that users access via a browser to configure a MAKER job, and a server
     backend that monitor for job submissions and executes MAKER.  The
     mwas_server script is responsible for the back end, but can be used to
     generate the front end CGI/HTML in the directory of your choosing (i.e a
     web accessible directy like /var/www/cgi-bin/maker for Apache).  To do 
     this use the CGI option (don't forget to specify the value for the
     directory in the server.ctl file afterward).


Options:

     STATUS      Checks the status of the MAKER server.

     START       Starts the daemon.

     RESTART     Shutsdown and then restarts the daemon.

     STOP        Shuts down the daemon. SHUTDOWN, QUIT, and KILL are aslo
                 accepted.

     CTL         Generates default control files in the /maker/config
                 directory, does not destroy existing files.

     SETUP       Setup the GGI/HTML files needed to launch the web interface.
                 Also sets up the database the web interface will use.  You
                 must set cgi_dir and html_dir in /config/server.ctl as well
                 as DBI and dbname before running SETUP.

     APOLLO      Setup a webstart version of Apollo for browsing job results. 
                 You must set APOLLO_ROOT in /config/server.ctl first.

     HELP        Prints this usage statement

";

#------------------------------------------------------------------------
#-------------------------------- MAIN ----------------------------------
#------------------------------------------------------------------------

#lets downstream maker libraries know this is the server app
$main::server = 1;

#proccess command line options
my $opt = uc($ARGV[0]) || 'HELP';
$opt =~ s/^\-+|^\=+//; #fix -'s or ='s in options
$opt = 'HELP' if($opt eq '?'); #also accept ?
$opt = 'STOP' if($opt =~ /^SHUTDOWN$|^KILL$|^QUIT$/); #also accept SHUTDOWN, KILL, or QUIT

#find control files and load them
my $c_dir = "$FindBin::Bin/../config/"; #configuration file directory
my @files = ("$c_dir/maker_opts.ctl",
	     "$c_dir/maker_bopts.ctl",
	     "$c_dir/maker_exe.ctl",
	     "$c_dir/server.ctl",
	     "$c_dir/menus.ctl",
	     );
my @exists = grep {-f $_} @files;

%CTL_OPT = GI::load_server_files(\@exists);


if($opt eq 'HELP'){
    print $usage;
    exit(1);
}
elsif($opt eq 'STATUS'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
        print STDERR "STATUS: $EXE is not currently running\n";
    }
    elsif(! $signalable){
        die "ERROR: $EXE is running but you do not have the correct ".
	    "permissions to manage it\n\n";
    }
    else{
        print STDERR "STATUS: $EXE is running\n";
     }
}
elsif($opt eq 'CTL'){
    GI::generate_control_files($c_dir,'all',\%CTL_OPT);
    GI::generate_control_files($c_dir,'server', \%CTL_OPT);
    GI::generate_control_files($c_dir,'menus', \%CTL_OPT);
}
elsif($opt eq 'SETUP'){
    #error checking
    if(@exists < @files){
	die "ERROR: You must run $EXE with the CTL option first to create MAKER\n".
	    "configuration files. Once you are finished building and editing these file\n".
	    "you can run $EXE with the SETUP option, to build the web interface.\n\n";
    }

    my $cgi_dir  = $CTL_OPT{cgi_dir}; #get directory to build CGI/HTML files
    my $html_dir = $CTL_OPT{cgi_dir}; #get directory to build CGI/HTML files

    die "ERROR: You must supply a directory for both cgi_dir and html_dir\n".
	"to install CGI/HTML files\n" if(! $cgi_dir || ! $html_dir);

    die "ERROR: The directory '$cgi_dir' does not exist\n" if(! -d $cgi_dir);
    die "ERROR: The directory '$html_dir' does not exist\n" if(! -d $html_dir);

    #copy all cgi, html, and support files to a web accessible directory
    my $co_dir = "$FindBin::Bin/../cgi-bin/"; #original direcory
    my $ho_dir = "$FindBin::Bin/../html/"; #original direcory
    my $m_lib = "$FindBin::Bin/../../lib/"; #/maker/lib
    my $p_lib = "$FindBin::Bin/../../perl/lib/"; #/maker/perl/lib
    system("cp -R -u $co_dir/* $cgi_dir/") && die("ERROR: Copying files to $cgi_dir failed\n");
    system("cp -R -u $ho_dir/* $html_dir/") && die("ERROR: Copying files to $html_dir failed\n");
    system("cp -R -u $c_dir/* $cgi_dir/config/") && die("ERROR: Copying files to $cgi_dir failed\n");
    system("cp -R -u $m_lib/* $cgi_dir/lib/") && die("ERROR: Copying files to $cgi_dir failed\n");
    system("cp -R -u $p_lib/* $cgi_dir/lib/") && die("ERROR: Copying files to $cgi_dir failed\n");

    if($CTL_OPT{DBI} && $CTL_OPT{dbname}){
	#try to connect to the database as a test
	my $dsn = "DBI:$CTL_OPT{DBI}:dbname=$CTL_OPT{dbname};";
	$dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
	$dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});

	if(!$CTL_OPT{username}){ #warn if no db_username specified
	    warn "WARNING: No username for connecting to the database is specified\n".
		"without a username online requests to MWAS will fail because of\n".
		"permission issues. Please make the necessary changes to server.ctl.\n\n";
	}

	my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
	    or die "<br>Got error $DBI::errstr when connecting to database\n";
	
	#setup the database
	check_table_structure($dbh);
	reset_queue($dbh);
	$dbh->disconnect;
    }
    else{
	die "ERROR: Could not setup the database structure because no database\n".
	    "or database interface is specified in server.ctl.  Please finish\n".
	    "editing the control files and run SETUP again.\n\n";
    }
}
elsif($opt eq 'APOLLO'){
    #go the extra mile and try and setup apollo webstart
    if($CTL_OPT{APOLLO_ROOT}){
	my $html_dir = $CTL_OPT{html_dir};

	#set up directory for web
	my (undef, $t_xml) = File::Temp::tempfile();
	mkdir("$html_dir/jars") if(! -d "$html_dir/jars");

	#create a dummy congfigurable jnlp for webstart
	my $tt_xml = "$FindBin::Bin/../lib/tt_templates/apollo_webstart.tt";
	system("$CTL_OPT{APOLLO_ROOT}/bin/webstart_generator.pl -i $tt_xml -d ".
	       "$CTL_OPT{APOLLO_ROOT}/jars -o $c_dir/apollo.jnlp -D $html_dir/jars") &&
	       die "ERROR: Generating Apollo webstart jars and jnlp file failed\n";
    }
    else{
	die "ERROR: You must suply a value for APOLLO_ROOT in server.ctl to\n".
	    "setup Apollo for use with the MAKER web interface\n\n";
    }
}
elsif($opt eq 'RESTART'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
	print STDERR "STATUS:  is not currently running\n";
	exec($0, 'START');
    }
    elsif(! $signalable){
	die "ERROR: you do not have the correct permissions to restart $EXE\n";
    }
    else{
	print STDERR "STATUS: Trying to restart $EXE\n";
	my $stat = Proc::Signal::killall('HUP', "$EXE");
	if($stat){
	    print STDERR "STATUS: $EXE was restarted successfully\n";
	}
	else{
	    print STDERR "ERROR: Could not restart $EXE!\n";
	}
    }
}
elsif($opt eq 'STOP'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
	print STDERR "STATUS: $EXE is not currently running\n";
    }
    elsif(! $signalable){
	die "ERROR: you do not have the correct permissions to stop $EXE\n";
    }
    else{
	print STDERR "STATUS: Trying to stop $EXE\n";
	my $stat = Proc::Signal::killall('STOP', "$EXE");
	my $run = Proc::Signal::exists_proc_by_name("$EXE");
	if($stat && ! $run){
	    print STDERR "STATUS: $EXE was stopped successfully\n";
	}
	else{
	    print STDERR "ERROR: Could not stop $EXE!\n";
	}
    }
}
elsif($opt eq 'DIEDIE'){
    my ($exists, $signalable) = Proc::Signal::exists_killall(0, "$EXE");

    if(! $exists){
	print STDERR "STATUS: $EXE is not currently running\n";
    }
    elsif(! $signalable){
	die "ERROR: you do not have the correct permissions to stop $EXE\n";
    }
    else{
	print STDERR "STATUS: Trying to stop $EXE\n";
	my $stat = Proc::Signal::killall(9, "$EXE");
	my $run = Proc::Signal::exists_proc_by_name("$EXE");
	if($stat && ! $run){
	    print STDERR "STATUS: $EXE was stopped successfully\n";
	}
	else{
	    print STDERR "ERROR: Could not stop $EXE!\n";
	}
    }
}
elsif($opt eq 'START'){
    my $exists = Proc::Signal::exists_proc_by_name("$EXE");

    if($exists){
	die "ERROR: $EXE is already running\n";
    }
    else{
	print STDERR "STATUS: Now starting $EXE\!\n";

	#error checking
	if(@exists < @files){
	    die "ERROR: Server control files are missing.  Run $EXE\n".
		"with the CTL option first to create the control files.\n".
		"Once you are finished building and editing these files\n".
		"run with the SETUP option to build all files necessary\n".
		"for client side web access to the server. Then you can\n".
		"start the server.\n\n";
	}

	#try to connect to the database as a test
	my $dsn = "DBI:$CTL_OPT{DBI}:dbname=$CTL_OPT{dbname};";
	$dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
	$dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});

	if(!$CTL_OPT{username}){ #warn if no db_username specified
	    warn "WARNING: No username for connecting to the database is specified\n".
		"without a username online requests to MWAS will fail because of\n".
		"permission issues. Please make the necessary changes to server.ctl.\n\n";
	}

	my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
	    or die "<br>Got error $DBI::errstr when connecting to database\n";
	$dbh->disconnect;

	#check permissions on data directory
	if(! -w $CTL_OPT{data_dir} || ! -r $CTL_OPT{data_dir} || ! -x $CTL_OPT{data_dir}){
	    die "ERROR: Current file permissions won't allow you to use $CTL_OPT{data_dir}\n".
		"as the ouput directory for the MAKER Web Annotation Service\n\n";
	}

	if($DEBUG){ #run server in forground for debugger
	    run_server();
	}
	else{#run server as a daemon
	    start_daemon();
	}
    }
}
else{
    print STDERR "ERROR: Invalid option: $opt\n\n";
    print $usage;
    exit(1);
}
#------------------------------------------------------------------------
#----------------------------- SUBROUTINES ------------------------------
#------------------------------------------------------------------------
sub start_daemon {
    unless(my $pid = fork()) {
	exit if $pid;
        setsid();
	my $date = date_time();
	
	#rediret STDERR to the log file since there will be no terminal
	close(STDERR);
	open(STDERR, ">> $LOG"); #append

        print STDERR "STATUS: Starting $EXE $date\n";
	run_server();
    }
}
#------------------------------------------------------------------------
#sens messages via e-mail i.e. errors or status reports
sub send_message{
    my $address = shift @_;
    my $smtp    = shift @_;
    my $subject = shift @_;
    my $msg     = shift @_;

    my $sender = Mail::Sender->new({smtp => $smtp});
    
    my $sq = $sender->MailMsg({to      => $address,
			       from    => "no-reply\@$smtp",
			       subject => $subject,
			       msg     => $msg
			      });
}
#------------------------------------------------------------------------
sub date_time {
    #get time values
    my ($sec, $min, $hour, $mday, $month,
	$year, $wday, $yday, $iddst) = localtime(time);
    
    #fix values
    $year += 1900;
    $month++;
    
    #fix digit spacing
    foreach my $v ($month, $mday, $hour, $min){
	if ($v < 10) {
	    $v = "0$v";
	}
    }
    
    return "$month/$mday/$year $hour:$min";
}
#------------------------------------------------------------------------
sub run_server {
    #load the control files
    my $c_dir = "$FindBin::Bin/../config/"; #configuration file direcdtory
    %CTL_OPT = GI::load_server_files(["$c_dir/maker_opts.ctl",
				      "$c_dir/maker_bopts.ctl",
				      "$c_dir/maker_exe.ctl",
				      "$c_dir/server.ctl",
				      "$c_dir/menus.ctl",
				      ]);

    #make sure required database values are setup
    if(! $CTL_OPT{DBI}){
	die "ERROR: You must specify a DBI connection method in: $FindBin::Bin/../config/server.ctl\n\n";
    }

    if(! $CTL_OPT{dbname}){
	die "ERROR: You must specify a database to connecty to in: $FindBin::Bin/../config/server.ctl\n\n";
    }

    if(! $CTL_OPT{cgi_dir}){
	die "ERROR: You must specify the directory where web content is installed in: $FindBin::Bin/../config/server.ctl\n\n";
    }

    #try to connect to the database as a test
    my $dsn = "DBI:$CTL_OPT{DBI}:dbname=$CTL_OPT{dbname};";
    $dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
    $dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});
    
    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
	or die "<br>Got error $DBI::errstr when connecting to database\n";

    #correct everrything in db tables on startup 
    check_table_structure($dbh);
    reset_queue($dbh);

    #update web interface to current configuration
    my $p_lib = "$FindBin::Bin/../config/"; #config directory
    my $w_dir = $CTL_OPT{cgi_dir}; #web accessible directory
    system("cp -R $c_dir/* $w_dir/config/") && die("ERROR: Copying files to $w_dir failed\n");

    $dbh->disconnect; #database found successfully
    
    #start continuous loop for constant server operation
    my %running; #holds ids of all forks associated with a job

    #connect to database

    while(1){
	my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
	    or die "<br>Got error $DBI::errstr when connecting to database\n";
	#========check on jobs and package data for finished jobs
	
	#look at all active jobs
	while(my $jid = each %running){
	    my @still_running;
	    foreach my $child (@{$running{$jid}}){
		my $stat = waitpid($child, WNOHANG); #nonblocking check of proccess id
		push(@still_running, $child) if($stat == 0); #keep those that aren't finished
	    }

	    #has there been a change in the number of active children?
	    next if(@still_running == @{$running{$jid}});

	    #update active children
	    $running{$jid} = \@still_running;
	    
	    #update cpus entry in table to reflect the true number of active children
	    dbh_do_commit($dbh, qq{UPDATE jobs SET cpus=}.@still_running.qq{ WHERE job_id=$jid});

	    #if all children are inactive
	    if(!@still_running){
		#reset is_running to reflect cpu changes
		dbh_do_commit($dbh, qq{UPDATE jobs SET is_running=0, cpus=0 WHERE job_id=$jid});

		#see if MAKER is really finished
		my ($finished) = $dbh->selectrow_array(qq{SELECT is_finished FROM jobs WHERE job_id=$jid});
		if(!$finished){
		    #not finished, put job back in queue as long as it's not failed
		    dbh_do_commit($dbh, qq{UPDATE jobs SET is_queued=1 WHERE job_id=$jid and is_error=0});
		    delete($running{$jid}); #clear hash key
		}
		else{
		    #All finished, package data for user to download
		    clean_and_package($jid, $CTL_OPT{data_dir}, $dbh);
		    delete($running{$jid}); #clear hash key
		}
	    }
	}

	#========try and start or increase resources to new jobs

	#count all active cpus
	my $cpus = 0;
	grep {$cpus += $_} @{$dbh->selectcol_arrayref(qq{SELECT cpus FROM jobs WHERE is_running=1})}; #use grep to sum

	#if no resources are available just wait
	if($cpus >= $CTL_OPT{max_cpus}){
	    sleep 20;
	    $dbh->disconnect;
	    next;
	}
	
	#check for available jobs in queue
	my ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE is_queued=1 and admin_block=0 and is_error=0 and is_finished=0 ORDER BY job_id LIMIT 1});
	
	if(! $job_id){ #no job in queue
	    #see if I can give extra cpus to existing jobs
	    ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE is_running=1 and cpus }.
					      qq{< $CTL_OPT{job_cpus} and is_finished=0 and admin_block=0 }.
					      qq{and is_error=0 ORDER BY job_id LIMIT 1});

	    if($job_id){ #give more cpus to the job
		my $child = start_job($job_id, \%CTL_OPT, $dbh);
		push(@{$running{$job_id}}, $child) if($child);
		$dbh->disconnect;
		next;
	    }
	    else{#no free cpus, just wait
		sleep 10;
		$dbh->disconnect;
		next;
	    }
	}
	else{ #there's a job, run it
	    my $child = start_job($job_id, \%CTL_OPT, $dbh);
	    push(@{$running{$job_id}}, $child) if($child);
	    $dbh->disconnect;
	    next;
	}
	$dbh->disconnect;
    }
}
#------------------------------------------------------------------------
sub clean_and_package {
    my $job_id   = shift;
    my $data_dir = shift;
    my $dbh      = shift;

    my ($packaged) = $dbh->selectrow_array(qq{SELECT is_packaged FROM jobs WHERE job_id=$job_id});

    #already packaged, move on
    return if($packaged);

    #get job run directory
    my $job_dir = "$data_dir/jobs/$job_id/";

    #get result directory
    my $r_dir = "$job_id.maker.output";
    #where did the results go? run again
    if(! -d "$job_dir/$r_dir"){
	dbh_do_commit($dbh, qq{UPDATE jobs SET is_queued=1, is_finished=0 WHERE job_id=$job_id and is_error=0});
	return;
    }

    #delete extra files from maker output directory
    my @to_delete = (<$job_dir/$r_dir/mpi_blastdb>, <$job_dir/$r_dir/seen.dbm>, <$job_dir/$r_dir/*.db>, <$job_dir/$r_dir/*lock*>);
    foreach my $f (@to_delete){
	unlink($f) if(-f $f);
	File::Path::rmtree($f) if(-d $f);
    }

    #rap everything up into a nice package
    system("cd $job_dir\n".
	   "tar -zcf $r_dir.tar.gz $r_dir --exclude \"run.log\" --exclude \"theVoid\" --exclude \"seen.dbm\" --exclude \"mpi_blastdb\"") &&
	   die("ERROR: Building tarball for job '$job_id' failed\n");

    my $index = "$job_dir/$r_dir/$job_id\_master_datastore_index.log";
    open(my $IN, "< $index");
    while(my $line = <$IN>){
        chomp $line;
        my @data = split("\t", $line);

        if($data[2] eq 'FINISHED'){
            my $val = "$job_dir/$r_dir/$data[1]";
            $val =~ s/[\/]+$//;
            my ($name) = $val =~ /([^\/]+)$/;
            my $gff = "$val/$name.gff";
            my $xml = "$val/$name.xml";
	    
            system("/usr/local/gmod/apollo/bin/apollo -i gff3 -f $gff -o game -w $xml &> /dev/null")if(! -f $xml);
        }
    }
    close($IN);


    my $date = date_time();
    dbh_do_commit($dbh, qq{UPDATE jobs SET is_packaged=1, finish_time='$date' WHERE job_id=$job_id});
}
#------------------------------------------------------------------------
#starts a maker process for a given job
sub start_job {
    my $job_id = shift @_;
    my %CTL_OPT = %{shift @_}; #makes a copy of the control options
    my $dbh = shift;

    #identify if the the user the job belongs to
    my ($user_id) = $dbh->selectrow_array(qq{SELECT user_id FROM jobs WHERE job_id=$job_id});

    ####===lock the database so no changes are made until the job is started
    my $lock = lockDB() || ((print STDERR lock_error()) & (return 0));

    #identify if the the user the job belongs to is active
    my ($owner) = $dbh->selectrow_array(qq{SELECT user_id FROM users WHERE user_id=$user_id});
    
    if(! $owner){ #the user was deleted, so we need to clean up their job
	print STDERR "ERROR: Job '$job_id' from inactive user '$user_id' must be deleted.\t".date_time();
	$dbh->do(qq{DELETE FROM jobs WHERE job_id=$job_id});
	$dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=$job_id});
	$dbh->commit;
	return 0;
    }
    
    #make sure I can still start this job
    my ($status) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE (is_queued=1 or is_running=1) and is_finished=0 and is_error=0});
    
    if($status){ #job can be started
	my $date = date_time();
	print STDERR "Starting job: $job_id for user: $user_id\t$date\n";

	$dbh->do(qq{UPDATE jobs SET start_time='$date' WHERE job_id=$job_id and is_started=0});	
	$dbh->do(qq{UPDATE jobs SET is_queued=0, is_started=1 WHERE job_id=$job_id}); #for existing jobs
	$dbh->commit;
    }
    else{ #job is finished or deleted
	return 0;
    }

    $lock->unlock;
    ####===unlock
    
    #make directories for running maker
    my $user_dir = "$CTL_OPT{data_dir}/users/$user_id";
    my $job_dir = "$CTL_OPT{data_dir}/jobs/$job_id";
    File::Path::mkpath($user_dir) if(! -d $user_dir);
    File::Path::mkpath($job_dir) if(! -d $job_dir);
    
    #build control files for job
    my $job_ctl = $dbh->selectrow_hashref(qq{SELECT * FROM ctl_opt WHERE job_id=$job_id});
    %CTL_OPT = (%CTL_OPT, %{$job_ctl}); #override current defaults with user values
    GI::generate_control_files($job_dir, 'all', \%CTL_OPT) if(! -f "$job_dir/maker_opts.ctl" ||
							      ! -f "$job_dir/maker_bopts.ctl" ||
							      ! -f "$job_dir/maker_exe.ctl" );
    $dbh->disconnect; #disconnect before forking

    #rebuild connection string
    my $dsn = "DBI:$CTL_OPT{DBI}:dbname=$CTL_OPT{dbname};";
    $dsn .= "host=$CTL_OPT{host};" if($CTL_OPT{host});
    $dsn .= "port=$CTL_OPT{port};" if($CTL_OPT{host} && $CTL_OPT{port});

    #fork off the MAKER proccess and return process id of the child
    FORK: { 
	my $pid;
	if (!$DEBUG || ($pid=fork())) { # this is the parent, so return the pid
			 # everything below here is either the child or a very major 
	                 # system failure

	    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
		or die "<br>Got error $DBI::errstr when connecting to database\n";	    

	    return $pid;
	}
	elsif ($DEBUG || defined $pid){ #this is the child
	    my $dbh = DBI->connect($dsn, $CTL_OPT{username}, $CTL_OPT{password}, {AutoCommit => 0})
		or die "<br>Got error $DBI::errstr when connecting to database\n";

	    ####===lock the database so no changes are made until the job is started
	    my $lock = lockDB() || ((print STDERR lock_error()) && (exit(0)));

	    #get current cpu usage and increment
	    my ($job_cpus) = $dbh->selectrow_array(qq{SELECT cpus FROM jobs WHERE job_id=$job_id});
	    $job_cpus++;
	    $dbh->do(qq{UPDATE jobs SET is_queued=0, is_running=1, cpus=$job_cpus WHERE job_id=$job_id});
	    $dbh->commit;

	    #run maker
	    my $exe = "$FindBin::Bin/../../bin/maker";
	    my $job_log = "$job_dir/job.log";
	    
	    $lock->unlock;
    	    ####===unlock

	    my $err = system("cd $job_dir\n".
			     "$exe -qq -base $job_id&> $job_log");
	    
	    ####===lock the database so no changes are made while I'm writing
	    $lock = lockDB() || ((print STDERR lock_error()) & (exit(0)));

	    #get current cpu usage and increment
	    ($job_cpus) = $dbh->selectrow_array(qq{SELECT cpus FROM jobs WHERE job_id=$job_id});
	    $job_cpus--;
	    
	    if($err){
		$dbh->do(qq{UPDATE jobs SET is_error=1, cpus=$job_cpus WHERE job_id=$job_id});
		print STDERR "Failed job: $job_id for user: $user_id\t".date_time()."\n";
	    }
	    else{
		my $date = date_time();
		$dbh->do(qq{UPDATE jobs SET is_finished=1, cpus=$job_cpus WHERE job_id=$job_id});
		print STDERR "Finished job: $job_id for user: $user_id\t$date\n";
	    }

	    $dbh->commit;
	    $lock->unlock;
	    ####===unlock

	    exit(0); #finished
	}
	elsif ($! == EAGAIN)  {
	    #fork failed try again
	    sleep 3;
	    redo FORK;
	}
	else {
	    print STDERR "ERROR: Can not start fork for MAKER.\t".date_time()."\n$!";

	    return 0;
	}
    }
}
#------------------------------------------------------------------------
#will verify the existance of all tables and columns and create them if necessary
sub check_table_structure {
    my $dbh = shift;

    #checking if CTL_OPT is loaded
    my %def_opt = (GI::set_defaults('opts'), GI::set_defaults('bopts')); #get system produced CTL_OPT
    die "ERROR: CTL_OPT must be loaded before calling main::check_table_structure\n"
	if(@{[keys %def_opt]} > @{[keys %CTL_OPT]});

    my @tables = $dbh->tables;

    #list of expected tables
    my @expected = qw(users
		      menus
		      files
		      jobs
		      ctl_opt
		      all_default_opt
		      stat
		      id_store
		     );

    #if an expected table is not found, create it
    ####===lock the database so no changes are made until all tables are in place
    my $lock = lockDB() || die lock_error();
    
    #use different datatypes depending on type of SQL used in DBI
    my $t_type = ($dbh->{Driver}->{Name} =~ /mysql/i) ? 'VARCHAR(100)' : 'TEXT';

    #weird extra tables in Pg
    @tables = grep {/^public\./} @tables if($dbh->{Driver}->{Name} =~ /^pg$/i);

    #create users table
    $dbh->do(qq{CREATE TABLE users (user_id INTEGER PRIMARY KEY, login $t_type UNIQUE, }.
		    qq{password $t_type, first $t_type, last $t_type, e_mail $t_type, }.
		    qq{institution $t_type, is_guest INTEGER, is_admin INTEGER, }.
		    qq{date_created $t_type, last_login $t_type)}
	     ) if(! grep {/users/} @tables);
        
    #create files table
    $dbh->do(qq{CREATE TABLE files (name $t_type, value $t_type UNIQUE, contig_count $t_type, }.
		    qq{type $t_type, length $t_type, user_id INTEGER, description $t_type)}
	     ) if(! grep {/files/} @tables);
    
    #create jobs table
    $dbh->do(qq{CREATE TABLE jobs (job_id INTEGER PRIMARY KEY, user_id INTEGER, length $t_type, }.
		    qq{is_queued INTEGER, is_started INTEGER, is_running INTEGER, is_finished INTEGER, }.
		    qq{is_error INTEGER, is_packaged INTEGER, is_saved INTEGER, admin_block INTEGER, is_tutorial INTEGER, }.
		    qq{cpus INTEGER, start_time $t_type, finish_time $t_type, name $t_type, note $t_type)}
	     ) if(! grep {/jobs/} @tables);
    
    #create ctl_opt table
    my @defaults = map {"$_ $t_type"} keys %def_opt; #get table column names and datatype
    my $do_string = 'CREATE TABLE ctl_opt (job_id INTEGER UNIQUE, '.join(', ', @defaults).')';
    $dbh->do($do_string) if(! grep {/ctl_opt/} @tables);

    #create/re-create menus table (always)
    $dbh->do(qq{DROP TABLE menus}) if(grep {/menus/} @tables);
    $dbh->do(qq{CREATE TABLE menus (name $t_type, value $t_type UNIQUE, contig_count $t_type,}.
	     qq{type $t_type, length $t_type, is_tutorial INTEGER, description $t_type)});

    while(my $type = each %{$CTL_OPT{menus}}){
	while(my $name = each %{$CTL_OPT{menus}{$type}}){
	    my $value = $CTL_OPT{menus}{$type}{$name};
	    my $is_tutorial = 0;
	    $is_tutorial++ if($value =~ /\/dpp_contig.fasta$/ ||
			      $value =~ /\/dpp_proteins.fasta$/ ||
			      $value =~ /\/dpp_transcripts.fasta$/);

	    if(! -e $value && $type !~ /^augustus_species$|^model_org$/){
		warn "WARNING: The menu option '$name => $value'\n".
		     "is not a valid file and will be ignored";
		next;
	    }

	    my $length = @{[stat($value)]}[7] || 0;
	    my $c_count = 0;
	    if($type =~ /^fasta$|^est$|^protein$|^repeat_protein$|^altest$|^genome$/){
		$length = MWAS_util::fasta_length($value);
		$c_count = `grep -c ">" $value`;
	    }

	    $dbh->do(qq{INSERT INTO menus (name, value, type, length, contig_count, is_tutorial) }.
		     qq{VALUES ('$name', '$value', '$type', '$length', '$c_count', $is_tutorial)});
	}
    }    

    #log/re-log last unique key ids used (this is to help generate new keys)
    #Most versions of SQL can do this automatically but not all, so I will handle it in perl
    #please note that job_id 1 is reserved for tutorial data and user_id 1 for administrator
    $dbh->do(qq{DROP TABLE id_store}) if(grep {/id_store/} @tables);
    $dbh->do(qq{CREATE TABLE id_store (last_user_id INTEGER, last_job_id INTEGER)});
    my ($last_user_id) = $dbh->selectrow_array(qq{SELECT user_id FROM users ORDER BY user_id DESC LIMIT 1}) || 1;
    my ($last_job_id)  = $dbh->selectrow_array(qq{SELECT job_id FROM jobs ORDER BY job_id DESC LIMIT 1}) || 1;
    $dbh->do(qq{INSERT INTO id_store (last_user_id, last_job_id) VALUES ($last_user_id, $last_job_id)});
    
    #add administrator to database
    my ($user_id) = $dbh->selectrow_array(qq{SELECT user_id FROM users WHERE user_id=1});
    $dbh->do(qq{INSERT INTO users (user_id, login, password, first, last, e_mail, is_guest, is_admin, date_created) }.
	     qq{VALUES (1, 'admin', 'password', 'Server', 'Administrator', '', 0, 1, \'}.date_time().qq{\')}) if(! $user_id);

    #update administrator e-mail
    if($dbh->selectrow_array(qq{SELECT e_mail FROM users WHERE e_mail='$CTL_OPT{admin_email}' and user_id != 1})){
	warn "WARNING:  The administrative e-mail address provided in the server.ctl file is already\n".
	     "registered to another user.  The e-mail address will be set to empty and the control files\n".
	     "will be updated accordingly\n";

	$CTL_OPT{admin_email} = '';
	GI::generate_control_files("$FindBin::Bin/../config/", 'server', \%CTL_OPT)
    }
    else{
	$dbh->do(qq{UPDATE users SET e_mail='$CTL_OPT{admin_email}' WHERE user_id=1}); #update admin e-mail address
    }

    #--add tutorial job (always adds/re-adds)
    my $t_message = "This example job will annotate the region of Drosophila melanogaster ".
                    "chromosome 2L that encodes the gene decapentaplegic.  This is a gene ".
		    "with multiple confirmed alternately spliced transcripts, and it ".
		    "illustrates how EST evidence can suggest differtent splice forms ".
		    "and UTR variation";
    
    #drop job from table
    $dbh->do(qq{DELETE FROM jobs WHERE job_id=1}); #drop
    $dbh->do(qq{DELETE FROM ctl_opt WHERE job_id=1}); #drop
    
    #add/re-add control file options	
    my @files = @{$dbh->selectcol_arrayref(qq{SELECT value FROM menus WHERE is_tutorial=1 and }.
					   qq{(value LIKE '%dpp_contig.fasta' or }.
					   qq{value LIKE '%dpp_transcripts.fasta' or }.
					   qq{value LIKE '%dpp_proteins.fasta')}
					   )};	
    if(@files == 3 && -f $files[0] && -f $files[1] && -f $files[2]){ #re-add here
	my %job_opt = %CTL_OPT; #make a copy of control file settings
	
	#add needed values
	($job_opt{genome})  = grep {/dpp_contig.fasta/} @files;
	($job_opt{est})     = grep {/dpp_transcripts.fasta/} @files;
	($job_opt{protein}) = grep {/dpp_proteins.fasta/} @files;
	$job_opt{predictor} = 'est2genome';
	
	#look for snap hmm to use
	my ($hmm) = $dbh->selectrow_array(qq{SELECT value FROM menus WHERE name='fly' or name='D. melanogaster'}.
					  qq{ or name='Drosophila melanogaster'});
	$job_opt{predictor} .= ",$hmm" if($hmm);
	
	#add to ctl_opt table
	@defaults = (keys %def_opt); #keys to add
	my $do_string = "INSERT INTO ctl_opt (job_id, ".join(", ", @defaults).") VALUES (1, '".join("', '", @job_opt{@defaults})."')";
	$dbh->do($do_string); #add ctl_opt
    }
    
    #add job but only if control file options were ok
    my ($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM ctl_opt WHERE job_id=1});
    if($job_id){
	my $genome = $dbh->selectrow_array(qq{SELECT genome FROM ctl_opt WHERE job_id=1});
	($job_id) = $dbh->selectrow_array(qq{SELECT job_id FROM jobs WHERE job_id=1});
	$dbh->do(qq{INSERT INTO jobs (job_id, user_id, length, is_queued, is_started, }.
		 qq{is_running, is_finished, is_error, is_packaged, is_saved, admin_block, }.
		 qq{is_tutorial,  cpus, start_time, finish_time, name, note)}.
		 qq{VALUES(1, 1, \'}.MWAS_util::get_length_for_value($dbh, $genome).
                 qq{\', 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, '', '', 'D. melanogaster : Dpp','$t_message')}
		 ) if(! $job_id); #add job
    }
    
    #create/re-create all_default_opt table
    $dbh->do(qq{DROP TABLE all_default_opt}) if(grep {/all_default_opt/} @tables); #drop table
    @defaults = map {"$_ $t_type"} grep {!/^menus$|^stat%/i} keys %CTL_OPT; #get table column names and datatype
    $do_string = 'CREATE TABLE all_default_opt ('.join(', ', @defaults).')';
    $dbh->do($do_string);
    @defaults = grep {!/^menus$|^stat%/i} keys %CTL_OPT; #keys to add
    $do_string = "INSERT INTO all_default_opt (".join(", ", @defaults).") VALUES ('".join("', '", @CTL_OPT{@defaults})."')";
    $dbh->do($do_string); #add ctl_opt

    #create/re-create stat table
    my %stat = %{$CTL_OPT{STAT}};
    $dbh->do(qq{DROP TABLE stat}) if(grep {/stat/} @tables); #drop table
    @defaults = map {"$_ $t_type"}  keys %stat; #get table column names and datatype
    $do_string = 'CREATE TABLE stat ('.join(', ', @defaults).')';
    $dbh->do($do_string);
    @defaults = keys %stat; #keys to add
    $do_string = "INSERT INTO stat (".join(", ", @defaults).") VALUES ('".join("', '", @stat{@defaults})."')";
    $dbh->do($do_string); #add ctl_opt

    #commit changes
    $dbh->commit;
    $lock->unlock;
    ####===unlock
}
#------------------------------------------------------------------------
#puts jobs back into queue on server restart
sub reset_queue {
    my $dbh = shift;

    dbh_do_commit($dbh, qq{UPDATE jobs SET is_running=0, is_queued=1, is_finished=0, cpus=0}.
		  qq{WHERE is_started=1 and is_packaged=0 and is_error=0});
}
#------------------------------------------------------------------------
#lock for updating the database
sub lockDB {
    return File::NFSLock->new("$CTL_OPT{data_dir}/.dblock", 'EX', 300, 300);
}
#------------------------------------------------------------------------
#standard message for not getting the lock
sub lock_error {
    print STDERR "ERROR: Could not get lock on database:\t".date_time()."\n";
}
#------------------------------------------------------------------------
#standard message for not getting the lock
sub dbh_do_commit {
    my $dbh = shift || return;
    my $do_string = shift || return;

    my $lock = lockDB() || ((print STDERR lock_error()) && (return));
    $dbh->do($do_string);
    $dbh->commit;

    return 1;
}
