#! /usr/bin/perl -w

use strict "vars";
use strict "refs";

use FindBin;
use lib "$FindBin::Bin/../lib";
use vars qw($LOG $COMMAND_LINE);

BEGIN{
   $ENV{CGL_SO_SOURCE} = "$FindBin::Bin/../lib/CGL/so.obo" if not ($ENV{CGL_SO_SOURCE});
   $ENV{CGL_GO_SOURCE} = "$FindBin::Bin/../lib/CGL/gene_ontology.obo" if not ($ENV{CGL_GO_SOURCE});
   $COMMAND_LINE = $0 . ' '.join(' ', @ARGV);

   $SIG{'INT'} = sub {print STDERR "\n\nMaker aborted by user!!\n\n"; exit (1);};

   #output to log file of seq that caused rank to die                                                                               
   $SIG{'__DIE__'} =
   sub {
      if (defined ($LOG) && defined $_[0]) {
	 my $die_count = $LOG->get_die_count();
	 $die_count++;

	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);

	 die "#----------------------\n",
	 "FATAL: Maker has failed\n" . $_[0];
      }
      else {
	 die "#----------------------\n",
	 "FATAL: Maker has failed\n" . $_[0];
      }
   };
}

use Error qw(:try);
use Error::Simple;
use Dumper::GFF::GFFV3;
use Dumper::XML::Game;
use Datastore::MD5;
use URI::Escape;
use Storable;
use File::Path;
use File::Find::Rule;
use Data::Dumper;
use Getopt::Long;
use FileHandle;
use PostData;
use Cwd;
use Fasta;
use Iterator::Fasta;
use FastaChunker;
use Widget::RepeatMasker;
use Widget::blastx;
use Widget::tblastx;
use Widget::blastn;
use Widget::snap; 
use Widget::augustus;
use PhatHit_utils;
use Shadower;
use Bio::DB::Fasta;
use polisher::exonerate::protein;
use polisher::exonerate::est;
use maker::auto_annotator;
use cluster;
use repeat_mask_seq;
use maker::sens_spec;
use runlog;

$|  = 1;

my $usage = "
Usage:

        maker [options] <maker_opts.ctl> <maker_bopts.ctl> <maker_exe.ctl>

        The three input arguments are user control files that specify how maker should behave.
        All input files listed in the control options files must be in fasta format.  Please
        see maker documentation to learn more about control file format.  The program will
        automatically try and locate the user control files in the current working
        directory if these arguments are not supplied when initializing maker.

        It is important to note that maker does not try and recalculated data that it has
        already calculated.  For example, if you run an analysis twice on the same fasta file
        you will notice that maker does not rerun any of the blast analyses but instead uses
        the blast analyses stored from the previous run.  To force maker to rerun all
        analyses, use the -f flag.

Options:

     -genome|g  <file_name>   Give MAKER a different genome file (this overrides the
                              control file value)

     -predictor <snap>        Selects the gene predictor to use when building annotations (Default
                <augustus>    is 'snap').  The option 'est2genome' builds annotations directly
                <est2genome>  from the EST evidence.

     -GFF                     Use an input gff3 format file of repeat elements for repeat masking.
                              You must set rm_gff in maker_opts.ctl to the files location.  This
                              option turns off all other repeat masking.

     -RM_off|R                Turns repeat masking off (* See Warning)

     -force|f                 Forces maker to rerun all analyses (replaces all previous output).

     -datastore|d             Causes output to be written using datastore.  This option is
                              automatically enabled if there are more than 1000 fasta entries
                              in the input file.  Output can then accessed using the
                              master_datastore_index file created by the program.

     -PREDS                   Outputs ab-initio predictions that do not overlap maker annotation
                              as gene annotations in the final gff3 output file (based on the
                              -predictor flag ).

     -CTL                     Generates generic control files in the current working directory.

     -retry     <integer>     Re-run failed contigs up to the spcified number of re-tries.

     -cpus|c    <integer>     Tells how many cpus to use for Blast analysis (this overrides
                              contorol file value).

     -help|?                  Prints this usage statement.


Warning:
      
        *When using the -R flag, maker expects that the input genome file is already masked.
         Also if your genome file contains lower case characters, maker will consider those
         characers to be soft masked.

";

#variables that are persistent outside of try block
my %OPT;
my %CTL_OPTIONS;

try{
   GetOptions("RM_off|R" => \$OPT{R},
	      "force|f" => \$OPT{f},
	      "datastore|d" => \$OPT{d},
	      "genome|g=s" => \$OPT{g},
	      "cpus|c=i" => \$OPT{c},
	      "GFF"=> \$OPT{GFF},
	      "PREDS" => \$OPT{SNAPS},
	      "predictor=s" =>\$OPT{predictor},
	      "retry=i" =>\$OPT{retry},
	      "CTL" => sub {generate_control_files(); exit(0);},
	      "help|?" => sub {print $usage; exit(0)},
	     );
   
   if (defined($OPT{retry}) && $OPT{retry} <= 0) {
      print STDERR "WARNING: the retry flag must be set to a value greater than zero\n";
      $OPT{retry} = 1;
   }
}
catch Error::Simple with{
   my $E = shift;

   print STDERR $E->{-text};
   print STDERR "\n\nMaker failed parsing command line options!!\n\n";
   my $code = 2;
   $code = $E->{-value} if (defined($E->{-value}));

   exit($code);
};

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

#variables that are persistent outside of try block
my $fasta_iterator;
my $proteins;
my $transcripts;
my $fasta_t_index;
my $fasta_p_index;

try{
   #---get arguments off the command line
   my $infile;
   
   my @ctlfiles = @ARGV;
   
   if (not @ctlfiles) {
      if (-e "maker_opts.ctl" && -e "maker_bopts.ctl" && -e "maker_exe.ctl") {
	 @ctlfiles = ("maker_opts.ctl","maker_bopts.ctl","maker_exe.ctl");
      }
      else {
	 die "ERROR: Control files not found\n";
      }
   }

   #---set up control options from control files
   %CTL_OPTIONS = load_control_files(@ctlfiles);
   
   #---load genome fasta file
   $fasta_iterator = new Iterator::Fasta($CTL_OPTIONS{'genome'});
   
   if ($fasta_iterator->number_of_entries() == 0) {
      die "ERROR:  The genome file $CTL_OPTIONS{'genome'} contains no fasta sequences\n";
   }
   
   #---decide whether to use datastore 
   if ($fasta_iterator->number_of_entries() > 1000) {
      print STDERR "\n\n".
      "WARNING:  There are more than 1000 entries in the multi-fasta file.\n".
      "Datastore will be used to avoid overloading the data structure of\n".
      "the output directory.\n\n";
      
      $OPT{d} = 1;
   }
   
   if ($OPT{d}) {
      %CTL_OPTIONS = build_datastore(\%CTL_OPTIONS); #alter control options to use datastore
   }
   
   #---set up blast databases for analyisis
   create_blastdb(\%CTL_OPTIONS);

   #--build an index of the databases
   my $proteins = $CTL_OPTIONS{'protein'};
   my $transcripts = $CTL_OPTIONS{'est'};
   my $fasta_t_index     = build_fasta_index($transcripts); 
   my $fasta_p_index     = build_fasta_index($proteins);  
}
catch Error::Simple with{
   my $E = shift;
   print STDERR $E->{-text};
   print STDERR "\n\nMaker failed while examining startup data (control files and input fasta files)!!\n\n";
   my $code = 2;
   $code = $E->{-value} if (defined($E->{-value}));

   exit($code);
};

my @failed; #holds failed contigs;
   
#---iterate over each sequence in the fasta
CONTIG: while (my $fasta = $fasta_iterator->nextEntry() || shift @failed) {
   my $failed_contig = 0; #set failure flag to false
   $LOG = undef;

   #variables that are persistent outside of try block
   my $query_def;
   my $query_seq;
   my $seq_id;
   my $seq_out_name;
   my $out_dir;
   my $the_void;

   try{
      $query_def = Fasta::getDef($fasta);  #Get fasta header
      $query_seq = Fasta::getSeq($fasta);  #Get fasta sequence
      ($seq_id)  = $query_def =~ /^>(\S+)/; #Get sequence identifier off of fasta header
      
      #-build a safe name for file names from the sequence identifier
      $seq_out_name = uri_escape($seq_id,  
				 '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
				);
      
      #set up base directory for output
      $out_dir = $CTL_OPTIONS{'out_base'};
      
      #use datastore as base if datastore flag is set
      if ($OPT{d}) {
	 $out_dir = $CTL_OPTIONS{'datastore'}->id_to_dir($seq_out_name);
	 $CTL_OPTIONS{'datastore'}->mkdir($seq_out_name) || die "ERROR: could not make directory $out_dir\n";
      }
      
      #-set up void directory where analysis is stored
      $the_void  = build_the_void($seq_out_name, $out_dir);
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed while examining contents of the fasta file!!\n\n";
      my $code = 2;
      $code = $E->{-value} if (defined($E->{-value}));
      
      exit($code);
   };

   try{
      #-build and proccess the run log
      $LOG = runlog->new(\%CTL_OPTIONS, \%OPT, $the_void, "run.log");
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed while trying to building/processing the run.log file!!\n\n";
      my $code = 2;
      $code = $E->{-value} if (defined($E->{-value}));
      
      exit($code);
   };

   my $continue_flag = $LOG->get_continue_flag();

   #==Decide whether to skip the current seq or continue
   if ($continue_flag == 1) {
      print STDERR "#----------------------------------------------------------------------\n",
                   "Now processing the contig:$seq_id!!\n",
                   "#----------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 my $fh = $CTL_OPTIONS{'fh_dsindex'};
	 print $fh "$seq_id\t$out_dir\n";
      }
   }
   elsif ($continue_flag == 0) {
      print STDERR "#----------------------------------------------------------------------\n",
      "The contig:$seq_id has already been processed!!\n",
      "Maker will now skip to the next contig.\n",
      "Run maker with the -f flag to force Maker to recompute all contig data.\n",
      "#----------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 my $fh = $CTL_OPTIONS{'fh_dsindex'};
	 print $fh "$seq_id\t$out_dir\n";
      }

      next;
   }
   elsif ($continue_flag == -1) {
      print STDERR "#----------------------------------------------------------------------\n",
      "The contig:$seq_id failed on the last run!!\n",
      "Maker will now skip to the next contig rather than try again.\n",
      "Run maker with the -f flag to force Maker to recompute all contig data.\n",
      "Run maker with the -died flag to have Maker retry data that failed.\n",
      "#----------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 my $fh = $CTL_OPTIONS{'fh_dsindex'};
	 print $fh "$seq_id\t$out_dir\n";
      }

      next;
   }
   elsif ($continue_flag == 2) {
      print STDERR "#----------------------------------------------------------------------\n",
      "The failed contig:$seq_id will now run again!!\n",
      "#----------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 my $fh = $CTL_OPTIONS{'fh_dsindex'};
	 print $fh "$seq_id\t$out_dir\tDIED_SKIPPED\n";
      }
   }
   elsif ($continue_flag == -2) {
      print STDERR "#----------------------------------------------------------------------\n",
      "Skipping the contig:$seq_id!!\n",
      "However this contig is still not finished!!\n",
      "#----------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 my $fh = $CTL_OPTIONS{'fh_dsindex'};
	 print $fh "$seq_id\t$out_dir\tSKIPPED\n";
      }

      next;
   }
   elsif ($continue_flag == -3) {
      my $die_count = $LOG->get_die_count();
      print STDERR "#----------------------------------------------------------------------\n",
      "The contig:$seq_id failed $die_count time!!\n",
      "Maker will not try again!!\n",
      "The contig will be stored in $out_dir/$seq_out_name.died.fasta\n",
      "You can use this fasta file to debug and re-run this sequence\n",
      "#----------------------------------------------------------------------\n\n\n";

      open (DFAS, "> $out_dir/$seq_out_name.died.fasta");
      print DFAS $fasta;
      close (DFAS);

      if ($OPT{d}) {
	 my $fh = $CTL_OPTIONS{'fh_dsindex'};
	 print $fh "$seq_id\t$out_dir\tDIED_SKIPPED_PERMANENT\n";
      }

      next;
   }

   #==from here on fastas are proccessed as chunks

   #-set up variables that are heldover from last chunk
   my $holdover_blastn;
   my $holdover_blastx;
   my $holdover_preds;

   #-set up variables that are the result of chunk accumulation
   my $masked_total_seq;
   my $p_fastas;
   my $t_fastas;

   my $GFF3 = new Dumper::GFF::GFFV3();
   $GFF3->seq($query_seq);
   $GFF3->seq_id($seq_id);

   #==REPEAT MASKING HERE

   try{				#coresponds to levels 0-3 in mpi_maker
      if ($OPT{R}) {
	 print STDERR "Repeatmasking skipped!!\n";
	 $masked_total_seq = $$query_seq;
      }
      elsif ($OPT{GFF}) {
	 $masked_total_seq = repeat_mask_seq::gff(uc($$query_seq), 
						  $seq_id,
						  $CTL_OPTIONS{'rm_gff'}
						 );
      }
      else {
	 my $fasta_chunker = new FastaChunker();
	 $fasta_chunker->parent_fasta($fasta);
	 $fasta_chunker->chunk_size($CTL_OPTIONS{'max_dna_len'});
	 $fasta_chunker->min_size($CTL_OPTIONS{'split_hit'});
	 $fasta_chunker->load_chunks();
	 
	 my $chunk_count = 0;
	 
	 while (my $chunk = $fasta_chunker->get_chunk($chunk_count++)) {	 
	    $chunk->seq(uc($chunk->seq())); #must be upper case before soft masking
	    
	    #-get repeatmask hits
	    my ($rma_keepers) = repeatmask($chunk, 
					   $the_void,
					   $seq_out_name,
					   $CTL_OPTIONS{'model_org'},
					   $CTL_OPTIONS{'RepeatMasker'},
					   $CTL_OPTIONS{'rmlib'},
					   $CTL_OPTIONS{'cpus'}
					  );
	    
	    #-mask the chunk using repeatmasker hits
	    $chunk = repeat_mask_seq::mask_chunk($chunk, $rma_keepers);
	    
	    #-blastx against a repeat library (for better masking)
	    my $repeat_blastx_keepers = [];
	    $repeat_blastx_keepers = blastx($chunk,
					    $CTL_OPTIONS{'repeat_protein'},
					    $the_void,
					    $seq_out_name,
					    $CTL_OPTIONS{blastx},
					    $CTL_OPTIONS{eval_blastx},
					    $CTL_OPTIONS{bit_blastx},
					    $CTL_OPTIONS{percov_blastx},
					    $CTL_OPTIONS{percid_blastx},
					    $CTL_OPTIONS{split_hit},
					    $CTL_OPTIONS{cpus}
					   ) if($CTL_OPTIONS{'te_remove'});
	    
	    #-mask the chunk using blastx hits
	    $chunk = repeat_mask_seq::mask_chunk($chunk, $repeat_blastx_keepers);
	    
	    #-combine and cluster blastx and repeatmasker hits
	    #-to get consensus repeat hits for gff3 and XML annotations
	    my $rm_keepers = repeat_mask_seq::process($rma_keepers, 
						      $repeat_blastx_keepers,
						      $query_seq
						     );
	    
	    #-add repeats to GFF3
	    $GFF3->repeat_hits($rm_keepers);
	    
	    #-build/fill big masked sequence
	    $masked_total_seq .= $chunk->seq();
	 }
      }
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed while repeat masking!!\n";
      print STDERR "FAILED CONTIG:$seq_id\n\n";

      my $die_count = $LOG->get_die_count();
      $die_count++;
      
      $LOG->add_entry("DIED","RANK","non_mpi");
      $LOG->add_entry("DIED","COUNT",$die_count);
      $failed_contig = 1;
      push(@failed, $fasta);
   };

   next CONTIG if ($failed_contig);

   #variables that are persistent outside of try block
   my $masked_fasta;
   my $snaps;
   my $augus;
   my $fasta_chunker;
   my $chunk_count;

   try{				#coresponds to level 4 in mpi-maker
      $masked_fasta = Fasta::toFasta($query_def.' masked', \$masked_total_seq);
      FastaFile::writeFile($masked_fasta ,$the_void."/query.masked.fasta");

      #==SNAP ab initio here
      $snaps = snap($masked_fasta,
		    $the_void,
		    $seq_out_name,
		    $CTL_OPTIONS{snap},
		    $CTL_OPTIONS{'snaphmm'}
		   );
      
      #==AUGUSTUS ab initio here
      $augus = [];
      $augus = augustus($masked_fasta,
			$the_void,
			$seq_out_name,
			$CTL_OPTIONS{'augustus'},
			$CTL_OPTIONS{'augustus_species'}
		       ) if ($CTL_OPTIONS{'augustus'});
      
      #--run blast analysis in these new chunks
      $fasta_chunker = new FastaChunker();
      $fasta_chunker = new FastaChunker();
      $fasta_chunker->parent_fasta($$masked_fasta);
      $fasta_chunker->chunk_size($CTL_OPTIONS{'max_dna_len'});
      $fasta_chunker->min_size($CTL_OPTIONS{'split_hit'});
      $fasta_chunker->load_chunks();


      $chunk_count = 0;
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed at ab-initio gene predictions!!\n";
      print STDERR "FAILED CONTIG:$seq_id\n\n";

      my $die_count = $LOG->get_die_count();
      $die_count++;
      
      $LOG->add_entry("DIED","RANK","non_mpi");
      $LOG->add_entry("DIED","COUNT",$die_count);
      $failed_contig = 1;
      push(@failed, $fasta);
   };

   next CONTIG if ($failed_contig);
    
   while (my $chunk = $fasta_chunker->get_chunk($chunk_count++)) {
      #==BLAST ANALYSIS HERE

      #variables that are persistent outside of try block
      my $blastn_keepers;

      try{			#coresponds to levels 5-6 in mpi_maker
	 #-blastn search the file against ESTs
	 $blastn_keepers = blastn($chunk,
				  $transcripts,
				  $the_void,
				  $seq_out_name,
				  $CTL_OPTIONS{blastn},
				  $CTL_OPTIONS{eval_blastn},
				  $CTL_OPTIONS{bit_blastn},
				  $CTL_OPTIONS{percov_blastn},
				  $CTL_OPTIONS{percid_blastn},
				  $CTL_OPTIONS{split_hit},
				  $CTL_OPTIONS{cpus}
				 );
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at blastn of ESTs!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";
	 
	 my $die_count = $LOG->get_die_count();
	 $die_count++;
      
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #variables that are persistent outside of try block
      my $blastx_keepers;

      try{			#coresponds to levels 7-8 in mpi_maker
	 #-blastx search the masked input file
	 $blastx_keepers = blastx($chunk, 
				  $proteins,
				  $the_void,
				  $seq_out_name,
				  $CTL_OPTIONS{blastx},
				  $CTL_OPTIONS{eval_blastx},
				  $CTL_OPTIONS{bit_blastx},
				  $CTL_OPTIONS{percov_blastx},
				  $CTL_OPTIONS{percid_blastx},
				  $CTL_OPTIONS{split_hit},
				  $CTL_OPTIONS{cpus}
				 );
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at blastx of proteins!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";
	 
	 my $die_count = $LOG->get_die_count();
	 $die_count++;
      
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #variables that are persistent outside of try block
      my $pred_command;
      my $preds_on_chunk;

      try{			#coresponds to level 9 in mpi_maker
	 #-- decide which gene finder to use to build annotations 

	 if ($CTL_OPTIONS{predictor} eq 'augustus') {
	    $pred_command = $CTL_OPTIONS{augustus} .' --species='.$CTL_OPTIONS{augustus_species};
	    $preds_on_chunk = get_preds_on_chunk($augus,
						 $chunk
						);
	 }
	 elsif ($CTL_OPTIONS{predictor} eq 'snap') {
	    $pred_command = $CTL_OPTIONS{snap}.' '.$CTL_OPTIONS{snaphmm};
	    $preds_on_chunk = get_preds_on_chunk($snaps,
						 $chunk
						);
	 }
	 elsif ($CTL_OPTIONS{predictor} eq 'est2genome') {
	    $pred_command = '';
	    $preds_on_chunk = [];
	 }
	 else {
	    die "ERROR: invalid predictor type: $CTL_OPTIONS{predictor}\n";
	 }

	 #==merge heldover Phathits from last round
	 if ($chunk->number != 0) { #if not first chunk
	    ($blastn_keepers,
	     $blastx_keepers) = merge_and_resolve_hits($masked_fasta,
						       $fasta_t_index,
						       $fasta_p_index,
						       $blastn_keepers,
						       $blastx_keepers,
						       $holdover_blastn,
						       $holdover_blastx,
						       $the_void,
						       \%CTL_OPTIONS,
						       $OPT{f}
						      );
	 }
	 
	 #==PROCESS HITS CLOSE TOO CHUNK DIVISIONS   
	 if (not $chunk->is_last) { #if not last chunk
	    ($holdover_blastn,
	     $holdover_blastx,
	     $holdover_preds,
	     $blastn_keepers,
	     $blastx_keepers,
	     $preds_on_chunk) = process_the_chunk_divide($chunk,
							 $CTL_OPTIONS{'split_hit'},
							 $blastn_keepers,
							 $blastx_keepers,
							 $preds_on_chunk
							);
	 }
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed while proccessing the chunk divide!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #==EXONERATE HERE

      #variables that are persistent outside of try block
      my $blastx_data;
      my $exonerate_p_data;

      try{			#coresponds to level 10 in mpi_maker
	 #-cluster the blastx hits
	 print STDERR "cleaning blastx...\n";
	 
	 my $blastx_clusters = cluster::clean_and_cluster($blastx_keepers,
							  $query_seq,
							  10);
	 
	 undef $blastx_keepers;
	 
	 #-make a multi-fasta of the seqs in the blastx_clusters 
	 #-polish the blastx hits with exonerate
	 
	 my $exonerate_p_clusters = polish_exonerate($fasta,
						     $blastx_clusters,
						     $fasta_p_index,
						     $the_void,
						     5,
						     'p',
						     $CTL_OPTIONS{exonerate},
						     $CTL_OPTIONS{percov_blastx},
						     $CTL_OPTIONS{percid_blastx},
						     $CTL_OPTIONS{ep_score_limit},
						     $CTL_OPTIONS{ep_matrix}
						    );
	 
	 my $blastx_data      = flatten($blastx_clusters);
	 my $exonerate_p_data = flatten($exonerate_p_clusters, 'exonerate:p');
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at exonerate against proteins!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #variables that are persistent outside of try block
      my $blastn_data;
      my $exonerate_e_data;

      try{			#coresponds to levels 11 in mpi_maker
	 #-cluster the blastn hits
	 print STDERR "cleaning blastn...\n";
	 my $blastn_clusters = cluster::clean_and_cluster($blastn_keepers,
							  $query_seq,
							  10
							 );
	 
	 undef $blastn_keepers;
	 
	 #-polish blastn hits with exonerate
	 my $exonerate_e_clusters = polish_exonerate($fasta,
						     $blastn_clusters,
						     $fasta_t_index,
						     $the_void,
						     5,
						     'e',
						     $CTL_OPTIONS{exonerate},
						     $CTL_OPTIONS{percov_blastn},
						     $CTL_OPTIONS{percid_blastn},
						     $CTL_OPTIONS{en_score_limit},
						     $CTL_OPTIONS{en_matrix}
						    ); 
	 
	 $blastn_data      = flatten($blastn_clusters);
	 $exonerate_e_data = flatten($exonerate_e_clusters, 'exonerate:e');
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at exonerate against transcripts!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #####working here###########
      #==MAKER annotations built here

      #variables that are persistent outside of try block
      my $annotations;

      try{			#coresponds to level 12 in mpi_maker
	 #-auto-annotate the input file
	 $annotations = maker::auto_annotator::annotate($fasta,
							$$masked_fasta,
							$chunk->number(),
							$exonerate_p_data,
							$exonerate_e_data,
							$blastx_data,
							$preds_on_chunk,
							$the_void,
							$pred_command,
							$CTL_OPTIONS{snap_flank},
							$CTL_OPTIONS{'single_exon'},
							$OPT{f},
							$OPT{SNAPS},
							$CTL_OPTIONS{predictor},
						       );
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at annotation generation!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      try{			#coresponds to levels 13 in mpi_maker
	 #==OUTPUT DATA HERE
	 
	 #--- GFF3      
	 $GFF3->genes($annotations);
	 $GFF3->phat_hits($blastx_data);
	 $GFF3->phat_hits($blastn_data);
	 $GFF3->phat_hits($exonerate_p_data);
	 $GFF3->phat_hits($exonerate_e_data);
	 
	 #--- GAME XML
	 
	 #my $IOX= new Dumper::XML::Game->init(FastaFile=>$CTL_OPTIONS{'genome'},
	 #                                     WriteFile=>$out_dir."/".$seq_out_name.".xml"
	 #                                    );
	 #$IOX->add_hits($rm_keepers);
	 #$IOX->add_hits($blastx_keepers);
	 #$IOX->add_hits($blastn_keepers);
	 #foreach my $pp (@$exonerate_p_clusters) {
	 #   $IOX->add_hits($pp);
	 #}
	 #foreach my $ee (@$exonerate_e_clusters) {
	 #   $IOX->add_hits($ee);
	 #}      
	 #$IOX->add_hits($snaps);
	 
	 #---adding auto annotations
	 
	 #my @quality_indices;
	 #foreach my $an (@$annotations) {
	 #   my $g_name     = $an->{g_name};
	 #   my $g_s        = $an->{g_start};
	 #   my $g_e        = $an->{g_end};
	 #   my $g_strand   = $an->{g_strand};
	 #
	 #   my @temp_ant;
	 #   foreach my $a (@{$an->{t_structs}}) {
	 #       push(@quality_indices, [$a->{t_name}, $a->{t_qi}]);
	 #
	 #       my ($p_fasta, $t_fasta) = get_p_and_t_fastas($a);
	 #
	 #       $t_fastas .= $$t_fasta;
	 #       $p_fastas .= $$p_fasta;
	 #
	 #       push (@temp_ant,$a) if defined($a->{hit});
	 #       $IOX->add_autoant($a) if defined($a->{hit});
	 #   }
	 #}
	 #Write the quality index of the mRNAs to a separate file.
	 #write_quality_data(\@quality_indices, $seq_id);
	 #
	 #   $IOX->Game();
	 
	 #--- building fastas for annotations (grows with itteration)
	 my ($p_fasta, $t_fasta) = get_maker_p_and_t_fastas($annotations);
	 $p_fastas .= $p_fasta;
	 $t_fastas .= $t_fasta;
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at processing annotations on chunk!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);
   }				#END CONTIG

   try{				#coresponds to levels 14 in mpi_maker
      #--- building fastas of predictions
      my ($p_snap_fastas, $t_snap_fastas) = get_snap_p_and_t_fastas($query_seq, $snaps);
      my ($p_augus_fastas, $t_augus_fastas) = get_snap_p_and_t_fastas($query_seq, $augus);
      
      #--Write fasta files now that all chunks are finished
      FastaFile::writeFile(\$p_fastas ,"$out_dir\/$seq_out_name\.maker.proteins.fasta");
      FastaFile::writeFile(\$t_fastas ,"$out_dir\/$seq_out_name\.maker.transcripts.fasta");
      FastaFile::writeFile(\$p_snap_fastas ,"$out_dir\/$seq_out_name\.maker.snap.proteins.fasta");
      FastaFile::writeFile(\$t_snap_fastas ,"$out_dir\/$seq_out_name\.maker.snap.transcript.fasta");
      if ($CTL_OPTIONS{'augustus'}) {
	 FastaFile::writeFile(\$p_augus_fastas ,"$out_dir\/$seq_out_name\.maker.augus.proteins.fasta");
	 FastaFile::writeFile(\$t_augus_fastas ,"$out_dir\/$seq_out_name\.maker.augus.transcript.fasta");
      }
      
      #--- add predictions to GFF and write
      $GFF3->predictions($snaps);
      $GFF3->predictions($augus);
      $GFF3->print($out_dir."/".$seq_out_name.".gff");
      
      #--cleanup maker files created with each fasta sequence
      File::Path::rmtree ($the_void) if $CTL_OPTIONS{clean_up};	#rm temp directory
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed while writing final data!!\n";
      print STDERR "FAILED CONTIG:$seq_id\n\n";

      my $die_count = $LOG->get_die_count();
      $die_count++;
	 
      $LOG->add_entry("DIED","RANK","non_mpi");
      $LOG->add_entry("DIED","COUNT",$die_count);
      $failed_contig = 1;
      push(@failed, $fasta);
   };

   next CONTIG if ($failed_contig);

   #--- clear the log variable
   $LOG = undef;
}

print STDERR "\n\nMaker is now finished!!!\n\n";

exit(0);

#-----------------------------------------------------------------------------
#----------------------------------- SUBS ------------------------------------
#-----------------------------------------------------------------------------
sub get_preds_on_chunk {
   my $preds = shift;
   my $chunk = shift;

   my $c_start = $chunk->offset + 1;
   my $c_end = $chunk->offset + $chunk->length;
   
   my @keepers;
   foreach my $pred (@{$preds}) {
      my $s_start = $pred->start('query');

      if ($pred->strand('query') eq '1' && $c_start <= $s_start && $s_start <= $c_end) {
	 push (@keepers, $pred);
      }
   }

   return \@keepers;
}

#-----------------------------------------------------------------------------
sub merge_and_resolve_hits{
   my $fasta = shift @_;
   my $fasta_t_index = shift @_;
   my $fasta_p_index = shift @_;
   my $blastn_keepers = shift @_;
   my $blastx_keepers = shift @_;
   my $blastn_holdovers = shift @_;
   my $blastx_holdovers = shift @_;
   my $the_void = shift @_;
   my %CTL_OPTIONS = %{shift @_};
   my $OPT_f = shift @_;

   PhatHit_utils::merge_hits($blastn_keepers,  
			     $blastn_holdovers, 
			     $CTL_OPTIONS{split_hit},
			    );
   @{$blastn_holdovers} = ();

   PhatHit_utils::merge_hits($blastx_keepers,  
			     $blastx_holdovers, 
			     $CTL_OPTIONS{split_hit},
			    );
   @{$blastx_holdovers} = ();

   $blastn_keepers = reblast_merged_hits($fasta,
					 $blastn_keepers,
					 $fasta_t_index,
					 $the_void,
					 'blastn',
					 \%CTL_OPTIONS,
					 $OPT_f
					);

   $blastx_keepers = reblast_merged_hits($fasta,
					 $blastx_keepers,
					 $fasta_p_index,
					 $the_void,
					 'blastx',
					 \%CTL_OPTIONS,
					 $OPT_f
					);

   return ($blastn_keepers, $blastx_keepers);
}
#-----------------------------------------------------------------------------
sub reblast_merged_hits {
   my $g_fasta     = shift @_;
   my $hits         = shift @_;
   my $db_index    = shift @_;
   my $the_void    = shift @_;
   my $type        = shift @_;
   my %CTL_OPTIONS = %{shift @_};
   my $OPT_f       = shift @_;

   #==get data from parent fasta

   #parent fasta get def and seq
   my $par_def = Fasta::getDef($$g_fasta);
   my $par_seq = Fasta::getSeq($$g_fasta);

   #get seq id off def line
   my $p_id  = $par_def;
   $p_id =~ s/\s+/_/g;
   $p_id =~ s/\|/_/g;

   #build a safe name for file names from the sequence identifier
   my $p_safe_id = uri_escape($p_id, 
			      '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
			     );

   my @blast_keepers;

   #==check whether to re-blast each hit
   foreach my $hit (@{$hits}) {
      #if not a merged hit take as is
      if (not $hit->{'_sequences_was_merged'}) {
	 push (@blast_keepers, $hit);
	 next;
      }

      #== excise region of query fasta and build new chunk object for blast
      
      #find region of hit to get piece
      my ($nB, $nE) = PhatHit_utils::get_span_of_hit($hit,'query');   
      my @coors = [$nB, $nE];
      my $piece = Shadower::getPieces($par_seq, \@coors, $CTL_OPTIONS{split_hit});
      
      #get piece fasta def, seq, and offset
      my $piece_def = $par_def." ".$piece->[0]->{b}." ".$piece->[0]->{e};
      my $piece_seq = $piece->[0]->{piece};
      my $offset = $piece->[0]->{b} - 1;
      
      #make the piece into a fasta chunk
      my $chunk = new FastaChunk();
      $chunk->seq($piece_seq);
      $chunk->def($piece_def);
      $chunk->parent_def($par_def);
      $chunk->size(length($$par_seq));	     #the max size of a chunk
      $chunk->length(length($chunk->seq())); #the actual size of a chunk                                                
      $chunk->offset($offset);
      $chunk->number(0);
      $chunk->is_last(1);
      $chunk->parent_seq_length(length($$par_seq));

      #==build new fasta and db for blast search from hit name and db index
      
      #get name to search db index
      my $t_id  = $hit->name();
      $t_id =~ s/\s+/_/g;
      $t_id =~ s/\|/_/g;
      
      #build a safe name for file names from the sequence identifier
      my $t_safe_id = uri_escape($t_id, 
				 '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
				);
      #search db index
      my $fastaObj = $db_index->get_Seq_by_id($hit->name);
      if (not $fastaObj) {
	 print STDERR "stop here:".$hit->name."\n";
	 die "ERROR: Fasta index error\n";
      }
      
      #get fasta def and seq
      my $t_seq      = $fastaObj->seq();
      my $t_def      = $db_index->header($hit->name);
      $t_def =~ s/\|/_/g;
      
      #write fasta file
      my $fasta = Fasta::toFasta('>'.$t_def, \$t_seq);
      my $t_file = $the_void."/".$t_safe_id.'.for_'.$type.'.fasta';
      FastaFile::writeFile($fasta, $t_file);
      
      #build db for blast using xdformat
      if ( $type eq 'blastx' && ! -e $t_file.'.xpd') {
	 system($CTL_OPTIONS{xdformat}. " -p -C ".$CTL_OPTIONS{'alt_peptide'}." $t_file");
      }
      elsif ( $type eq 'blastn' && ! -e $t_file.'.xnd') {
	 system($CTL_OPTIONS{xdformat}. " -n $t_file");
      }

      #==run the blast search
      if ($type eq 'blastx') {

	 print STDERR "re-running blast against $t_id...\n";
	 my $keepers = blastx($chunk, 
			      $t_file,
			      $the_void,
			      $p_safe_id."-2-".$t_safe_id,
			      $CTL_OPTIONS{blastx},
			      $CTL_OPTIONS{eval_blastx},
			      $CTL_OPTIONS{bit_blastx},
			      $CTL_OPTIONS{percov_blastx},
			      $CTL_OPTIONS{percid_blastx},
			      $CTL_OPTIONS{split_hit},
			      $CTL_OPTIONS{cpus}
			     );

	 push(@blast_keepers, @{$keepers});
	 print STDERR "...finished\n";
      }
      elsif ($type eq 'blastn') {

	 print STDERR "re-running blast against $t_id...\n";
	 my $keepers = blastn($chunk, 
			      $t_file,
			      $the_void,
			      $p_safe_id."-2-".$t_safe_id,,
			      $CTL_OPTIONS{blastn},
			      $CTL_OPTIONS{eval_blastn},
			      $CTL_OPTIONS{bit_blastn},
			      $CTL_OPTIONS{percov_blastn},
			      $CTL_OPTIONS{percid_blastn},
			      $CTL_OPTIONS{split_hit},
			      $CTL_OPTIONS{cpus}
			     );
	 
	 push(@blast_keepers, @{$keepers});
	 print STDERR "...finished\n";
      }
      else {
	 die "ERROR: Invaliv type \'$type\' in maker::reblast_merged_hit\n";
      }
   }

   #==return hits
   return (\@blast_keepers);
}
#-----------------------------------------------------------------------------
sub process_the_chunk_divide{
   my $chunk = shift @_;
   my $split_hit = shift @_;
   my $hit_groups = \@_; #processed and returned in order given by user

   my $phat_hits;

   foreach my $group (@{$hit_groups}) {
      push(@{$phat_hits}, @{$group});
   }

   my ($p_hits, $m_hits) = PhatHit_utils::seperate_by_strand('query', $phat_hits);
   my $p_coors  = PhatHit_utils::to_begin_and_end_coors($p_hits, 'query');
   my $m_coors  = PhatHit_utils::to_begin_and_end_coors($m_hits, 'query');

   foreach my $p_coor (@{$p_coors}) {
      $p_coor->[0] -= $chunk->offset();
      $p_coor->[1] -= $chunk->offset();
      $p_coor->[0] = $chunk->length if($p_coor->[0] > $chunk->length);
      $p_coor->[1] = $chunk->length if($p_coor->[1] > $chunk->length);
   }
   foreach my $m_coor (@{$m_coors}) {
      $m_coor->[0] -= $chunk->offset();
      $m_coor->[1] -= $chunk->offset();
      #fix coordinates for hits outside of chunk end
      $m_coor->[0] = $chunk->length if($m_coor->[0] > $chunk->length);
      $m_coor->[1] = $chunk->length if($m_coor->[1] > $chunk->length);
      #fix coordinates for hits outside of chunk begin
      $m_coor->[0] = 0 if($m_coor->[0] < 0);
      $m_coor->[1] = 0 if($m_coor->[1] < 0);
   }

   my $p_pieces = Shadower::getPieces(\($chunk->seq), $p_coors, 10);
   $p_pieces = [sort {$b->{e} <=> $a->{e}} @{$p_pieces}];
   my $m_pieces = Shadower::getPieces(\($chunk->seq), $m_coors, 10);
   $m_pieces = [sort {$b->{e} <=> $a->{e}} @{$m_pieces}];

   my @keepers;
   my @holdovers;

   my $cutoff = $chunk->length + $chunk->offset - $CTL_OPTIONS{'split_hit'};
   my $p_cutoff = $chunk->length + $chunk->offset + 1;
   my $m_cutoff = $chunk->length + $chunk->offset + 1;

   foreach my $p_piece (@{$p_pieces}) {
      if ($p_piece->{e} + $chunk->offset >= $cutoff) {
	 $p_cutoff = $p_piece->{b} + $chunk->offset;
      }
   }
   foreach my $m_piece (@{$m_pieces}) {
      if ($m_piece->{e} + $chunk->offset >= $cutoff) {
	 $m_cutoff = $m_piece->{b} + $chunk->offset;
      }
   }

   if ($p_cutoff <= 1 && $m_cutoff <= 1) { #too small, all are heldover for next round
      push (@holdovers, @{$hit_groups});
      return @holdovers, @keepers;
   }

   foreach my $group (@{$hit_groups}) {
      my $group_keepers = [];
      my $group_holdovers = [];

      foreach my $hit (@{$group}) {
	 my $b = $hit->nB('query');
	 my $e = $hit->nE('query');
	 my $strand = $hit->strand;

	 ($b, $e) = ($e, $b) if $b > $e;
	 
	 if (($e < $p_cutoff && $strand eq '1') ||
	     ($e < $m_cutoff && $strand eq '-1')
	    ) {
	    push(@{$group_keepers}, $hit);
	 }
	 else {
	    push(@{$group_holdovers}, $hit);
	 }
      }

      push(@keepers, $group_keepers);
      push(@holdovers, $group_holdovers);
   }

   my $abs_cutoff = ($p_cutoff < $m_cutoff) ? $p_cutoff -200 : $m_cutoff -200;
   my $sub_strt = $abs_cutoff - $chunk->offset - 1;
   $sub_strt = 0 if($sub_strt < 0);

   #   my $new_chunk = Storable::dclone($chunk); 
   #      $new_chunk->p_cutoff($p_cutoff);
   #      $new_chunk->m_cutoff($m_cutoff);
   #      $new_chunk->length($chunk->length - ($abs_cutoff - $chunk->offset - 1));
   #      $new_chunk->offset($abs_cutoff - 1);
   #      $new_chunk->seq(substr($new_chunk->seq,
   #			     $sub_strt,
   #			     $new_chunk->length
   #			    )
   #		     );

   #hit holdovers and keepers are returned in same order given by user
   return @holdovers, @keepers; 
}
#-----------------------------------------------------------------------------
sub build_datastore {
   my %CTL_OPTIONS = %{shift @_};

   $CTL_OPTIONS{'dsroot'} = "$CTL_OPTIONS{'out_base'}/$CTL_OPTIONS{'out_name'}_datastore";
   $CTL_OPTIONS{'dsindex'} = "$CTL_OPTIONS{'out_base'}/$CTL_OPTIONS{'out_name'}_master_datastore.index";

   print STDERR "A data structure will be created for you at:\n".
   "$CTL_OPTIONS{'dsroot'}\n\n".
   "To access files for individual sequences use the datastore index:\n".
   "$CTL_OPTIONS{'dsindex'}\n\n";
    
   $CTL_OPTIONS{'datastore'} = new Datastore::MD5('root' => $CTL_OPTIONS{'dsroot'}, 'depth' => 2);
   $CTL_OPTIONS{'fh_dsindex'} = new FileHandle();
   $CTL_OPTIONS{'fh_dsindex'}->open("> $CTL_OPTIONS{'dsindex'}");
   $CTL_OPTIONS{'fh_dsindex'}->autoflush(1);

   return %CTL_OPTIONS;
}
#-----------------------------------------------------------------------------
sub write_quality_data {
   my $quality_indices = shift;
   my $seq_id          = shift;

   my $out_file = $seq_id.'.maker.transcripts.qi';
   my $fh = new FileHandle();
   $fh->open(">$out_file");

   print $fh "genomic_seq\ttranscript\tquality_index\n";

   while (my $d = shift(@{$quality_indices})) {
      my $t_name = $d->[0];
      my $t_qi   = $d->[1];
	
      print $fh "$seq_id\t$t_name\t$t_qi\n";
   }
   $fh->close();
}
#-----------------------------------------------------------------------------
sub get_snap_p_and_t_fastas {
   my $seq   = shift;
   my $snaps = shift;
	
   my $p_fastas = '';
   my $t_fastas = '';
   foreach my $hit (@{$snaps}) {
      my $t_name = $hit->name(); # note this is being set in GFFV3::pred_data
      my $t_seq  = maker::auto_annotator::get_transcript_seq($hit, $seq);	
		
      my ($p_seq, $offset, $end) = 
      maker::auto_annotator::get_translation_seq($t_seq);
		
      my $score = 0;
      foreach my $hsp ($hit->hsps) {
	 $score += $hsp->score();
      }
		
      my $p_def = '>'.$t_name.' protein score:'.$score;
      my $t_def = '>'.$t_name.' snap.transcript offset:'.$offset;
      $t_def.= ' score:'.$score; 
		
      my $p_fasta = Fasta::toFasta($p_def, \$p_seq);
      my $t_fasta = Fasta::toFasta($t_def, \$t_seq);
		
      $p_fastas .= $$p_fasta;
      $t_fastas .= $$t_fasta;
		
   }
   return ($p_fastas, $t_fastas);
}
#-----------------------------------------------------------------------------
sub get_maker_p_and_t_fastas {
   my $annotations = shift @_;
   
   my $p_fastas = '';
   my $t_fastas = '';
   
   foreach my $an (@$annotations) {
      foreach my $a (@{$an->{t_structs}}) {
	 my ($p_fasta, $t_fasta) = get_p_and_t_fastas($a);
	 $p_fastas .= $$p_fasta;
	 $t_fastas .= $$t_fasta;
      }
   }
   
   return $p_fastas, $t_fastas;
}

#-----------------------------------------------------------------------------
sub get_p_and_t_fastas {
   my $t_struct = shift;
	
   my $t_seq  = $t_struct->{t_seq};
   my $p_seq  = $t_struct->{p_seq};
   my $t_off  = $t_struct->{t_offset};
   my $t_name = $t_struct->{t_name};
	
   my $p_def = '>'.$t_name.' protein'; 
   my $t_def = '>'.$t_name.' transcript offset:'.$t_off;
	
   my $p_fasta = Fasta::toFasta($p_def, \$p_seq);
   my $t_fasta = Fasta::toFasta($t_def, \$t_seq);
	
   return($p_fasta, $t_fasta);
}
#----------------------------------------------------------------------------
sub create_blastdb {
   my %CTL_OPTIONS = %{shift @_};

   unless (-e $CTL_OPTIONS{'protein'}.'.xpd') {
      system($CTL_OPTIONS{xdformat}. " -p -C $CTL_OPTIONS{'alt_peptide'} $CTL_OPTIONS{'protein'}");
   }
   unless (-e $CTL_OPTIONS{'est'}.'.xnd') {
      system($CTL_OPTIONS{xdformat}. " -n $CTL_OPTIONS{'est'}");
   }
   if (!$OPT{R} && ! -e $CTL_OPTIONS{'repeat_protein'}.'.xpd') {
      system($CTL_OPTIONS{xdformat}." -p $CTL_OPTIONS{'repeat_protein'}");
   }
   if ($CTL_OPTIONS{'alt_est'} && ! $CTL_OPTIONS{'alt_est'}.'.xnd') {
      system($CTL_OPTIONS{xdformat}. " -n $CTL_OPTIONS{'alt_est'}");
   }
}
#----------------------------------------------------------------------------
sub load_anno_hsps {
   my $annotations = shift;
   my @coors;
   my $i = @{$annotations};
   foreach my $an (@$annotations) {
      foreach my $a (@{$an->[0]}) {
	 my $hit = $a->{hit};
	 foreach my $hsp ($hit->hsps()) {
	    push(@coors, [$hsp->nB('query'),
			  $hsp->nE('query'),
			 ]);
	 }
      }
   }
   return (\@coors, $i);;
}
#-----------------------------------------------------------------------------
sub load_clust_hsps {
   my $clusters = shift;
   my @coors;
   my $i = @{$clusters};
   foreach my $c (@$clusters) {
      foreach my $hit (@{$c}) {
	 foreach my $hsp ($hit->hsps()) {
	    push(@coors, [$hsp->nB('query'),
			  $hsp->nE('query'),
			 ]);
	 }
      }
   }
   return (\@coors, $i);
}
#-----------------------------------------------------------------------------
sub load_snap_hsps {
   my $snaps = shift;
   my @coors;
   my $i = @{$snaps};
   foreach my $hit (@{$snaps}) {
      foreach my $hsp ($hit->hsps()) {
	 push(@coors, [$hsp->nB('query'),
		       $hsp->nE('query'),
		      ]);
      }
   }
   return (\@coors, $i);
}
#-----------------------------------------------------------------------------
sub flatten {
   my $clusters = shift;
   my $type     = shift;
   my @hits;
   foreach my $c (@{$clusters}) {
      foreach my $hit (@{$c}) {
	 $hit->type($type) if defined($type);
	 push(@hits, $hit);
      }
   }
   return \@hits;
}
#-----------------------------------------------------------------------------
sub snap {
   my $fasta      = shift;
   my $the_void   = shift;
   my $seq_id     = shift;
   my $snap       = shift;
   my $snaphmm    = shift;
	
   my %params;
   my $file_name = "$the_void/$seq_id.all";
   my $o_file    = "$the_void/$seq_id\.all\.snap";


   $LOG->add_entry("STARTED", $o_file, "");   


   FastaFile::writeFile($fasta , $file_name);
		
   runSnap($file_name,
	   $o_file,
	   $snap,
	   $snaphmm
	  );

   $LOG->add_entry("FINISHED", $o_file, "");
	
   $params{min_exon_score}  = -100000;	    #-10000;
   $params{min_gene_score}  = -100000;	    #0;
		
   my $chunk_keepers = Widget::snap::parse($o_file,
					   \%params,
					   $file_name,
					  );

   unlink($file_name);

   return $chunk_keepers;
}
#-----------------------------------------------------------------------------
sub runSnap {
   my $q_file   = shift;
   my $out_file = shift;
   my $snap = shift;
   my $snaphmm = shift;
	
   my $command  = $snap;
   $command .= " $snaphmm";
   $command .= " $q_file";
   $command .= " > $out_file";
	
   my $w = new Widget::snap();
	
   if (-e $out_file && ! $OPT{f}) {
      print STDERR "re reading snap report.\n";
      print STDERR "$out_file\n";
   }
   else {
      print STDERR "running  snap.\n";
      $w->run($command);
   }
}
#-----------------------------------------------------------------------------
sub augustus {
   my $fasta      = shift;
   my $the_void   = shift;
   my $seq_id     = shift;
   my $exe        = shift;
   my $org        = shift;

   my %params;
   my $file_name = "$the_void/$seq_id.all";
   my $o_file    = "$the_void/$seq_id\.all\.augustus";

   $LOG->add_entry("STARTED", $o_file, ""); 

   FastaFile::writeFile($fasta , $file_name) unless -e $file_name;

   runAugustus($file_name,
               $o_file,
               $exe,
               $org
	      );

   $LOG->add_entry("FINISHED", $o_file, "");

   $params{min_exon_score}  = -100000;      #-10000;
   $params{min_gene_score}  = -100000;      #0;

   my $chunk_keepers = Widget::augustus::parse($o_file,
					       \%params,
					       $file_name,
					      );

   unlink($file_name);

   return $chunk_keepers;
}

#-----------------------------------------------------------------------------
sub runAugustus {
   my $q_file   = shift;
   my $out_file = shift;
   my $exe      = shift;
   my $org      = shift;

   my $command  = $exe;
   $command .= ' --species='."$org";
   $command .= " $q_file";
   $command .= " > $out_file";

   my $w = new Widget::augustus();

   if (-e $out_file && ! $OPT{f}) {
      print STDERR "re reading augustus report.\n";
      print STDERR "$out_file\n";
   }
   else {
      print STDERR "running  augustus.\n";
      $w->run($command);
   }
}
#-----------------------------------------------------------------------------
sub polish_exonerate {
   my $g_fasta           = shift;
   my $phat_hit_clusters = shift;
   my $db_index          = shift;
   my $the_void          = shift;
   my $depth             = shift;
   my $type              = shift;
   my $exonerate         = shift;
   my $percov            = shift;
   my $percid            = shift;
   my $score_limit       = shift;
   my $matrix            = shift;

   my $def = Fasta::getDef($g_fasta);
   my $seq = Fasta::getSeq($g_fasta);
	
   my $exe = $exonerate;
	
   my @exonerate_clusters;
   my $i = 0;
   foreach my $c (@{$phat_hit_clusters}) {
      my $n = 0;
      my $got_some = 0;

      foreach my $hit (@{$c}) {
	 last if $n == $depth;

	 next if $hit->pAh < $percov;
	 next if $hit->hsp('best')->frac_identical < $percid;
	 
	 my ($nB, $nE) = PhatHit_utils::get_span_of_hit($hit,'query');

	 my @coors = [$nB, $nE];
	 my $p = Shadower::getPieces($seq, \@coors, 50);
	 my $p_def = $def." ".$p->[0]->{b}." ".$p->[0]->{e};
	 my $p_fasta = Fasta::toFasta($p_def, \$p->[0]->{piece});
	 my ($name) = $p_def =~ />([^\s\t\n]+)/;

	 #build a safe name for file names from the sequence identifier
	 my $safe_name = uri_escape($name,
				    '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
				   );
	 $safe_name .= '.fasta';
	 my $d_file = $the_void."/".$safe_name.'.'.$i.'.'.$n;
	 FastaFile::writeFile($p_fasta, $d_file);
	 my $offset = $p->[0]->{b} - 1;
	 my $id  = $hit->name();
	 $id =~ s/\s+/_/g;
	 $id =~ s/\|/_/g;
	 my $fastaObj = $db_index->get_Seq_by_id($hit->name);
	 if (not $fastaObj) {
	    print "stop here:".$hit->name."\n";
	    die "ERROR: Fasta index error\n";
	 }
	 my $seq      = $fastaObj->seq();
	 my $def      = $db_index->header($hit->name);
	 $def =~ s/\|/_/g;
	 my $fasta    = Fasta::toFasta('>'.$def, \$seq);

	 #build a safe name for file names from the sequence identifier
	 my $safe_id = uri_escape($id, 
				  '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
				 );

	 my $t_file    = $the_void."/".$safe_id.'.'.$i.'.'.$n.'.fasta';
	 my $ext = "$i\.$n";
	 FastaFile::writeFile($fasta, $t_file);

	 my $exonerate_hits = to_polisher($d_file,
					  $t_file,
					  $the_void,
					  $offset,
					  $type,
					  $ext,
					  $exe,
					  $score_limit,
					  $matrix
					 );

	 foreach my $exonerate_hit (@{$exonerate_hits}) {
	    if (defined($exonerate_hit) && exonerate_okay($exonerate_hit)) {
	       $n++;
	       push(@{$exonerate_clusters[$i]}, $exonerate_hit);
	       $got_some = 1;
	    }
	 }
      }
      $i++ if $got_some;
   }
   return \@exonerate_clusters;
}
#-----------------------------------------------------------------------------
sub exonerate_okay {
   my $hit  = shift;

   my $i = 0;
   foreach my $hsp ($hit->hsps()) {
      return 0 unless defined($hsp->nB('query'));
      return 0 unless defined($hsp->nE('query'));
      return 0 unless defined($hsp->nB('hit'));
      return 0 unless defined($hsp->nE('hit'));
      return 0 unless defined($hsp->strand('query'));
      return 0 unless defined($hsp->strand('query'));
      return 0 unless defined($hsp->strand('hit'));
      return 0 unless defined($hsp->strand('hit'));

      my $q_str = $hsp->query_string();
      my $h_str = $hsp->hit_string();
		
      if ($h_str =~ /Target Intron/) {
	 print STDERR "BADDD EXONERATE!\n";
	 sleep 4;
	 return 0;
      } elsif ($q_str =~ /Target Intron/) {
	 print STDERR "BADDD EXONERATE!\n";
	 sleep 4;
	 return 0;
      }
      $i++;
   }

   return 1 
}
#-----------------------------------------------------------------------------
sub to_polisher {
   my $d_file   = shift;
   my $t_file   = shift;
   my $the_void = shift;
   my $offset   = shift;
   my $type     = shift;
   my $ext      = shift;
   my $exe      = shift;
   my $score_limit = shift;
   my $matrix = shift;
    
   if ($type eq 'p') {
      return polisher::exonerate::protein::polish($d_file,
						  $t_file,
						  $the_void,
						  $offset,
						  $ext,
						  $exe,
						  $score_limit,
						  $matrix,
						  $OPT{f}
						 );
   } elsif ($type eq 'e') {
      return polisher::exonerate::est::polish($d_file,
					      $t_file,
					      $the_void,
					      $offset,
					      $ext,
					      $exe,
					      $score_limit,
					      $matrix,
					      $OPT{f}
					     );
   } else {
      die "unknown type:$type in sub to_polisher.\n";
   }
}
#-----------------------------------------------------------------------------
sub make_multi_fasta {
   my $index    = shift;
   my $clusters = shift;;
   my $fastas = '';
   foreach my $c (@{$clusters}) {
      foreach my $hit (@{$c}) {
	 my $id = $hit->name();
	 my $fastaObj = $index->get_Seq_by_id($id);
	 my $seq      = $fastaObj->seq(); 
	 my $def      = $index->header($id);
	 my $fasta    = Fasta::toFasta('>'.$def, \$seq);
	 $fastas     .= $$fasta; 
      }
   }
   return \$fastas;
}
#-----------------------------------------------------------------------------
sub build_fasta_index {
   my $db = shift;
   my $index = new Bio::DB::Fasta($db);
   return $index;
}

#-----------------------------------------------------------------------------
sub blastn {
   my $chunk      = shift;
   my $db         = shift;
   my $the_void    = shift;
   my $seq_id     = shift;
   my $blastn = shift;
   my $eval_blastn = shift;
   my $bit_blastn = shift,
   my $percov_blastn = shift;
   my $percid_blastn = shift;
   my $split_hit = shift;
   my $cpus = shift;

   my ($db_n) = $db =~ /([^\/]+)$/;
   $db_n  =~ s/\.fasta$//;
	
   my $chunk_number = $chunk->number();
   my $q_length = $chunk->parent_seq_length();
   my $file_name = "$the_void/$seq_id\.$chunk_number";
   my $o_file    = "$the_void/$seq_id\.$chunk_number\.$db_n\.blastn";

   $LOG->add_entry("STARTED", $o_file, ""); 

   $chunk->write_file($file_name);
   runBlastn($file_name,
	     $db,
	     $o_file,
	     $blastn,
	     $eval_blastn,
	     $cpus
	    );

   $LOG->add_entry("FINISHED", $o_file, "");

   my %params;
   $params{significance}  = $eval_blastn;
   $params{hsp_bit_min}   = $bit_blastn;
   $params{percov}        = $percov_blastn;
   $params{percid}        = $percid_blastn;
   $params{split_hit}     = $split_hit;

   my $chunk_keepers = Widget::blastn::parse($o_file,
					     \%params,
					    );

   PhatHit_utils::add_offset($chunk_keepers,
			     $chunk->offset(),
			    );

   $chunk->erase_fasta_file();
   
   #   if($chunk->p_cutoff || $chunk->m_cutoff){
   #      my @keepers;
   #      
   #      foreach my $hit (@{$chunk_keepers}){
   #	 if ($hit->strand('query') eq '1' && $hit->start('query') >= $chunk->p_cutoff){
   #	    push (@keepers, $hit)
   #	 }
   #	 elsif ($hit->strand('query') eq '-1' && $hit->start('query') >= $chunk->m_cutoff){
   #	    push (@keepers, $hit)
   #	 }
   #     }
   #      
   #      return \@keepers;
   #   }

   return $chunk_keepers
}
#-----------------------------------------------------------------------------
sub runBlastn {
   my $q_file   = shift;
   my $db       = shift;
   my $out_file = shift;
   my $blastn = shift;
   my $eval_blastn = shift;
   my $cpus = shift;
	
   my $command  = $blastn;
   $command .= " $db $q_file B=100000 V=100000 E=$eval_blastn";
   $command .= " wordmask=seg";
   $command .= " R=3";
   $command .= " W=15";
   $command .= " M=1";
   $command .= " N=-3";
   $command .= " Q=3";
   $command .= " Z=128000000";
   $command .= " cpus=$cpus";	
   $command .= " topcomboN=1";
   $command .= " hspmax=100";
   $command .= " gspmax=100";
   $command .= " hspsepqmax=10000";
   $command .= " lcmask";
   $command .= " filter=seg";
   $command .= " gi";
   #$command .= " mformat=2"; # remove for full report
   $command .= " > $out_file";
	
   my $w = new Widget::blastn();
   if (-e $out_file && ! $OPT{f}) {
      print STDERR "re reading blast report.\n";
      print STDERR "$out_file\n";
   }
   else {
      print STDERR "running  blast search.\n";
      $w->run($command);
   }

}
#-----------------------------------------------------------------------------
sub blastx {
   my $chunk      = shift;
   my $db         = shift;
   my $the_void    = shift;
   my $seq_id     = shift;
   my $blastx = shift;
   my $eval_blastx = shift;
   my $bit_blastx = shift;
   my $percov_blastx = shift;
   my $percid_blastx = shift;
   my $split_hit = shift;
   my $cpus = shift;

   my ($db_n) = $db =~ /([^\/]+)$/;
   $db_n  =~ s/\.fasta$//;

   my $q_length = $chunk->parent_seq_length();
   my $chunk_number = $chunk->number();
		
   my $file_name = "$the_void/$seq_id\.$chunk_number";
   my $o_file    = "$the_void/$seq_id\.$chunk_number\.$db_n\.blastx";

   $LOG->add_entry("STARTED", $o_file, ""); 

   $chunk->write_file($file_name);
   runBlastx($file_name,
	     $db,
	     $o_file,
	     $blastx,
	     $eval_blastx,
	     $cpus
	    );

   $LOG->add_entry("FINISHED", $o_file, "");

   my %params;
   $params{significance}  = $eval_blastx;
   $params{hsp_bit_min}   = $bit_blastx;
   $params{percov}        = $percov_blastx;
   $params{percid}        = $percid_blastx;
   $params{split_hit}     = $split_hit;
   
   my $chunk_keepers = Widget::blastx::parse($o_file,
					     \%params,
					    );

   PhatHit_utils::add_offset($chunk_keepers,
			     $chunk->offset(),
			    );
   
   $chunk->erase_fasta_file();
   
   if ($chunk->p_cutoff || $chunk->m_cutoff) {
      my @keepers;
      
      foreach my $hit (@{$chunk_keepers}) {
	 if ($hit->strand('query') eq '1' && $hit->start('query') >= $chunk->p_cutoff) {
	    push (@keepers, $hit)
	 }
	 elsif ($hit->strand('query') eq '-1' && $hit->start('query') >= $chunk->m_cutoff) {
	    push (@keepers, $hit)
	 }
      }
      
      return \@keepers;
   }
   else {
      return $chunk_keepers
   }
}

#-----------------------------------------------------------------------------
sub runBlastx {
   my $q_file   = shift;
   my $db       = shift;
   my $out_file = shift;
   my $blastx = shift;
   my $eval_blastx = shift;
   my $cpus = shift;

   my $command  = $blastx;
   $command .= " $db $q_file B=100000 V=100000 E=$eval_blastx";
   $command .= " wordmask=seg";
   #$command .= " T=20";
   #$command .= " W=5";
   #$command .= " wink=5";
   $command .= " Z=300";
   $command .= " Y=500000000";
   $command .= " hspmax=100";
   $command .= " cpus=$cpus";
   $command .= " gspmax=100";
   $command .= " hspsepqmax=10000";
   $command .= " lcfilter";
   $command .= " filter=seg";
   $command .= " gi";
   #$command .= " mformat=2"; # remove for full report
   $command .= " > $out_file";
   my $w = new Widget::blastx();

   if (-e $out_file  && ! $OPT{f}) {
      print STDERR "re reading blast report.\n";
      print STDERR "$out_file\n";
   }
   else {
      print STDERR "running  blast search.\n";
      $w->run($command);
   }
}
#-----------------------------------------------------------------------------
sub repeatmask {
   my $chunk        = shift;
   my $the_void     = shift;
   my $seq_id       = shift;
   my $model_org    = shift;
   my $RepeatMasker = shift;
   my $rmlib        = shift;
   my $cpus         = shift;

   my $chunk_number = $chunk->number();
   my $file_name = "$the_void/$seq_id\.$chunk_number";
   my $o_file    = "$the_void/$seq_id\.$chunk_number\.out";
   my $q_length = $chunk->parent_seq_length();
   my $query_def = $chunk->parent_def();
   my $query_seq = $chunk->seq();

   $LOG->add_entry("STARTED", $o_file, ""); 

   $chunk->write_file($file_name);
		
   runRepeatMasker($file_name, 
		   $model_org, 
		   $the_void, 
		   $o_file,
		   $RepeatMasker,
		   $rmlib,
		   $cpus
		  );		# -no_low

   $LOG->add_entry("FINISHED", $o_file, ""); 
		
   my $rm_chunk_keepers = Widget::RepeatMasker::parse($o_file, 
						      $seq_id, 
						      $q_length,
						      $OPT{f}
						     );
  
   PhatHit_utils::add_offset($rm_chunk_keepers, 
			     $chunk->offset(),
			    );
   #     PhatHit_utils::merge_hits($rm_keepers,  
   # 			      $rm_chunk_keepers, 
   # 			      20,
   # 			     );

   $chunk->erase_fasta_file();
	
   return ($rm_chunk_keepers);
}
#-----------------------------------------------------------------------------
sub runRepeatMasker {
   my $q_file   = shift;
   my $species  = shift;
   my $dir      = shift;
   my $o_file   = shift;
   my $RepeatMasker = shift;
   my $rmlib = shift;
   my $cpus = shift;
   my $no_low   = shift;
	
   my $command  = $RepeatMasker;
    
   if ($rmlib) {
      $command .= " $q_file -lib $rmlib -dir $dir -pa $cpus";    
   } else {
      $command .= " $q_file -species $species -dir $dir -pa $cpus";
   }
   $command .= " -nolow" if defined($no_low);
	
   my $w = new Widget::RepeatMasker();
   if (-e $o_file && ! $OPT{f}) {
      print STDERR "re reading repeat masker report.\n";
      print STDERR "$o_file\n";
   }
   else {
      print STDERR "running  repeat masker.\n";
      $w->run($command);
   }
}

#-----------------------------------------------------------------------------
sub build_the_void {
   my $seq_id  = shift;
   my $out_dir = shift;

   $out_dir =~ s/\/$//;

   my $vid = "theVoid\.$seq_id";   
   my $the_void = "$out_dir/$vid";
   File::Path::mkpath ($the_void);

   return $the_void;
}

#-----------------------------------------------------------------------------
sub load_control_files {
   my @ctlfiles = @_;
   my %CTL_OPTIONS;
   my %OK_FIELDS;

   my @MAKER_OPTS_PARAMS = ('genome',
			    'est',
			    'protein',
			    'repeat_protein',
			    'rmlib',
			    'rm_gff',
			    'predictor',
			    'snaphmm',
			    'augustus_species',
			    'model_org',
			    'max_dna_len',
			    'split_hit',
			    'snap_flank',
			    'te_remove',
			    'single_exon',
			    'use_seq_dir',
			    'clean_up',
			    'cpus',
			    'alt_peptide'
			   );
    
   my @MAKER_BOPTS_PARAMS = ('percov_blastn',
			     'percid_blastn',
			     'eval_blastn',
			     'bit_blastn',
			     'percov_blastx',
			     'percid_blastx',
			     'eval_blastx',
			     'bit_blastx',
			     'e_perc_cov',
			     'ep_score_limit',
			     'en_score_limit'
			    );

   my @MAKER_EXE_PARAMS = ('xdformat',
			   'blastn',
			   'blastx',
			   'snap',
			   'augustus',
			   'RepeatMasker',
			   'exonerate',
			  );


   foreach my $attr (@MAKER_OPTS_PARAMS, @MAKER_BOPTS_PARAMS, @MAKER_EXE_PARAMS) {
      $OK_FIELDS{$attr}++;
   }


   #set default values for certain control options
   $CTL_OPTIONS{'clean_up'} = 0;
   $CTL_OPTIONS{'max_dna_len'} = 100000;
   $CTL_OPTIONS{'percov_blastn'} = 0.80;
   $CTL_OPTIONS{'percid_blastn'} = 0.85;
   $CTL_OPTIONS{'eval_blastn'} = 1e-10;
   $CTL_OPTIONS{'bit_blastn'} = 40;
   $CTL_OPTIONS{'percov_blastx'} = 0.50;
   $CTL_OPTIONS{'percid_blastx'} = 0.40;
   $CTL_OPTIONS{'eval_blastx'} = 1e-6;
   $CTL_OPTIONS{'bit_blastx'} = 30;
   $CTL_OPTIONS{'e_perc_cov'} = 50;
   $CTL_OPTIONS{'alt_peptide'} = 'c';
   $CTL_OPTIONS{'en_score_limit'} = 20;
   $CTL_OPTIONS{'ep_score_limit'} = 20;
   $CTL_OPTIONS{'predictor'} = 'snap';
   
   #load values from control files
   foreach my $ctlfile (@ctlfiles) {
      open (CTL, "< $ctlfile") or die"ERROR: Could not open control file \"$ctlfile\".\n";
	
      while (my $line = <CTL>) {
	 chomp($line);
	    
	 if ($line !~ /^[\#\s\t\n]/ && $line =~ /^([^\:]+)\:([^\s\t\n]+)/) {
	    my $key = $1;
	    my $value = $2;
	    if (exists $OK_FIELDS{$key}) {
	       if ($value =~ /\$/) {
		  $value = `echo $value`;
		  chomp($value);
	       }
	       $CTL_OPTIONS{$key} = $value unless (not defined $value);
	    }
	    else {
	       warn "ERROR: Invalid option \"$key\" in control file $ctlfile\n";
	    }
	 }
      }
   }

   #use command line defined genome
   $CTL_OPTIONS{'genome'} = $OPT{g} if (defined $OPT{g});
    
   #use command line defined predictor
   $CTL_OPTIONS{'predictor'} = $OPT{predictor} if (defined $OPT{predictor});
   die "ERROR: Invalid predictor defined: $CTL_OPTIONS{'predictor'}\n".
   "Must be set to 'snap', 'augustus, or 'es2genome'\n"
   unless ($CTL_OPTIONS{'predictor'} =~ /snap|augustus|est2genome/);

   #validate required values from control files
   my @infiles = ('genome', 'protein', 'est', 'xdformat', 'blastn',
		  'blastx', 'exonerate', 'snap'
		 );

   #sometimes required
   push (@infiles, 'repeat_protein') if ($CTL_OPTIONS{te_remove});
   push (@infiles, 'RepeatMasker') unless($OPT{R} || $OPT{GFF});
   push (@infiles, 'rm_gff') if ($OPT{GFF});
   push (@infiles, 'augustus') if ($CTL_OPTIONS{predictor} eq 'augustus' || $CTL_OPTIONS{'augustus'});

   my $error;

   foreach my $in (@infiles) {
      if (not $CTL_OPTIONS{$in}) {
	 $error .= "You have failed to provide a value for \'$in\' in the control files\n";
	 next;
      }

      if (not -e $CTL_OPTIONS{$in}) {
	 $error .= "The \'$in\' file $CTL_OPTIONS{$in} does not exist.\n".
	 "Please check your control files: maker_opts.ctl, maker_bopts, or maker_exe.ctl\n";
	 next;
      }

      #set the absolute path to the file to reduce ambiguity
      #$CTL_OPTIONS{$in} = Cwd::abs_path($CTL_OPTIONS{$in});
   }

   die $error if (defined $error);

   if (! $OPT{R} && ! $CTL_OPTIONS{'model_org'}) {
      warn "There is no model specified for RepeatMasker in maker_opts.ctl : model_org.\n".
      "As a result the default (drosophila) will be used.\n";
      $CTL_OPTIONS{'model_org'} = "drosophila";
   }
   if ( ($CTL_OPTIONS{'predictor'} eq 'augustus' || $CTL_OPTIONS{'augustus'}) &&
	not $CTL_OPTIONS{'augustus_species'}
      ) {
      warn "There is no species specified for Augustus in maker_opts.ctl : augustus_species.\n".
      "As a result the default (fly) will be used.\n";
      $CTL_OPTIONS{'augustus_species'} = "fly";
   }
   if (not $CTL_OPTIONS{'snaphmm'}) {
      warn "There is no model specified for for Snap in maker_opts.ctl : snaphmm.\n".
      "As a result, the default (fly) will be used.\n";
      $CTL_OPTIONS{'snaphmm'} = "fly";
   }
   if (! -e $CTL_OPTIONS{'snaphmm'} &&
       (! exists $ENV{'ZOE'} || ! -e $ENV{'ZOE'}."/".$CTL_OPTIONS{'snaphmm'})
      ) {
      
      die "ERROR: The snaphmm specified for Snap in maker_opts.ctl does not exist.\n";
   }
   if ($CTL_OPTIONS{'max_dna_len'} < 50000) {
      warn "ERROR: max_dna_len is set too low.  The minimum value permited is 50,000\n".
      "max_dna_len wil be reset to 50,000\n\n";
      $CTL_OPTIONS{'max_dna_len'} = 50000;
   }

   #set values for datastructure    
   $CTL_OPTIONS{'genome'} =~ /([^\/]+)$/;
   $CTL_OPTIONS{'out_name'} = $1;
   $CTL_OPTIONS{'out_name'} =~ s/\.[^\.]+$//;
   $CTL_OPTIONS{'out_base'} = Cwd::cwd();

   if ($CTL_OPTIONS{'use_seq_dir'}) {
      my @file_struct = split(/\//, $CTL_OPTIONS{'genome'});
      pop @file_struct;
      $CTL_OPTIONS{'out_base'} = join("/", @file_struct);
   }
    
   if (not $CTL_OPTIONS{'out_base'}) {
      die "No working directory, check your use_seq_dir option\n";
   }

   return %CTL_OPTIONS;
}

#-----------------------------------------------------------------------------
sub generate_control_files {
   #--build maker_opts.ctl file
   my $repeat_protein = Cwd::abs_path("$FindBin::Bin/../data/te_proteins.fasta");

   open (OUT, "> maker_opts.ctl");
   print OUT "#-----sequence and library files\n";
   print OUT "genome: #genome sequence file (required)\n";
   print OUT "est: #EST sequence file (required)\n";
   print OUT "protein:  #protein sequence file (required)\n";
   print OUT "repeat_protein:$repeat_protein #a database of transposable element proteins\n";
   print OUT "rmlib: #an organism specific repeat library (optional)\n";
   print OUT "rm_gff: #a gff3 format file of repeat elements (only used with -GFF flag)\n";
   print OUT "\n";
   print OUT "#-----external application specific options\n";
   print OUT "snaphmm:fly #SNAP HMM model\n";
   print OUT "augustus_species:fly #Augustus gene prediction model\n";
   print OUT "model_org:all #RepeatMasker model organism\n";
   print OUT "alt_peptide:c #amino acid used to replace non standard amino acids in xdformat\n";
   print OUT "cpus:2 #max number of cpus to use in BLAST and RepeatMasker\n";
   print OUT "\n";
   print OUT "#-----Maker specific options\n";
   print OUT "predictor:snap #identifies which gene prediction program to use for annotations\n";
   print OUT "te_remove:1 #mask regions with excess similarity to transposable element proteins\n";
   print OUT "max_dna_len:100000 #length for dividing up contigs into chunks (larger values increase memory usage)\n";
   print OUT "split_hit:10000 #length of the splitting of hits (max intron size for EST and protein alignments)\n";
   print OUT "snap_flank:200 #length of sequence surrounding EST and protein evidence used to extend gene predictions\n";
   print OUT "single_exon:0 #consider EST hits aligning to single exons when generating annotations, 1 = yes, 0 = no\n";
   print OUT "use_seq_dir:1 #place output files in same directory as sequence file: 1 = yes, 0 = no\n";
   print OUT "clean_up:0 #remove theVoid directory: 1 = yes, 0 = no\n";
   close (OUT);

   #--build maker_bopts.ctl file
   open (OUT, "> maker_bopts.ctl");
   print OUT "#-----BLAST and Exonerate statistics thresholds\n";
   print OUT "percov_blastn:0.80 #Blastn Percent Coverage Threhold EST-Genome Alignments\n";
   print OUT "percid_blastn:0.85 #Blastn Percent Identity Threshold EST-Genome Aligments\n";
   print OUT "eval_blastn:1e-10 #Blastn eval cutoff\n";
   print OUT "bit_blastn:40 #Blastn bit cutoff\n";
   print OUT "percov_blastx:0.50 #Blastx Percent Coverage Threhold Protein-Genome Alignments\n";
   print OUT "percid_blastx:0.40 #Blastx Percent Identity Threshold Protein-Genome Aligments\n";
   print OUT "eval_blastx:1e-6 #Blastx eval cutoff\n";
   print OUT "bit_blastx:30 #Blastx bit cutoff\n";
   print OUT "e_perc_cov:50 #Exonerate Percent Coverage Thresshold EST_Genome Alignments\n";
   print OUT "ep_score_limit:20 #Report  alignments scoring at least this percentage of the maximal score exonerate nucleotide\n";
   print OUT "en_score_limit:20 #Report  alignments scoring at least this percentage of the maximal score exonerate protein\n";
   close(OUT);

   #--build maker_exe.ctl file
   my %executables = ( xdformat => '',
		       blastn => '',
		       blastx => '',
		       snap => '',
		       augustus => '',
		       exonerate => '',
		       RepeatMasker => '',
		       exonerate => ''
		     );

   while (my $exe = each %executables) {
      my $loc = `which $exe`;
      chomp $loc;
      $executables{$exe} = $loc unless ($loc =~ /^no $exe/);
   }

   open (OUT, "> maker_exe.ctl");
   print OUT "#-----Location of executables required by Maker\n";
   print OUT "xdformat:".$executables{xdformat}." #location of xdformat executable\n";
   print OUT "blastn:".$executables{blastn}." #location of blastn executable\n";
   print OUT "blastx:".$executables{blastx}." #location of blastn executable\n";
   print OUT "snap:".$executables{snap}." #location of snap executable\n";
   print OUT "augustus:".$executables{augustus}." #location of augustus executable (optional)\n";
   print OUT "RepeatMasker:".$executables{RepeatMasker}." #location of RepeatMasker executable\n";
   print OUT "exonerate:".$executables{exonerate}." #location of exonerate executable\n";
   close(OUT);
}
