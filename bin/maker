#! /usr/bin/perl -w

use strict "vars";
use strict "refs";

use FindBin;
use lib "$FindBin::Bin/../lib";

BEGIN{
   $ENV{CGL_SO_SOURCE} = "$FindBin::Bin/../lib/CGL/so.obo" if not ($ENV{CGL_SO_SOURCE});
   $ENV{CGL_GO_SOURCE} = "$FindBin::Bin/../lib/CGL/gene_ontology.obo" if not ($ENV{CGL_GO_SOURCE});
}

use Dumper::GFF::GFFV3;
use Dumper::XML::Game;
use Datastore::MD5;
use URI::Escape;
use Storable;
use File::Path;
use Data::Dumper;
use Getopt::Long;
use FileHandle;
use PostData;
use Cwd qw(cwd abs_path);
use Fasta;
use Iterator::Fasta;
use FastaChunker;
use Widget::RepeatMasker;
use Widget::blastx;
use Widget::tblastx;
use Widget::blastn;
use Widget::snap; 
use Widget::augustus;
use PhatHit_utils;
use Shadower;
use Bio::DB::Fasta;
use polisher::exonerate::protein;
use polisher::exonerate::est;
use maker::auto_annotator;
use cluster;
use repeat_mask_seq;
use maker::sens_spec;

$|  = 1;

#--delete these later
my $masked_fasta;
#--

my $usage = "
Usage:

        maker [options] <maker_opts.ctl> <maker_bopts.ctl> <maker_exe.ctl>

        The three input arguments are user control files that specify how maker should behave.
        All input files listed in the control options files must be in fasta format.  Please
        see maker documentation to learn more about control file format.  The program will
        automatically try and locate the user control files in the current working
        directory if these arguments are not supplied when initializing maker.

        It is important to note that maker does not try and recalculated data that it has
        already calculated.  For example, if you run an analysis twice on the same fasta file
        you will notice that maker does not rerun any of the blast analyses but instead uses
        the blast analyses stored from the previous run.  To force maker to rerun all
        analyses, use the -f flag.

Options:

     -genome|g  <file_name>   Give MAKER a different genome file (this overrides the
                              control file value)

     -predictor <snap>        Selects the gene predictor to use when building annotations (Default
                <augustus>    is 'snap').  The option 'est2genome' builds annotations directly
                <est2genome>  from the EST evidence.

     -GFF                     Use an input gff3 format file of repeat elements for repeat masking.
                              You must set rm_gff in maker_opts.ctl to the files location.  This
                              option turns off all other repeat masking.

     -RM_off|R                Turns repeat masking off (* See Warning)

     -force|f                 Forces maker to rerun all analyses (replaces all previous output).

     -datastore|d             Causes output to be written using datastore.  This option is
                              automatically enabled if there are more than 1000 fasta entries
                              in the input file.  Output can then accessed using the
                              master_datastore_index file created by the program.

     -PREDS                   Outputs ab-initio predictions that do not overlap maker annotation
                              as gene annotations in the final gff3 output file (based on the
                              -predictor flag ).

     -CTL                     Generates generic control files in the current working directory.

     -cpus|c    <integer>     Tells how many cpus to use for Blast analysis (this overrides
                              contorol file value).

     -help|?                  Prints this usage statement.


Warning:
      
        *When using the -R flag, maker expects that the input genome file is already masked.
         Also if your genome file contains lower case characters, maker will consider those
         characers to be soft masked.

";

my %OPT;

GetOptions("RM_off|R" => \$OPT{R},
	   "force|f" => \$OPT{f},
	   "datastore|d" => \$OPT{d},
	   "genome|g=s" => \$OPT{g},
	   "cpus|c=i" => \$OPT{c},
	   "GFF"=> \$OPT{GFF},
	   "PREDS" => \$OPT{SNAPS},
	   "predictor=s" =>\$OPT{predictor},
	   "CTL" => sub {generate_control_files(); exit;},
	   "help|?" => sub {die $usage;},
	  );

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

#---get arguments off the command line
my $infile;

my @ctlfiles = @ARGV;

if (not @ctlfiles) {
   if (-e "maker_opts.ctl" && -e "maker_bopts.ctl" && -e "maker_exe.ctl") {
      @ctlfiles = ("maker_opts.ctl","maker_bopts.ctl","maker_exe.ctl");
   }
   else {
      die $usage;
   }
}

#---set up control options from control files
my %CTL_OPTIONS = load_control_files(@ctlfiles);

#---load genome fasta file
my $fasta_iterator = new Iterator::Fasta($CTL_OPTIONS{'genome'});

if ($fasta_iterator->number_of_entries() == 0) {
   die "ERROR:  The genome file $CTL_OPTIONS{'genome'} contains no fasta sequences\n";
}

#---decide whether to use datastore 
if ($fasta_iterator->number_of_entries() > 1000) {
   print STDERR "\n\n".
   "WARNING:  There are more than 1000 entries in the multi-fasta file.\n".
   "Datastore will be used to avoid overloading the data structure of\n".
   "the output directory.\n\n";

   $OPT{d} = 1;
}

if ($OPT{d}) {
   %CTL_OPTIONS = build_datastore(\%CTL_OPTIONS); #alter control options to use datastore
}

#---set up blast databases for analyisis
create_blastdb(\%CTL_OPTIONS);

#---iterate over each sequence in the fasta
while (my $fasta     = $fasta_iterator->nextEntry()) {

   my $query_def = Fasta::getDef($fasta);  #Get fasta header
   my $query_seq = Fasta::getSeq($fasta);  #Get fasta sequence
   my ($seq_id)  = $query_def =~ /^>(\S+)/; #Get sequence identifier off of fasta header
   
   #-build a safe name for file names from the sequence identifier
   my $seq_out_name = uri_escape($seq_id,  
				 '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
				);

   #-set up void directory where analysis is stored
   my $out_dir = $CTL_OPTIONS{'out_base'};

   if ($OPT{d}) {
      $out_dir = $CTL_OPTIONS{'datastore'}->id_to_dir($seq_out_name);
      $CTL_OPTIONS{'datastore'}->mkdir($seq_out_name) || die "ERROR: could not make directory $out_dir\n";
      my $fh = $CTL_OPTIONS{'fh_dsindex'};
      print $fh "$seq_id\t$out_dir\n";
   }

   my $the_void  = build_the_void($seq_out_name, $out_dir);

   #==from here on fastas are proccessed as chunks

   #-set up variables that are heldover from last chunk
   my $holdover_chunk;

   #-set up variables that are the result of chunk accumulation
   my $masked_total_seq;
   my $p_fastas;
   my $t_fastas;
   my $p_snap_fastas;
   my $t_snap_fastas;
   my $p_augus_fastas;
   my $t_augus_fastas;

   my $GFF3 = new Dumper::GFF::GFFV3();
   $GFF3->seq($query_seq);
   $GFF3->seq_id($seq_id);

   #==REPEAT MASKING HERE
   if($OPT{R}){
      print STDERR "Repeatmasking skipped!!\n";
      $masked_total_seq = $$query_seq;
   }
   elsif($OPT{GFF}){
      $masked_total_seq = repeat_mask_seq::gff(uc($$query_seq), 
					       $seq_id,
					       $CTL_OPTIONS{'rm_gff'}
					      );
   }
   else{
      my $fasta_chunker = new FastaChunker();
      $fasta_chunker->parent_fasta($fasta);
      $fasta_chunker->chunk_size($CTL_OPTIONS{'max_dna_len'});
      $fasta_chunker->min_size($CTL_OPTIONS{'split_hit'});
      $fasta_chunker->load_chunks();
      
      my $chunk_count = 0;
      
      while (my $chunk = $fasta_chunker->get_chunk($chunk_count++)) {	 
	 $chunk->seq(uc($chunk->seq())); #must be upper case before soft masking
	 
	 #-get repeatmask hits
	 my ($rma_keepers) = repeatmask($chunk, 
					$the_void,
					$seq_out_name,
					$CTL_OPTIONS{'model_org'},
					$CTL_OPTIONS{'RepeatMasker'},
					$CTL_OPTIONS{'rmlib'},
					$CTL_OPTIONS{'cpus'}
				       );
	 
	 #-mask the chunk using repeatmasker hits
	 $chunk = repeat_mask_seq::mask_chunk($chunk, $rma_keepers);
	 
	 #-blastx against a repeat library (for better masking)
	 my $repeat_blastx_keepers = blastx($chunk,
					    $CTL_OPTIONS{'repeat_protein'},
					    $the_void,
					    $seq_out_name,
					    $CTL_OPTIONS{blastx},
					    $CTL_OPTIONS{eval_blastx},
					    $CTL_OPTIONS{bit_blastx},
					    $CTL_OPTIONS{percov_blastx},
					    $CTL_OPTIONS{percid_blastx},
					    $CTL_OPTIONS{split_hit},
					    $CTL_OPTIONS{cpus}
					   );
	 
	 #-mask the chunk using blastx hits
	 $chunk = repeat_mask_seq::mask_chunk($chunk, $repeat_blastx_keepers);
	 
	 #-combine and cluster blastx and repeatmasker hits
	 #-to get consensus repeat hits for gff3 and XML annotations
	 my $rm_keepers = repeat_mask_seq::process($rma_keepers, 
						   $repeat_blastx_keepers,
						   $query_seq
						  );
	 
	 #-add repeats to GFF3
	 $GFF3->repeat_hits($rm_keepers);
	 
	 #-build/fill big masked sequence
	 $masked_total_seq .= $chunk->seq();
      }
   }
   
   $masked_fasta = Fasta::toFasta($query_def.' masked', \$masked_total_seq);
   FastaFile::writeFile($masked_fasta ,$the_void."/query.masked.fasta");

   #==SNAP ab initio here
   my $snaps = snap($masked_fasta,
		    $the_void,
		    $seq_out_name,
		    $CTL_OPTIONS{snap},
		    $CTL_OPTIONS{'snaphmm'}
		   );

   #==AUGUSTUS ab initio here
   my $augus = [];
   $augus = augustus($masked_fasta,
		     $the_void,
		     $seq_out_name,
		     $CTL_OPTIONS{'augustus'},
		     $CTL_OPTIONS{'augustus_species'}
		    ) if ($CTL_OPTIONS{'augustus'});

   #--build an index of the databases
   my $proteins = $CTL_OPTIONS{'protein'};
   my $transcripts = $CTL_OPTIONS{'est'};
   my $fasta_p_index     = build_fasta_index($proteins);
   my $fasta_t_index     = build_fasta_index($transcripts);
   
   #--run blast analysis in chunks
   my $fasta_chunker = new FastaChunker();
   $fasta_chunker = new FastaChunker();
   $fasta_chunker->parent_fasta($$masked_fasta);
   $fasta_chunker->chunk_size($CTL_OPTIONS{'max_dna_len'});
   $fasta_chunker->min_size($CTL_OPTIONS{'split_hit'});
   $fasta_chunker->load_chunks();

   my $chunk_count = 0;

   while (my $chunk = $fasta_chunker->get_chunk($chunk_count++)) {
      #==BLAST ANALYSIS HERE
      
      #-merge heldover chunk sequence from last round
      unless($chunk->number == 0){
	 $chunk = merge_chunks($holdover_chunk, $chunk);
      }

      #-blastn search the file against ESTs
      my $blastn_keepers = blastn($chunk,
				  $transcripts,
				  $the_void,
				  $seq_out_name,
				  $CTL_OPTIONS{blastn},
				  $CTL_OPTIONS{eval_blastn},
				  $CTL_OPTIONS{bit_blastn},
				  $CTL_OPTIONS{percov_blastn},
				  $CTL_OPTIONS{percid_blastn},
				  $CTL_OPTIONS{split_hit},
				  $CTL_OPTIONS{cpus}
				 );

      #-blastx search the masked input file
      my $blastx_keepers = blastx($chunk, 
				  $proteins,
				  $the_void,
				  $seq_out_name,
				  $CTL_OPTIONS{blastx},
				  $CTL_OPTIONS{eval_blastx},
				  $CTL_OPTIONS{bit_blastx},
				  $CTL_OPTIONS{percov_blastx},
				  $CTL_OPTIONS{percid_blastx},
				  $CTL_OPTIONS{split_hit},
				  $CTL_OPTIONS{cpus}
				 );

      #==get just the snaps that overlap this chunk
      my $snaps_on_chunk = get_snaps_on_chunk($snaps,
					      $chunk
					     );

      #==get just the augustus that overlap this chunk
      my $augus_on_chunk = get_snaps_on_chunk($augus,
                                              $chunk
                                             );

      #==PROCESS HITS CLOSE TOO CHUNK DIVISIONS
      if(not $chunk->is_last){ #if not last chunk
	 ($holdover_chunk,
	  $blastx_keepers,
	  $blastn_keepers,
	  $snaps_on_chunk,
	  $augus_on_chunk) = process_the_chunk_divide($chunk,
						      $CTL_OPTIONS{'split_hit'},
						      $blastx_keepers,
						      $blastn_keepers,
						      $snaps_on_chunk,
						      $augus_on_chunk,
						     );
      }

      #==EXONERATE HERE
          
      #-cluster the blastx hits
      print STDERR "cleaning blastx...\n";
      
      my $blastx_clusters = cluster::clean_and_cluster($blastx_keepers,
						       $query_seq,
						       10);

      undef $blastx_keepers;
      
      #-make a multi-fasta of the seqs in the blastx_clusters 
      #-polish the blastx hits with exonerate
      
      my $exonerate_p_clusters = polish_exonerate($fasta,
						  $blastx_clusters,
						  $fasta_p_index,
						  $the_void,
						  5,
						  'p',
						  $CTL_OPTIONS{exonerate},
						  $CTL_OPTIONS{percov_blastx},
						  $CTL_OPTIONS{percid_blastx},
						  $CTL_OPTIONS{ep_score_limit},
						  $CTL_OPTIONS{ep_matrix}
						 );

      #-cluster the blastn hits
      print STDERR "cleaning blastn...\n";
      my $blastn_clusters = cluster::clean_and_cluster($blastn_keepers,
						       $query_seq,
						       10
						      );

      undef $blastn_keepers;
      
      #-polish blastn hits with exonerate
      my $exonerate_e_clusters = polish_exonerate($fasta,
						  $blastn_clusters,
						  $fasta_t_index,
						  $the_void,
						  5,
						  'e',
						  $CTL_OPTIONS{exonerate},
						  $CTL_OPTIONS{percov_blastn},
						  $CTL_OPTIONS{percid_blastn},
						  $CTL_OPTIONS{en_score_limit},
						  $CTL_OPTIONS{en_matrix}
						 ); 


      #####working here###########

      #==MAKER annotations built here

      my $blastx_data      = flatten($blastx_clusters);
      my $blastn_data      = flatten($blastn_clusters);
      my $exonerate_p_data = flatten($exonerate_p_clusters, 'exonerate:p');
      my $exonerate_e_data = flatten($exonerate_e_clusters, 'exonerate:e');
      
      #-- decide which gene finder to use to build annotations 
      my $pred_command;
      my $preds_on_chunk;
      if ($CTL_OPTIONS{predictor} eq 'augustus'){
	 $pred_command = $CTL_OPTIONS{augustus} .' --species='.$CTL_OPTIONS{augustus_species};
	 $preds_on_chunk = $augus_on_chunk;
      }
      elsif ($CTL_OPTIONS{predictor} eq 'snap'){
	 $pred_command = $CTL_OPTIONS{snap}.' '.$CTL_OPTIONS{snaphmm};
	 $preds_on_chunk = $snaps_on_chunk;
      }
      elsif($CTL_OPTIONS{predictor} eq 'est2genome'){
	 $pred_command = '';
	 $preds_on_chunk = [];
      }
      else{
	 die "ERROR: invalid predictor type: $CTL_OPTIONS{predictor}\n";
      }
      #-auto-annotate the input file
      
      my $annotations = maker::auto_annotator::annotate($fasta,
							$$masked_fasta,
							$chunk->number(),
							$exonerate_p_data,
							$exonerate_e_data,
							$blastx_data,
							$preds_on_chunk,
							$the_void,
							$pred_command,
							$CTL_OPTIONS{snap_flank},
							$CTL_OPTIONS{'single_exon'},
							$OPT{f},
							$OPT{SNAPS},
							$CTL_OPTIONS{predictor},
						       );

      #==OUTPUT DATA HERE
      
      #--- GFF3      
      $GFF3->genes($annotations);
      $GFF3->predictions($snaps_on_chunk);
      $GFF3->predictions($augus_on_chunk);
      $GFF3->phat_hits($blastx_data);
      $GFF3->phat_hits($blastn_data);
      $GFF3->phat_hits($exonerate_p_data);
      $GFF3->phat_hits($exonerate_e_data);

      #--- GAME XML

      #my $IOX= new Dumper::XML::Game->init(FastaFile=>$CTL_OPTIONS{'genome'},
      #                                     WriteFile=>$out_dir."/".$seq_out_name.".xml"
      #                                    );
      #$IOX->add_hits($rm_keepers);
      #$IOX->add_hits($blastx_keepers);
      #$IOX->add_hits($blastn_keepers);
      #foreach my $pp (@$exonerate_p_clusters) {
      #   $IOX->add_hits($pp);
      #}
      #foreach my $ee (@$exonerate_e_clusters) {
      #   $IOX->add_hits($ee);
      #}      
      #$IOX->add_hits($snaps);
            
      #---adding auto annotations

      #my @quality_indices;
      #foreach my $an (@$annotations) {
      #   my $g_name     = $an->{g_name};
      #   my $g_s        = $an->{g_start};
      #   my $g_e        = $an->{g_end};
      #   my $g_strand   = $an->{g_strand};
      #
      #   my @temp_ant;
      #   foreach my $a (@{$an->{t_structs}}) {
      #       push(@quality_indices, [$a->{t_name}, $a->{t_qi}]);
      #
      #       my ($p_fasta, $t_fasta) = get_p_and_t_fastas($a);
      #
      #       $t_fastas .= $$t_fasta;
      #       $p_fastas .= $$p_fasta;
      #
      #       push (@temp_ant,$a) if defined($a->{hit});
      #       $IOX->add_autoant($a) if defined($a->{hit});
      #   }
      #}
      #Write the quality index of the mRNAs to a separate file.
      #write_quality_data(\@quality_indices, $seq_id);
      #
      #   $IOX->Game();


      #--- building fastas
      my ($p_fasta, $t_fasta) = get_maker_p_and_t_fastas($annotations);
      $p_fastas .= $p_fasta;
      $t_fastas .= $t_fasta;
   
      my ($p_snap_fasta, $t_snap_fasta) = get_snap_p_and_t_fastas($query_seq, $snaps_on_chunk);
      $p_snap_fastas .= $p_snap_fasta;
      $t_snap_fastas .= $t_snap_fasta;

      my ($p_augus_fasta, $t_augus_fasta) = get_snap_p_and_t_fastas($query_seq, $augus_on_chunk);
      $p_augus_fastas .= $p_augus_fasta;
      $t_augus_fastas .= $t_augus_fasta;

   }

   #--Write fasta files and gff3 files now that all chunks are finished
   FastaFile::writeFile(\$p_fastas ,"$out_dir\/$seq_out_name\.maker.proteins.fasta");
   FastaFile::writeFile(\$t_fastas ,"$out_dir\/$seq_out_name\.maker.transcripts.fasta");
   FastaFile::writeFile(\$p_snap_fastas ,"$out_dir\/$seq_out_name\.maker.snap.proteins.fasta");
   FastaFile::writeFile(\$t_snap_fastas ,"$out_dir\/$seq_out_name\.maker.snap.transcript.fasta");
   if($CTL_OPTIONS{'augustus'}){
      FastaFile::writeFile(\$p_augus_fastas ,"$out_dir\/$seq_out_name\.maker.augus.proteins.fasta");
      FastaFile::writeFile(\$t_augus_fastas ,"$out_dir\/$seq_out_name\.maker.augus.transcript.fasta");
   }
   $GFF3->print($out_dir."/".$seq_out_name.".gff");

   #--cleanup maker files created with each fasta sequence
   rmtree ($the_void) if $CTL_OPTIONS{clean_up}; #rm temp directory
}

exit(0);

#-----------------------------------------------------------------------------
#----------------------------------- SUBS ------------------------------------
#-----------------------------------------------------------------------------
sub get_snaps_on_chunk {
   my $snaps = shift;
   my $chunk = shift;

   my $c_pstart = $chunk->offset + 1;
   my $c_pend = $chunk->offset + $chunk->length;
   
   my $c_mstart = $chunk->offset + 1;
   my $c_mend = $chunk->offset + $chunk->length;

   if($chunk->p_cutoff || $chunk->m_cutoff){
      $c_pstart = $chunk->p_cutoff;
      $c_pend = $chunk->p_cutoff + $chunk->length - 1;
      
      $c_mstart = $chunk->m_cutoff;
      $c_mend = $chunk->m_cutoff + $chunk->length - 1;
   }

   my @keepers;
   foreach my $snap (@{$snaps}){
      my $s_start = $snap->start('query');

      if ($snap->strand('query') eq '1' && $c_pstart <= $s_start && $s_start <= $c_pend){
	 push (@keepers, $snap);
      }
      elsif ($snap->strand('query') eq '-1' && $c_mstart <= $s_start && $s_start <= $c_mend){
	 push (@keepers, $snap);
      }
   }

   return \@keepers;
}
#-----------------------------------------------------------------------------
sub get_maker_p_and_t_fastas {
   my $annotations = shift @_;
   
   my $p_fastas = '';
   my $t_fastas = '';
   
   foreach my $an (@$annotations) {
      foreach my $a (@{$an->{t_structs}}) {
	 my ($p_fasta, $t_fasta) = get_p_and_t_fastas($a);
	 $p_fastas .= $$p_fasta;
	 $t_fastas .= $$t_fasta;
      }
   }
   
   return $p_fastas, $t_fastas;
}
#-----------------------------------------------------------------------------
sub merge_chunks{
   my $chunk1 = shift @_;
   my $chunk2 = shift @_;

   if (ref($chunk1) eq 'FastaChunk' && ref($chunk2) ne 'FastaChunk'){
      return $chunk1;
   }
   elsif(ref($chunk2) eq 'FastaChunk' && ref($chunk1) ne 'FastaChunk'){
      die "ERROR: The second argument to main::merge_chunks\n".
          "must be a FastaChunk object";
   }
   elsif ($chunk1->length == 0 ){
      return $chunk2;
   }

   #chunks must be flush to each other and given in order
   die "ERROR: Can not merge chunks at main::mergechunks\n"
      if ($chunk1->offset > $chunk2->offset);
   
   $chunk2->seq($chunk1->seq . $chunk2->seq);
   $chunk2->length($chunk1->length + $chunk2->length);
   $chunk2->offset($chunk1->offset);
   $chunk2->p_cutoff($chunk1->p_cutoff);
   $chunk2->m_cutoff($chunk1->m_cutoff);

   return $chunk2;
}

#-----------------------------------------------------------------------------
sub process_the_chunk_divide{
   my $chunk = shift @_;
   my $split_hit = shift @_;
   my $hit_groups = \@_;

   my $phat_hits;

   foreach my $group (@{$hit_groups}){
      push(@{$phat_hits}, @{$group});
   }

   my ($p_hits, $m_hits) = PhatHit_utils::seperate_by_strand('query', $phat_hits);
   my $p_coors  = PhatHit_utils::to_begin_and_end_coors($p_hits, 'query');
   my $m_coors  = PhatHit_utils::to_begin_and_end_coors($m_hits, 'query');

   foreach my $p_coor (@{$p_coors}){
      $p_coor->[0] -= $chunk->offset();
      $p_coor->[1] -= $chunk->offset();
      $p_coor->[0] = $chunk->length if($p_coor->[0] > $chunk->length);
      $p_coor->[1] = $chunk->length if($p_coor->[1] > $chunk->length);
   }
   foreach my $m_coor (@{$m_coors}){
      $m_coor->[0] -= $chunk->offset();
      $m_coor->[1] -= $chunk->offset();
      $m_coor->[0] = $chunk->length if($m_coor->[0] > $chunk->length);
      $m_coor->[1] = $chunk->length if($m_coor->[1] > $chunk->length);
   }

   my $p_pieces = Shadower::getPieces(\($chunk->seq), $p_coors, 10);
      $p_pieces = [sort {$b->{e} <=> $a->{e}} @{$p_pieces}];
   my $m_pieces = Shadower::getPieces(\($chunk->seq), $m_coors, 10);
      $m_pieces = [sort {$b->{e} <=> $a->{e}} @{$m_pieces}];

   my @keepers;
   my $cutoff = $chunk->length + $chunk->offset - $CTL_OPTIONS{'split_hit'};
   my $p_cutoff = $chunk->length + $chunk->offset + 1;
   my $m_cutoff = $chunk->length + $chunk->offset + 1;

   foreach my $p_piece (@{$p_pieces}){
      if ($p_piece->{e} + $chunk->offset >= $cutoff){
	 $p_cutoff = $p_piece->{b} + $chunk->offset;
      }
   }
   foreach my $m_piece (@{$m_pieces}){
      if ($m_piece->{e} + $chunk->offset >= $cutoff){
	 $m_cutoff = $m_piece->{b} + $chunk->offset;
      }
   }

   if ($p_cutoff <= 1 && $m_cutoff <= 1){  #too small, all are heldover for next round
      return $chunk, @keepers;
   }

   foreach my $group (@{$hit_groups}){
      my $group_keepers = [];

      foreach my $hit (@{$group}){
	 my $b = $hit->nB('query');
	 my $e = $hit->nE('query');
	 my $strand = $hit->strand;

	 ($b, $e) = ($e, $b) if $b > $e;
	 
	 if (($e < $p_cutoff && $strand eq '1') ||
	     ($e < $m_cutoff && $strand eq '-1')
	    ){
	       push(@{$group_keepers}, $hit);
	 }
      }

      push(@keepers, $group_keepers);
   }

   my $abs_cutoff = ($p_cutoff < $m_cutoff) ? $p_cutoff -200 : $m_cutoff -200;
   my $sub_strt = $abs_cutoff - $chunk->offset - 1;
      $sub_strt = 0 if($sub_strt < 0);

   my $new_chunk = Storable::dclone($chunk); 
      $new_chunk->p_cutoff($p_cutoff);
      $new_chunk->m_cutoff($m_cutoff);
      $new_chunk->length($chunk->length - ($abs_cutoff - $chunk->offset - 1));
      $new_chunk->offset($abs_cutoff - 1);
      $new_chunk->seq(substr($new_chunk->seq,
			     $sub_strt,
			     $new_chunk->length
			    )
		     );

   return $new_chunk, @keepers;
}
#-----------------------------------------------------------------------------
sub build_datastore {
   my %CTL_OPTIONS = %{shift @_};

   $CTL_OPTIONS{'dsroot'} = "$CTL_OPTIONS{'out_base'}/$CTL_OPTIONS{'out_name'}_datastore";
   $CTL_OPTIONS{'dsindex'} = "$CTL_OPTIONS{'out_base'}/$CTL_OPTIONS{'out_name'}_master_datastore.index";

   print STDERR "A data structure will be created for you at:\n".
                "$CTL_OPTIONS{'dsroot'}\n\n".
                "To access files for individual sequences use the datastore index:\n".
                "$CTL_OPTIONS{'dsindex'}\n\n";
    
   $CTL_OPTIONS{'datastore'} = new Datastore::MD5('root' => $CTL_OPTIONS{'dsroot'}, 'depth' => 2);
   $CTL_OPTIONS{'fh_dsindex'} = new FileHandle();
   $CTL_OPTIONS{'fh_dsindex'}->open("> $CTL_OPTIONS{'dsindex'}");
   $CTL_OPTIONS{'fh_dsindex'}->autoflush(1);

   return %CTL_OPTIONS;
}
#-----------------------------------------------------------------------------
sub write_quality_data {
   my $quality_indices = shift;
   my $seq_id          = shift;

   my $out_file = $seq_id.'.maker.transcripts.qi';
   my $fh = new FileHandle();
   $fh->open(">$out_file");

   print $fh "genomic_seq\ttranscript\tquality_index\n";

   while (my $d = shift(@{$quality_indices})) {
      my $t_name = $d->[0];
      my $t_qi   = $d->[1];
	
      print $fh "$seq_id\t$t_name\t$t_qi\n";
   }
   $fh->close();
}
#-----------------------------------------------------------------------------
sub get_snap_p_and_t_fastas {
   my $seq   = shift;
   my $snaps = shift;
	
   my $p_fastas = '';
   my $t_fastas = '';
   foreach my $hit (@{$snaps}) {
      my $t_name = $hit->name(); # note this is being set in GFFV3::pred_data
      my $t_seq  = maker::auto_annotator::get_transcript_seq($hit, $seq);	
		
      my ($p_seq, $offset, $end) = 
      maker::auto_annotator::get_translation_seq($t_seq);
		
      my $score = 0;
      foreach my $hsp ($hit->hsps) {
	 $score += $hsp->score();
      }
		
      my $p_def = '>'.$t_name.' protein score:'.$score;
      my $t_def = '>'.$t_name.' snap.transcript offset:'.$offset;
      $t_def.= ' score:'.$score; 
		
      my $p_fasta = Fasta::toFasta($p_def, \$p_seq);
      my $t_fasta = Fasta::toFasta($t_def, \$t_seq);
		
      $p_fastas .= $$p_fasta;
      $t_fastas .= $$t_fasta;
		
   }
   return ($p_fastas, $t_fastas);
}
#-----------------------------------------------------------------------------
sub get_p_and_t_fastas {
   my $t_struct = shift;
	
   my $t_seq  = $t_struct->{t_seq};
   my $p_seq  = $t_struct->{p_seq};
   my $t_off  = $t_struct->{t_offset};
   my $t_name = $t_struct->{t_name};
	
   my $p_def = '>'.$t_name.' protein'; 
   my $t_def = '>'.$t_name.' transcript offset:'.$t_off;
	
   my $p_fasta = Fasta::toFasta($p_def, \$p_seq);
   my $t_fasta = Fasta::toFasta($t_def, \$t_seq);
	
   return($p_fasta, $t_fasta);
}
#----------------------------------------------------------------------------
sub create_blastdb {
   my %CTL_OPTIONS = %{shift @_};

   unless (-e $CTL_OPTIONS{'protein'}.'.xpd') {
      system($CTL_OPTIONS{xdformat}. " -p -C $CTL_OPTIONS{'alt_peptide'} $CTL_OPTIONS{'protein'}");
   }
   unless (-e $CTL_OPTIONS{'est'}.'.xnd') {
      system($CTL_OPTIONS{xdformat}. " -n $CTL_OPTIONS{'est'}");
   }
   if (!$OPT{R} && ! -e $CTL_OPTIONS{'repeat_protein'}.'.xpd') {
      system($CTL_OPTIONS{xdformat}." -p $CTL_OPTIONS{'repeat_protein'}");
   }
   if ($CTL_OPTIONS{'alt_est'} && ! $CTL_OPTIONS{'alt_est'}.'.xnd') {
      system($CTL_OPTIONS{xdformat}. " -n $CTL_OPTIONS{'alt_est'}");
   }
}
#----------------------------------------------------------------------------
sub load_anno_hsps {
   my $annotations = shift;
   my @coors;
   my $i = @{$annotations};
   foreach my $an (@$annotations) {
      foreach my $a (@{$an->[0]}) {
	 my $hit = $a->{hit};
	 foreach my $hsp ($hit->hsps()) {
	    push(@coors, [$hsp->nB('query'),
			  $hsp->nE('query'),
			 ]);
	 }
      }
   }
   return (\@coors, $i);;
}
#-----------------------------------------------------------------------------
sub load_clust_hsps {
   my $clusters = shift;
   my @coors;
   my $i = @{$clusters};
   foreach my $c (@$clusters) {
      foreach my $hit (@{$c}) {
	 foreach my $hsp ($hit->hsps()) {
	    push(@coors, [$hsp->nB('query'),
			  $hsp->nE('query'),
			 ]);
	 }
      }
   }
   return (\@coors, $i);
}
#-----------------------------------------------------------------------------
sub load_snap_hsps {
   my $snaps = shift;
   my @coors;
   my $i = @{$snaps};
   foreach my $hit (@{$snaps}) {
      foreach my $hsp ($hit->hsps()) {
	 push(@coors, [$hsp->nB('query'),
		       $hsp->nE('query'),
		      ]);
      }
   }
   return (\@coors, $i);
}
#-----------------------------------------------------------------------------
sub flatten {
   my $clusters = shift;
   my $type     = shift;
   my @hits;
   foreach my $c (@{$clusters}) {
      foreach my $hit (@{$c}) {
	 $hit->type($type) if defined($type);
	 push(@hits, $hit);
      }
   }
   return \@hits;
}
#-----------------------------------------------------------------------------
sub snap {
   my $fasta      = shift;
   my $the_void   = shift;
   my $seq_id     = shift;
   my $snap       = shift;
   my $snaphmm    = shift;
	
   my %params;
   my $file_name = "$the_void/$seq_id.all";
   my $o_file    = "$the_void/$seq_id\.all\.snap";
   
   FastaFile::writeFile($fasta , $file_name);
		
   runSnap($file_name,
	   $o_file,
	   $snap,
	   $snaphmm
	  );
		
   $params{min_exon_score}  = -100000;	    #-10000;
   $params{min_gene_score}  = -100000;	    #0;
		
   my $chunk_keepers = Widget::snap::parse($o_file,
					   \%params,
					   $file_name,
					  );

   unlink($file_name);

   return $chunk_keepers;
}
#-----------------------------------------------------------------------------
sub augustus {
   my $fasta      = shift;
   my $the_void   = shift;
   my $seq_id     = shift;
   my $exe        = shift;
   my $org        = shift;

   my %params;
   my $file_name = "$the_void/$seq_id.all";
   my $o_file    = "$the_void/$seq_id\.all\.augustus";


   FastaFile::writeFile($fasta , $file_name) unless -e $file_name;

   runAugustus($file_name,
               $o_file,
               $exe,
               $org
          );


   $params{min_exon_score}  = -100000;      #-10000;
   $params{min_gene_score}  = -100000;      #0;

   my $chunk_keepers = Widget::augustus::parse($o_file,
                                              \%params,
                                              $file_name,
                                             );

   unlink($file_name);

   return $chunk_keepers;
}
#-----------------------------------------------------------------------------
sub runSnap {
   my $q_file   = shift;
   my $out_file = shift;
   my $snap = shift;
   my $snaphmm = shift;
	
   my $command  = $snap;
   $command .= " $snaphmm";
   $command .= " $q_file";
   $command .= " > $out_file";
	
   my $w = new Widget::snap();
	
   if (-e $out_file && ! $OPT{f}) {
      print STDERR "re reading snap report.\n";
      print STDERR "$out_file\n";
   }
   else {
      print STDERR "running  snap.\n";
      $w->run($command);
   }
}
#-----------------------------------------------------------------------------
sub runAugustus {
   my $q_file   = shift;
   my $out_file = shift;
   my $exe      = shift;
   my $org      = shift;

   my $command  = $exe;
      $command .= ' --species='."$org";
      $command .= " $q_file";
      $command .= " > $out_file";

   my $w = new Widget::augustus();

   if (-e $out_file && ! $OPT{f}) {
      print STDERR "re reading augustus report.\n";
      print STDERR "$out_file\n";
   }
   else {
      print STDERR "running  augustus.\n";
      $w->run($command);
   }
}
#-----------------------------------------------------------------------------
sub polish_exonerate {
   my $g_fasta           = shift;
   my $phat_hit_clusters = shift;
   my $db_index          = shift;
   my $the_void          = shift;
   my $depth             = shift;
   my $type              = shift;
   my $exonerate         = shift;
   my $percov            = shift;
   my $percid            = shift;
   my $score_limit       = shift;
   my $matrix            = shift;

   my $def = Fasta::getDef($g_fasta);
   my $seq = Fasta::getSeq($g_fasta);
	
   my $exe = $exonerate;
	
   my @exonerate_clusters;
   my $i = 0;
   foreach my $c (@{$phat_hit_clusters}) {
      my $n = 0;
      my $got_some = 0;

      foreach my $hit (@{$c}) {
	 last if $n == $depth;

	 next if $hit->pAh < $percov;
	 next if $hit->hsp('best')->frac_identical < $percid;
	 
	 my ($nB, $nE) = PhatHit_utils::get_span_of_hit($hit,'query');

	 my @coors = [$nB, $nE];
	 my $p = Shadower::getPieces($seq, \@coors, 50);
	 my $p_def = $def." ".$p->[0]->{b}." ".$p->[0]->{e};
	 my $p_fasta = Fasta::toFasta($p_def, \$p->[0]->{piece});
	 my ($name) = $p_def =~ />([^\s\t\n]+)/;

	 #build a safe name for file names from the sequence identifier
	 my $safe_name = uri_escape($name,
				    '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
				   );
	 $safe_name .= '.fasta';
	 my $d_file = $the_void."/".$safe_name.'.'.$i.'.'.$n;
	 FastaFile::writeFile($p_fasta, $d_file);
	 my $offset = $p->[0]->{b} - 1;
	 my $id  = $hit->name();
	 $id =~ s/\s+/_/g;
	 $id =~ s/\|/_/g;
	 my $fastaObj = $db_index->get_Seq_by_id($hit->name);
	 if (not $fastaObj) {
	    print "stop here:".$hit->name."\n";
	    die "ERROR: Fasta index error\n";
	 }
	 my $seq      = $fastaObj->seq();
	 my $def      = $db_index->header($hit->name);
	 $def =~ s/\|/_/g;
	 my $fasta    = Fasta::toFasta('>'.$def, \$seq);

	 #build a safe name for file names from the sequence identifier
	 my $safe_id = uri_escape($id, 
				  '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
				 );

	 my $t_file    = $the_void."/".$safe_id.'.'.$i.'.'.$n.'.fasta';
	 my $ext = "$i\.$n";
	 FastaFile::writeFile($fasta, $t_file);

	 my $exonerate_hits = to_polisher($d_file,
					  $t_file,
					  $the_void,
					  $offset,
					  $type,
					  $ext,
					  $exe,
					  $score_limit,
					  $matrix
					 );

	 foreach my $exonerate_hit (@{$exonerate_hits}) {
	    if (defined($exonerate_hit) && exonerate_okay($exonerate_hit)) {
	       $n++;
	       push(@{$exonerate_clusters[$i]}, $exonerate_hit);
	       $got_some = 1;
	    }
	 }
      }
      $i++ if $got_some;
   }
   return \@exonerate_clusters;
}
#-----------------------------------------------------------------------------
sub exonerate_okay {
   my $hit  = shift;

   my $i = 0;
   foreach my $hsp ($hit->hsps()) {
      return 0 unless defined($hsp->nB('query'));
      return 0 unless defined($hsp->nE('query'));
      return 0 unless defined($hsp->nB('hit'));
      return 0 unless defined($hsp->nE('hit'));
      return 0 unless defined($hsp->strand('query'));
      return 0 unless defined($hsp->strand('query'));
      return 0 unless defined($hsp->strand('hit'));
      return 0 unless defined($hsp->strand('hit'));

      my $q_str = $hsp->query_string();
      my $h_str = $hsp->hit_string();
		
      if ($h_str =~ /Target Intron/) {
	 print STDERR "BADDD EXONERATE!\n";
	 sleep 4;
	 return 0;
      } elsif ($q_str =~ /Target Intron/) {
	 print STDERR "BADDD EXONERATE!\n";
	 sleep 4;
	 return 0;
      }
      $i++;
   }

   return 1 
}
#-----------------------------------------------------------------------------
sub to_polisher {
   my $d_file   = shift;
   my $t_file   = shift;
   my $the_void = shift;
   my $offset   = shift;
   my $type     = shift;
   my $ext      = shift;
   my $exe      = shift;
   my $score_limit = shift;
   my $matrix = shift;
    
   if ($type eq 'p') {
      return polisher::exonerate::protein::polish($d_file,
						  $t_file,
						  $the_void,
						  $offset,
						  $ext,
						  $exe,
						  $score_limit,
						  $matrix,
						  $OPT{f}
						 );
   } elsif ($type eq 'e') {
      return polisher::exonerate::est::polish($d_file,
					      $t_file,
					      $the_void,
					      $offset,
					      $ext,
					      $exe,
					      $score_limit,
					      $matrix,
					      $OPT{f}
					     );
   } else {
      die "unknown type:$type in sub to_polisher.\n";
   }
}
#-----------------------------------------------------------------------------
sub make_multi_fasta {
   my $index    = shift;
   my $clusters = shift;;
   my $fastas = '';
   foreach my $c (@{$clusters}) {
      foreach my $hit (@{$c}) {
	 my $id = $hit->name();
	 my $fastaObj = $index->get_Seq_by_id($id);
	 my $seq      = $fastaObj->seq(); 
	 my $def      = $index->header($id);
	 my $fasta    = Fasta::toFasta('>'.$def, \$seq);
	 $fastas     .= $$fasta; 
      }
   }
   return \$fastas;
}
#-----------------------------------------------------------------------------
sub build_fasta_index {
   my $db = shift;
   my $index = new Bio::DB::Fasta($db);
   return $index;
}
#-----------------------------------------------------------------------------
sub repeatmask {
   my $chunk        = shift;
   my $the_void     = shift;
   my $seq_id       = shift;
   my $model_org    = shift;
   my $RepeatMasker = shift;
   my $rmlib        = shift;
   my $cpus         = shift;

   my $chunk_number = $chunk->number();
   my $file_name = "$the_void/$seq_id\.$chunk_number";
   my $o_file    = "$the_void/$seq_id\.$chunk_number\.out";
   my $q_length = $chunk->parent_seq_length();
   my $query_def = $chunk->parent_def();
   my $query_seq = $chunk->seq();

   $chunk->write_file($file_name);
		
   runRepeatMasker($file_name, 
		   $model_org, 
		   $the_void, 
		   $o_file,
		   $RepeatMasker,
		   $rmlib,
		   $cpus
		  );		# -no_low
		
   my $rm_chunk_keepers = Widget::RepeatMasker::parse($o_file, 
						      $seq_id, 
						      $q_length,
						      $OPT{f}
						     );
  
   PhatHit_utils::add_offset($rm_chunk_keepers, 
			     $chunk->offset(),
			    );
   #     PhatHit_utils::merge_hits($rm_keepers,  
   # 			      $rm_chunk_keepers, 
   # 			      20,
   # 			     );

   $chunk->erase_fasta_file();
	
   return ($rm_chunk_keepers);
}
#-----------------------------------------------------------------------------
sub blastn {
   my $chunk      = shift;
   my $db         = shift;
   my $the_void    = shift;
   my $seq_id     = shift;
   my $blastn = shift;
   my $eval_blastn = shift;
   my $bit_blastn = shift,
   my $percov_blastn = shift;
   my $percid_blastn = shift;
   my $split_hit = shift;
   my $cpus = shift;

   my ($db_n) = $db =~ /([^\/]+)$/;
   $db_n  =~ s/\.fasta$//;
	
   my $chunk_number = $chunk->number();
   my $q_length = $chunk->parent_seq_length();
   my $file_name = "$the_void/$seq_id\.$chunk_number";
   my $o_file    = "$the_void/$seq_id\.$chunk_number\.$db_n\.blastn";
		
   $chunk->write_file($file_name);
   runBlastn($file_name,
	     $db,
	     $o_file,
	     $blastn,
	     $eval_blastn,
	     $cpus
	    );

   my %params;
   $params{significance}  = $eval_blastn;
   $params{hsp_bit_min}   = $bit_blastn;
   $params{percov}        = $percov_blastn;
   $params{percid}        = $percid_blastn;
   $params{split_hit}     = $split_hit;

   my $chunk_keepers = Widget::blastn::parse($o_file,
					     \%params,
					    );

   PhatHit_utils::add_offset($chunk_keepers,
			     $chunk->offset(),
			    );

   $chunk->erase_fasta_file();
   
   if($chunk->p_cutoff || $chunk->m_cutoff){
      my @keepers;
      
      foreach my $hit (@{$chunk_keepers}){
	 if ($hit->strand('query') eq '1' && $hit->start('query') >= $chunk->p_cutoff){
	    push (@keepers, $hit)
	 }
	 elsif ($hit->strand('query') eq '-1' && $hit->start('query') >= $chunk->m_cutoff){
	    push (@keepers, $hit)
	 }
      }
      
      return \@keepers;
   }
   else{
      return $chunk_keepers
   }
}
#-----------------------------------------------------------------------------
sub runBlastn {
   my $q_file   = shift;
   my $db       = shift;
   my $out_file = shift;
   my $blastn = shift;
   my $eval_blastn = shift;
   my $cpus = shift;
	
   my $command  = $blastn;
   $command .= " $db $q_file B=10000 V=10000 E=$eval_blastn";
   $command .= " wordmask=seg";
   $command .= " R=3";
   $command .= " W=15";
   $command .= " M=1";
   $command .= " N=-3";
   $command .= " Q=3";
   $command .= " Z=128000000";
   $command .= " cpus=$cpus";	
   $command .= " topcomboN=1";
   $command .= " hspmax=100";
   $command .= " gspmax=100";
   $command .= " hspsepqmax=10000";
   $command .= " lcmask";
   $command .= " filter=seg";
   $command .= " gi";
   #$command .= " mformat=2"; # remove for full report
   $command .= " > $out_file";
	
   my $w = new Widget::blastn();
   if (-e $out_file && ! $OPT{f}) {
      print STDERR "re reading blast report.\n";
      print STDERR "$out_file\n";
   }
   else {
      print STDERR "running  blast search.\n";
      $w->run($command);
   }

}
#-----------------------------------------------------------------------------
sub blastx {
   my $chunk      = shift;
   my $db         = shift;
   my $the_void    = shift;
   my $seq_id     = shift;
   my $blastx = shift;
   my $eval_blastx = shift;
   my $bit_blastx = shift;
   my $percov_blastx = shift;
   my $percid_blastx = shift;
   my $split_hit = shift;
   my $cpus = shift;

   my ($db_n) = $db =~ /([^\/]+)$/;
   $db_n  =~ s/\.fasta$//;

   my $q_length = $chunk->parent_seq_length();
   my $chunk_number = $chunk->number();
		
   my $file_name = "$the_void/$seq_id\.$chunk_number";
   my $o_file    = "$the_void/$seq_id\.$chunk_number\.$db_n\.blastx";
		
   $chunk->write_file($file_name);
   runBlastx($file_name,
	     $db,
	     $o_file,
	     $blastx,
	     $eval_blastx,
	     $cpus
	    );

   my %params;
   $params{significance}  = $eval_blastx;
   $params{hsp_bit_min}   = $bit_blastx;
   $params{percov}        = $percov_blastx;
   $params{percid}        = $percid_blastx;
   $params{split_hit}     = $split_hit;
   
   my $chunk_keepers = Widget::blastx::parse($o_file,
					     \%params,
					    );

   PhatHit_utils::add_offset($chunk_keepers,
			     $chunk->offset(),
			    );
   
   $chunk->erase_fasta_file();
   
   if($chunk->p_cutoff || $chunk->m_cutoff){
      my @keepers;
      
      foreach my $hit (@{$chunk_keepers}){
	 if ($hit->strand('query') eq '1' && $hit->start('query') >= $chunk->p_cutoff){
	    push (@keepers, $hit)
	 }
	 elsif ($hit->strand('query') eq '-1' && $hit->start('query') >= $chunk->m_cutoff){
	    push (@keepers, $hit)
	 }
      }
      
      return \@keepers;
   }
   else{
      return $chunk_keepers
   }
}

#-----------------------------------------------------------------------------
sub runBlastx {
   my $q_file   = shift;
   my $db       = shift;
   my $out_file = shift;
   my $blastx = shift;
   my $eval_blastx = shift;
   my $cpus = shift;

   my $command  = $blastx;
   $command .= " $db $q_file B=10000 V=10000 E=$eval_blastx";
   $command .= " wordmask=seg";
   #$command .= " T=20";
   #$command .= " W=5";
   #$command .= " wink=5";
   $command .= " Z=300";
   $command .= " Y=500000000";
   $command .= " hspmax=100";
   $command .= " cpus=$cpus";
   $command .= " gspmax=100";
   $command .= " hspsepqmax=10000";
   $command .= " lcfilter";
   $command .= " filter=seg";
   $command .= " gi";
   #$command .= " mformat=2"; # remove for full report
   $command .= " > $out_file";
   my $w = new Widget::blastx();

   if (-e $out_file  && ! $OPT{f}) {
      print STDERR "re reading blast report.\n";
      print STDERR "$out_file\n";
   }
   else {
      print STDERR "running  blast search.\n";
      $w->run($command);
   }
}

#-----------------------------------------------------------------------------
sub runRepeatMasker {
   my $q_file   = shift;
   my $species  = shift;
   my $dir      = shift;
   my $o_file   = shift;
   my $RepeatMasker = shift;
   my $rmlib = shift;
   my $cpus = shift;
   my $no_low   = shift;
	
   my $command  = $RepeatMasker;
    
   if ($rmlib) {
      $command .= " $q_file -lib $rmlib -dir $dir -pa $cpus";    
   } else {
      $command .= " $q_file -species $species -dir $dir -pa $cpus";
   }
   $command .= " -nolow" if defined($no_low);
	
   my $w = new Widget::RepeatMasker();
   if (-e $o_file && ! $OPT{f}) {
      print STDERR "re reading repeat masker report.\n";
      print STDERR "$o_file\n";
   }
   else {
      print STDERR "running  repeat masker.\n";
      $w->run($command);
   }
}

#-----------------------------------------------------------------------------
sub build_the_void {
   my $seq_id  = shift;
   my $out_dir = shift;

   $out_dir =~ s/\/$//;

   my $vid = "theVoid\.$seq_id";   
   my $the_void = "$out_dir/$vid";
   mkpath ($the_void);

   return $the_void;
}

#-----------------------------------------------------------------------------
sub load_control_files {
   my @ctlfiles = @_;
   my %CTL_OPTIONS;
   my %OK_FIELDS;

   my @MAKER_OPTS_PARAMS = ('genome',
			    'est',
			    'protein',
			    'repeat_protein',
			    'rmlib',
			    'rm_gff',
			    'predictor',
			    'snaphmm',
			    'augustus_species',
			    'model_org',
			    'max_dna_len',
			    'split_hit',
			    'snap_flank',
			    'te_remove',
			    'single_exon',
			    'use_seq_dir',
			    'clean_up',
			    'cpus',
			    'alt_peptide'
			   );
    
   my @MAKER_BOPTS_PARAMS = ('percov_blastn',
			     'percid_blastn',
			     'eval_blastn',
			     'bit_blastn',
			     'percov_blastx',
			     'percid_blastx',
			     'eval_blastx',
			     'bit_blastx',
			     'e_perc_cov',
			     'ep_score_limit',
			     'en_score_limit'
			    );

   my @MAKER_EXE_PARAMS = ('xdformat',
			   'blastn',
			   'blastx',
			   'snap',
			   'augustus',
			   'RepeatMasker',
			   'exonerate',
			  );


   foreach my $attr (@MAKER_OPTS_PARAMS, @MAKER_BOPTS_PARAMS, @MAKER_EXE_PARAMS) {
      $OK_FIELDS{$attr}++;
   }


   #set default values for certain control options
   $CTL_OPTIONS{'clean_up'} = 0;
   $CTL_OPTIONS{'max_dna_len'} = 100000;
   $CTL_OPTIONS{'percov_blastn'} = 0.80;
   $CTL_OPTIONS{'percid_blastn'} = 0.85;
   $CTL_OPTIONS{'eval_blastn'} = 1e-10;
   $CTL_OPTIONS{'bit_blastn'} = 40;
   $CTL_OPTIONS{'percov_blastx'} = 0.50;
   $CTL_OPTIONS{'percid_blastx'} = 0.40;
   $CTL_OPTIONS{'eval_blastx'} = 1e-6;
   $CTL_OPTIONS{'bit_blastx'} = 30;
   $CTL_OPTIONS{'e_perc_cov'} = 50;
   $CTL_OPTIONS{'alt_peptide'} = 'c';
   $CTL_OPTIONS{'en_score_limit'} = 20;
   $CTL_OPTIONS{'ep_score_limit'} = 20;
   $CTL_OPTIONS{'predictor'} = 'snap';
   
   #load values from control files
   foreach my $ctlfile (@ctlfiles) {
      open (CTL, "< $ctlfile") or die "ERROR: Could not open control files.\n$usage";
	
      while (my $line = <CTL>) {
	 chomp($line);
	    
	 if ($line !~ /^[\#\s\t\n]/ && $line =~ /^([^\:]+)\:([^\s\t\n]+)/) {
	    my $key = $1;
	    my $value = $2;
	    if (exists $OK_FIELDS{$key}) {
	       if ($value =~ /\$/) {
		  $value = `echo $value`;
		  chomp($value);
	       }
	       $CTL_OPTIONS{$key} = $value unless (not defined $value);
	    }
	    else {
	       warn "ERROR: Invalid option \"$key\" in control file $ctlfile\n";
	    }
	 }
      }
   }

   #use command line defined genome
   $CTL_OPTIONS{'genome'} = $OPT{g} if (defined $OPT{g});
   $CTL_OPTIONS{'genome'} = abs_path($CTL_OPTIONS{'genome'});
    
   #use command line defined predictor
   $CTL_OPTIONS{'predictor'} = $OPT{predictor} if (defined $OPT{predictor});
   die "ERROR: Invalid predictor defined: $CTL_OPTIONS{'predictor'}\n".
       "Must be set to 'snap', 'augustus, or 'es2genome'\n"
       unless ($CTL_OPTIONS{'predictor'} =~ /snap|augustus|est2genome/);

   #validate required values from control files
   my @infiles = ('genome', 'protein', 'est', 'xdformat', 'blastn',
		  'blastx', 'exonerate', 'snap'
		 );

   #sometimes required
   push (@infiles, 'repeat_protein') if ($CTL_OPTIONS{te_remove});
   push (@infiles, 'RepeatMasker') unless($OPT{R} || $OPT{GFF});
   push (@infiles, 'rm_gff') if ($OPT{GFF});
   push (@infiles, 'augustus') if ($CTL_OPTIONS{predictor} eq 'augustus' || $CTL_OPTIONS{'augustus'});

   foreach my $in (@infiles) {
      if (not $CTL_OPTIONS{$in}) {
	 die "You have failed to provide a value for \'$in\' in the control files\n;"
      }

      if (not -e $CTL_OPTIONS{$in}) {
	 die "The \'$in\' file $CTL_OPTIONS{$in} does not exist.".
	 "Please check your control files: maker_opts.ctl, maker_bopts, or maker_exe.ctl\n";
      }
   }

   if (! $OPT{R} && ! $CTL_OPTIONS{'model_org'}) {
      warn "There is no model specified for RepeatMasker in maker_opts.ctl : model_org.\n".
	  "As a result the default (drosophila) will be used.\n";
      $CTL_OPTIONS{'model_org'} = "drosophila";
   }
   if ( ($CTL_OPTIONS{'predictor'} eq 'augustus' || $CTL_OPTIONS{'augustus'}) &&
	not $CTL_OPTIONS{'augustus_species'}
      ) {
       warn "There is no species specified for Augustus in maker_opts.ctl : augustus_species.\n".
	   "As a result the default (fly) will be used.\n";
       $CTL_OPTIONS{'augustus_species'} = "fly";
   }
   if (not $CTL_OPTIONS{'snaphmm'}) {
       warn "There is no model specified for for Snap in maker_opts.ctl : snaphmm.\n".
	   "As a result, the default (fly) will be used.\n";
       $CTL_OPTIONS{'snaphmm'} = "fly";
   }
   if (! -e $CTL_OPTIONS{'snaphmm'} &&
       (! exists $ENV{'ZOE'} || ! -e $ENV{'ZOE'}/$CTL_OPTIONS{'snaphmm'})
      ){
      
      die "ERROR: The snaphmm specified for Snap in maker_opts.ctl does not exist.\n";
   }
   if ($CTL_OPTIONS{'max_dna_len'} < 50000){
       warn "ERROR: max_dna_len is set too low.  The minimum value permited is 50,000\n".
	   "max_dna_len wil be reset to 50,000\n\n";
       $CTL_OPTIONS{'max_dna_len'} = 50000;
   }

   #set values for datastructure    
   $CTL_OPTIONS{'genome'} =~ /([^\/]+)$/;
   $CTL_OPTIONS{'out_name'} = $1;
   $CTL_OPTIONS{'out_name'} =~ s/\.[^\.]+$//;
   $CTL_OPTIONS{'out_base'} = cwd();

   if ($CTL_OPTIONS{'use_seq_dir'}) {
      my @file_struct = split(/\//, $CTL_OPTIONS{'genome'});
      pop @file_struct;
      $CTL_OPTIONS{'out_base'} = join("/", @file_struct);
   }
    
   if (not $CTL_OPTIONS{'out_base'}) {
      die "No working directory, check your use_seq_dir option\n";
   }

   return %CTL_OPTIONS;
}

#-----------------------------------------------------------------------------
sub generate_control_files {
   #--build maker_opts.ctl file
   my $repeat_protein = abs_path("$FindBin::Bin/../data/te_proteins.fasta");

   open (OUT, "> maker_opts.ctl");
   print OUT "#-----sequence and library files\n";
   print OUT "genome: #genome sequence file (required)\n";
   print OUT "est: #EST sequence file (required)\n";
   print OUT "protein:  #protein sequence file (required)\n";
   print OUT "repeat_protein:$repeat_protein #a database of transposable element proteins\n";
   print OUT "rmlib: #an organism specific repeat library (optional)\n";
   print OUT "rm_gff: #a gff3 format file of repeat elements (only used with -GFF flag)\n";
   print OUT "\n";
   print OUT "#-----external application specific options\n";
   print OUT "snaphmm:fly #SNAP HMM model\n";
   print OUT "augustus_species:fly #Augustus gene prediction model\n";
   print OUT "model_org:all #RepeatMasker model organism\n";
   print OUT "alt_peptide:c #amino acid used to replace non standard amino acids in xdformat\n";
   print OUT "cpus:2 #max number of cpus to use in BLAST and RepeatMasker\n";
   print OUT "\n";
   print OUT "#-----Maker specific options\n";
   print OUT "predictor:snap #identifies which gene prediction program to use for annotations\n";
   print OUT "te_remove:1 #mask regions with excess similarity to transposable element proteins\n";
   print OUT "max_dna_len:100000 #length for dividing up contigs into chunks (larger values increase memory usage)\n";
   print OUT "split_hit:10000 #length of the splitting of hits (max intron size for EST and protein alignments)\n";
   print OUT "snap_flank:200 #length of sequence surrounding EST and protein evidence used to extend gene predictions\n";
   print OUT "single_exon:0 #consider EST hits aligning to single exons when generating annotations, 1 = yes, 0 = no\n";
   print OUT "use_seq_dir:1 #place output files in same directory as sequence file: 1 = yes, 0 = no\n";
   print OUT "clean_up:0 #remove theVoid directory: 1 = yes, 0 = no\n";
   close (OUT);

   #--build maker_bopts.ctl file
   open (OUT, "> maker_bopts.ctl");
   print OUT "#-----BLAST and Exonerate statistics thresholds\n";
   print OUT "percov_blastn:0.80 #Blastn Percent Coverage Threhold EST-Genome Alignments\n";
   print OUT "percid_blastn:0.85 #Blastn Percent Identity Threshold EST-Genome Aligments\n";
   print OUT "eval_blastn:1e-10 #Blastn eval cutoff\n";
   print OUT "bit_blastn:40 #Blastn bit cutoff\n";
   print OUT "percov_blastx:0.50 #Blastx Percent Coverage Threhold Protein-Genome Alignments\n";
   print OUT "percid_blastx:0.40 #Blastx Percent Identity Threshold Protein-Genome Aligments\n";
   print OUT "eval_blastx:1e-6 #Blastx eval cutoff\n";
   print OUT "bit_blastx:30 #Blastx bit cutoff\n";
   print OUT "e_perc_cov:50 #Exonerate Percent Coverage Thresshold EST_Genome Alignments\n";
   print OUT "ep_score_limit:20 #Report  alignments scoring at least this percentage of the maximal score exonerate nucleotide\n";
   print OUT "en_score_limit:20 #Report  alignments scoring at least this percentage of the maximal score exonerate protein\n";
   close(OUT);

   #--build maker_exe.ctl file
   my %executables = ( xdformat => '',
		       blastn => '',
		       blastx => '',
		       snap => '',
		       augustus => '',
		       exonerate => '',
		       RepeatMasker => '',
		       exonerate => ''
		     );

   while (my $exe = each %executables){
      my $loc = `which $exe`;
      chomp $loc;
      $executables{$exe} = $loc unless ($loc =~ /^no $exe/);
   }

   open (OUT, "> maker_exe.ctl");
   print OUT "#-----Location of executables required by Maker\n";
   print OUT "xdformat:".$executables{xdformat}." #location of xdformat executable\n";
   print OUT "blastn:".$executables{blastn}." #location of blastn executable\n";
   print OUT "blastx:".$executables{blastx}." #location of blastn executable\n";
   print OUT "snap:".$executables{snap}." #location of snap executable\n";
   print OUT "augustus:".$executables{augustus}." #location of augustus executable (optional)\n";
   print OUT "RepeatMasker:".$executables{RepeatMasker}." #location of RepeatMasker executable\n";
   print OUT "exonerate:".$executables{exonerate}." #location of exonerate executable\n";
   close(OUT);
}
