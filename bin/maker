#! /usr/bin/perl -w

use strict "vars";
use strict "refs";

use FindBin;
use lib "$FindBin::Bin/../lib";
use vars qw($LOG $CMD_ARGS);
use File::Temp qw(tempfile tempdir);

BEGIN{
   $ENV{CGL_SO_SOURCE} = "$FindBin::Bin/../lib/CGL/so.obo" if not ($ENV{CGL_SO_SOURCE});
   $ENV{CGL_GO_SOURCE} = "$FindBin::Bin/../lib/CGL/gene_ontology.obo" if not ($ENV{CGL_GO_SOURCE});
   $CMD_ARGS = join(' ', @ARGV);

   $SIG{'INT'} = sub {
      print STDERR "\n\nMaker aborted by user!!\n\n";
      exit (1);
   };

   #output to log file of seq that caused rank to die                                                                               
   $SIG{'__DIE__'} =
   sub {
      if (defined ($LOG) && defined $_[0]) {
	 my $die_count = $LOG->get_die_count();
	 $die_count++;

	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);

      }
      die "#----------------------\n",
          "FATAL: failed!!\n",
          "#----------------------\n",
          $_[0] . "\n";
   };
}

use Error qw(:try);
use Error::Simple;
use Dumper::GFF::GFFV3;
use Dumper::XML::Game;
use Datastore::MD5;
use URI::Escape;
use Storable;
use File::Path;
use Data::Dumper;
use Getopt::Long;
use FileHandle;
use PostData;
use Cwd;
use Fasta;
use Iterator::Fasta;
use FastaChunker;
use Widget::RepeatMasker;
use Widget::blastx;
use Widget::tblastx;
use Widget::blastn;
use Widget::snap; 
use Widget::augustus;
use PhatHit_utils;
use Shadower;
use Bio::DB::Fasta;
use polisher::exonerate::protein;
use polisher::exonerate::est;
use maker::auto_annotator;
use cluster;
use repeat_mask_seq;
use maker::sens_spec;
use runlog;
use Shared_Functions;

$|  = 1;

my $usage = "
Usage:

        maker [options] <maker_opts.ctl> <maker_bopts.ctl> <maker_exe.ctl>

        The three input arguments are user control files that specify how maker should behave.
        All input files listed in the control options files must be in fasta format.  Please
        see maker documentation to learn more about control file format.  The program will
        automatically try and locate the user control files in the current working
        directory if these arguments are not supplied when initializing maker.

        It is important to note that maker does not try and recalculated data that it has
        already calculated.  For example, if you run an analysis twice on the same fasta file
        you will notice that maker does not rerun any of the blast analyses but instead uses
        the blast analyses stored from the previous run.  To force maker to rerun all
        analyses, use the -f flag.

Options:

     -genome|g  <file_name>   Give MAKER a different genome file (this overrides the
                              control file value)

     -predictor <snap>        Selects the gene predictor to use when building annotations (Default
                <augustus>    is 'snap').  The option 'est2genome' builds annotations directly
                <est2genome>  from the EST evidence. This can also be set in the control files.

     -RM_off|R                Turns all repeat masking off (* See Warning)

     -force|f                 Forces maker to rerun all analyses (erases all previous output).

     -datastore|d             Causes output to be written using datastore.  This option is
                              automatically enabled if there are more than 1000 fasta entries in
                              the input genome file.  Output can then be accessed using the
                              master_datastore_index file created by the maker.

     -PREDS                   Outputs ab-initio predictions that do not overlap maker annotation
                              as gene annotations in the final gff3 output file (based on the
                              -predictor flag ).

     -CTL                     Generates generic control files in the current working directory.

     -quiet		      Silences most of the status messages.

     -retry     <integer>     Re-run failed contigs up to the specified number of re-tries.

     -cpus|c    <integer>     Tells how many cpus to use for Blast analysis (this overrides
                              contorol file value).

     -help|?                  Prints this usage statement.


Warning:
      
        *When using the -R flag, maker expects that the input genome file is already masked. Also
         if your genome file contains lower case characters, maker will consider those characers
         to be soft masked.  So if your fasta file is all in lower case, nothing will align to it,
         and there will be no maker output.

";

#variables that are persistent outside of try block
my %OPT;
my %CTL_OPTIONS;

try{
   #--Process arguments and the command line 
   GetOptions("RM_off|R" => \$OPT{R},
	      "force|f" => \$OPT{f},
	      "datastore|d" => \$OPT{d},
	      "genome|g=s" => \$OPT{g},
	      "cpus|c=i" => \$OPT{c},
	      "PREDS" => \$OPT{PREDS},
	      "predictor=s" =>\$OPT{predictor},
	      "retry=i" =>\$OPT{retry},
	      "quiet" => \$main::quiet,
	      "CTL" => sub {Shared_Functions::generate_control_files(); exit(0);},
	      "help|?" => sub {print $usage; exit(0)},
	     );
   
   if (defined($OPT{retry}) && $OPT{retry} <= 0) {
      print STDERR "WARNING: the retry flag must be set to a value greater than zero\n";
      $OPT{retry} = 1;
   }
}
catch Error::Simple with{
   my $E = shift;

   print STDERR $E->{-text};
   print STDERR "\n\nMaker failed parsing command line options!!\n\n";
   my $code = 2;
   $code = $E->{-value} if (defined($E->{-value}));

   exit($code);
};

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

#variables that are persistent outside of try block
my $fasta_iterator;
my $DS_FH;

try{
   #---get arguments off the command line
   my $infile;
   
   my @ctlfiles = @ARGV;
   
   if (not @ctlfiles) {
      if (-e "maker_opts.ctl" && -e "maker_bopts.ctl" && -e "maker_exe.ctl") {
	 @ctlfiles = ("maker_opts.ctl","maker_bopts.ctl","maker_exe.ctl");
      }
      else {
	 print STDERR  "ERROR: Control files not found\n";
	 print $usage;
	 exit(0);
      }
   }

   #---set up control options from control files
   %CTL_OPTIONS = Shared_Functions::load_control_files(\@ctlfiles, \%OPT);
   
   #---load genome fasta file
   $fasta_iterator = new Iterator::Fasta($CTL_OPTIONS{'genome'});
   
   if ($fasta_iterator->number_of_entries() == 0) {
      die "ERROR:  The genome file $CTL_OPTIONS{'genome'} contains no fasta sequences\n";
   }
   
   #---decide whether to use datastore 
   if ($fasta_iterator->number_of_entries() > 1000 && ! $OPT{d}) {
      print STDERR "\n\n".
      "WARNING:  There are more than 1000 entries in the multi-fasta file.\n".
      "Datastore will be used to avoid overloading the data structure of\n".
      "the output directory.\n\n";
      
      $OPT{d} = 1;
   }
   
   #alter control options to use datastore
   if ($OPT{d}) {
      %CTL_OPTIONS = Shared_Functions::build_datastore(\%CTL_OPTIONS);

      $DS_FH = new FileHandle();
      $DS_FH->open("> $CTL_OPTIONS{'dsindex'}");
      $DS_FH->autoflush(1);
   }
   
   #---set up blast databases for analyisis
   Shared_Functions::create_blastdb(\%CTL_OPTIONS, \%OPT);  
}
catch Error::Simple with{
   my $E = shift;
   print STDERR $E->{-text};
   print STDERR "\n\nMaker failed while examining startup data\n",
                "(control files and input fasta files)!!\n\n";
   my $code = 2;
   $code = $E->{-value} if (defined($E->{-value}));

   exit($code);
};

my @failed; #holds failed contigs;
   
#---iterate over each sequence in the fasta
CONTIG: while (my $fasta = $fasta_iterator->nextEntry() || shift @failed) {
   next if ();
   my $failed_contig = 0; #set failure flag to false
   $LOG = undef;

   #variables that are persistent outside of try block
   my $query_def;
   my $query_seq;
   my $seq_id;
   my $seq_out_name;
   my $out_dir;
   my $the_void;

   try{
      #get fasta parts
      $query_def = Fasta::getDef($fasta);  #Get fasta header
      $query_seq = Fasta::getSeq($fasta);  #Get fasta sequence
      ($seq_id)  = $query_def =~ /^>(\S+)/; #Get sequence identifier off of fasta header

      #-build a safe name for file names from the sequence identifier
      $seq_out_name = uri_escape($seq_id,  
				 '\*\?\|\\\/\'\"\{\}\<\>\;\,\^\(\)\$\~\:'
				);
      
      #set up base directory for output
      $out_dir = $CTL_OPTIONS{'out_base'};
      
      #use datastore as base if datastore flag is set
      if ($OPT{d}) {
	 $out_dir = $CTL_OPTIONS{'datastore'}->id_to_dir($seq_out_name);
	 $CTL_OPTIONS{'datastore'}->mkdir($seq_out_name) ||
	      die "ERROR: could not make directory $out_dir\n";
      }
      
      #-set up void directory where analysis is stored
      $the_void  = Shared_Functions::build_the_void($seq_out_name, $out_dir);
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed while examining contents of the fasta file!!\n\n";
      my $code = 2;
      $code = $E->{-value} if (defined($E->{-value}));
      
      exit($code);
   };

   try{
      #-build and proccess the run log
      $LOG = runlog->new(\%CTL_OPTIONS, \%OPT, $the_void, "run.log");
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed while trying to building/processing the run.log file!!\n\n";
      my $code = 2;
      $code = $E->{-value} if (defined($E->{-value}));
      
      exit($code);
   };

   #skip contig if too short
   if (length($$query_seq) < $CTL_OPTIONS{min_contig}){
      print STDERR "#---------------------------------------------------------------------\n",
                   "Skipping the contig \'$seq_id\' because it is too small\n",
                   "#---------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 print $DS_FH "$seq_id\t$out_dir\tSKIPPED_SMALL\n";
      }

      next;
   }

   #==Decide whether to skip the current contig based on log
   my $continue_flag = $LOG->get_continue_flag();
   if ($continue_flag == 1) {
      print STDERR "#---------------------------------------------------------------------\n",
                   "Now starting the contig:$seq_id!!\n",
                   "#---------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 print $DS_FH "$seq_id\t$out_dir\tSTARTED\n";
      }
   }
   elsif ($continue_flag == 0) {
      print STDERR "#---------------------------------------------------------------------\n",
                   "The contig:$seq_id has already been processed!!\n",
                   "Maker will now skip to the next contig.\n",
		   "Run maker with the -f flag to force Maker to recompute all contig data.\n",
		   "#---------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 print $DS_FH "$seq_id\t$out_dir\tFINISHED\n";
      }

      next;
   }
   elsif ($continue_flag == -1) {
      print STDERR "#---------------------------------------------------------------------\n",
                   "The contig:$seq_id failed on the last run!!\n",
		   "Maker will now skip to the next contig rather than try again.\n",
		   "Run maker with the -f flag to force Maker to recompute all contig data.\n",
		   "Run maker with the -died flag to have Maker retry data that failed.\n",
		   "#---------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 print $DS_FH "$seq_id\t$out_dir\tDIED_SKIPPED\n";
      }

      next;
   }
   elsif ($continue_flag == 2) {
      print STDERR "#---------------------------------------------------------------------\n",
                   "The failed contig:$seq_id will now run again!!\n",
		   "#---------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 print $DS_FH "$seq_id\t$out_dir\tRETRY\n";
      }
   }
   elsif ($continue_flag == -2) {
      print STDERR "#---------------------------------------------------------------------\n",
                   "Skipping the contig:$seq_id!!\n",
		   "However this contig is still not finished!!\n",
		   "#---------------------------------------------------------------------\n\n\n";

      if ($OPT{d}) {
	 print $DS_FH "$seq_id\t$out_dir\tSKIPPED\n";
      }

      next;
   }
   elsif ($continue_flag == -3) {
      my $die_count = $LOG->get_die_count();
      print STDERR "#---------------------------------------------------------------------\n",
                   "The contig:$seq_id failed $die_count time!!\n",
		   "Maker will not try again!!\n",
		   "The contig will be stored in $out_dir/$seq_out_name.died.fasta\n",
		   "You can use this fasta file to debug and re-run this sequence\n",
		   "#---------------------------------------------------------------------\n\n\n";

      open (D_FASTA, "> $out_dir/$seq_out_name.died.fasta");
      print D_FASTA $fasta;
      close (D_FASTA);

      if ($OPT{d}) {
	 print $DS_FH "$seq_id\t$out_dir\tDIED_SKIPPED_PERMANENT\n";
      }

      next;
   }

   #==from here on fastas are proccessed as chunks

   #-set up variables that are heldover from last chunk
   my $holdover_blastn;
   my $holdover_blastx;
   my $holdover_tblastx;
   my $holdover_preds;

   #-set up variables that are the result of chunk accumulation
   my $masked_total_seq;
   my $p_fastas;
   my $t_fastas;

   my $GFF3 = new Dumper::GFF::GFFV3();
   $GFF3->seq($query_seq);
   $GFF3->seq_id($seq_id);

   #==REPEAT MASKING HERE

   try{	#coresponds to levels 0-3 in mpi_maker
      if ($OPT{R}) {
	 print STDERR "Repeatmasking skipped!!\n";
	 $masked_total_seq = $$query_seq;
      }
      elsif ($CTL_OPTIONS{rm_gff}) {
	 $masked_total_seq = repeat_mask_seq::gff(uc($$query_seq), 
						  $seq_id,
						  $CTL_OPTIONS{'rm_gff'}
						 );
      }
      else {
	 my $fasta_chunker = new FastaChunker();
	 $fasta_chunker->parent_fasta($fasta);
	 $fasta_chunker->chunk_size($CTL_OPTIONS{'max_dna_len'});
	 $fasta_chunker->min_size($CTL_OPTIONS{'split_hit'});
	 $fasta_chunker->load_chunks();
	 
	 my $chunk_count = 0;
	 
	 while (my $chunk = $fasta_chunker->get_chunk($chunk_count++)) {	 
	    $chunk->seq(uc($chunk->seq())); #must be upper case before soft masking

	    my $rma_keepers = [];

	    #-- repeatmask the input file
	    if(! $CTL_OPTIONS{rmlib_only}){
	       $chunk->seq(uc($chunk->seq())); #must be upper case before soft masking
	       
	       my $rma_keepers1 = Shared_Functions::repeatmask($chunk,
							       $the_void,
							       $seq_out_name,
							       $CTL_OPTIONS{'model_org'},
							       $CTL_OPTIONS{'RepeatMasker'},
							       '',
							       $CTL_OPTIONS{'cpus'},
							       $OPT{f},
							       $LOG
							      );
	       push(@{$rma_keepers}, @{$rma_keepers1});
	       
	       #-mask the chunk using repeatmasker hits
	       $chunk = repeat_mask_seq::mask_chunk($chunk, $rma_keepers1);
	    }

	    #-mask species specific repeats;
	    if($CTL_OPTIONS{rmlib}){
	       my $rma_keepers2 = Shared_Functions::repeatmask($chunk,
							       $the_void,
							       $seq_out_name,
							       $CTL_OPTIONS{'model_org'},
							       $CTL_OPTIONS{'RepeatMasker'},
							       $CTL_OPTIONS{'rmlib'},
							       $CTL_OPTIONS{'cpus'},
							       $OPT{f},
							       $LOG
							      );
	       push(@{$rma_keepers}, @{$rma_keepers2});

	       #-mask the chunk using repeatmasker hits
	       $chunk = repeat_mask_seq::mask_chunk($chunk, $rma_keepers2);
	    }	    
	    
	    #-blastx against a repeat library (for better masking)
	    my $repeat_blastx_keepers = [];
	    $repeat_blastx_keepers = Shared_Functions::blastx($chunk,
							      $CTL_OPTIONS{'repeat_protein'},
							      $the_void,
							      $seq_out_name,
							      $CTL_OPTIONS{blastx},
							      $CTL_OPTIONS{eval_blastx},
							      $CTL_OPTIONS{bit_blastx},
							      $CTL_OPTIONS{percov_blastx},
							      $CTL_OPTIONS{percid_blastx},
							      $CTL_OPTIONS{split_hit},
							      $CTL_OPTIONS{cpus},
							      $OPT{f},
							      $LOG
							     ) if($CTL_OPTIONS{'repeat_protein'});
	    
	    #-mask the chunk using blastx hits
	    $chunk = repeat_mask_seq::mask_chunk($chunk, $repeat_blastx_keepers);
	    
	    #-combine and cluster blastx and repeatmasker hits
	    #-to get consensus repeat hits for gff3 and XML annotations
	    my $rm_keepers = repeat_mask_seq::process($rma_keepers, 
						      $repeat_blastx_keepers,
						      $query_seq
						     );
	    
	    #-add repeats to GFF3
	    $GFF3->repeat_hits($rm_keepers);
	    
	    #-build/fill big masked sequence
	    $masked_total_seq .= $chunk->seq();
	 }
      }
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed while repeat masking!!\n";
      print STDERR "FAILED CONTIG:$seq_id\n\n";

      print $DS_FH "$seq_id\t$out_dir\tDIED\n";

      my $die_count = $LOG->get_die_count();
      $die_count++;

      $LOG->add_entry("DIED","RANK","non_mpi");
      $LOG->add_entry("DIED","COUNT",$die_count);
      $failed_contig = 1;
      push(@failed, $fasta);
   };

   next CONTIG if ($failed_contig);

   #variables that are persistent outside of try block
   my $masked_fasta;
   my $snaps;
   my $augus;
   my $fasta_chunker;
   my $chunk_count;
   my $proteins;
   my $transcripts;
   my $alt_ests;
   my $fasta_t_index;
   my $fasta_p_index;
   my $fasta_a_index;

   try{	#coresponds to level 4 in mpi-maker
      $masked_fasta = Fasta::toFasta($query_def.' masked', \$masked_total_seq);
      FastaFile::writeFile($masked_fasta ,$the_void."/query.masked.fasta");

      #==SNAP ab initio here
      $snaps = [];
      $snaps = Shared_Functions::snap($masked_fasta,
				      $the_void,
				      $seq_out_name,
				      $CTL_OPTIONS{snap},
				      $CTL_OPTIONS{'snaphmm'},
				      $OPT{f},
				      $LOG
				     )if ($CTL_OPTIONS{'snap'});
      
      #==AUGUSTUS ab initio here
      $augus = [];
      $augus = Shared_Functions::augustus($masked_fasta,
					  $the_void,
					  $seq_out_name,
					  $CTL_OPTIONS{'augustus'},
					  $CTL_OPTIONS{'augustus_species'},
					  $OPT{f},
					  $LOG
					 ) if ($CTL_OPTIONS{'augustus'});
      
      #--build an index of the databases
      $proteins = $CTL_OPTIONS{'protein'};
      $transcripts = $CTL_OPTIONS{'est'};
      $alt_ests = $CTL_OPTIONS{'alt_est'};
      $fasta_t_index     = Shared_Functions::build_fasta_index($transcripts); 
      $fasta_p_index     = Shared_Functions::build_fasta_index($proteins);
      $fasta_a_index     = Shared_Functions::build_fasta_index($alt_ests) if($alt_ests); 

      #--run future blast analysis in these new chunks
      $fasta_chunker = new FastaChunker();
      $fasta_chunker = new FastaChunker();
      $fasta_chunker->parent_fasta($$masked_fasta);
      $fasta_chunker->chunk_size($CTL_OPTIONS{'max_dna_len'});
      $fasta_chunker->min_size($CTL_OPTIONS{'split_hit'});
      $fasta_chunker->load_chunks();

      $chunk_count = 0;
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed at ab-initio gene predictions!!\n";
      print STDERR "FAILED CONTIG:$seq_id\n\n";

      print $DS_FH "$seq_id\t$out_dir\tDIED\n";

      my $die_count = $LOG->get_die_count();
      $die_count++;
      
      $LOG->add_entry("DIED","RANK","non_mpi");
      $LOG->add_entry("DIED","COUNT",$die_count);
      $failed_contig = 1;
      push(@failed, $fasta);
   };

   next CONTIG if ($failed_contig);
    
   while (my $chunk = $fasta_chunker->get_chunk($chunk_count++)) {
      #==BLAST ANALYSIS HERE

      #variables that are persistent outside of try block
      my $blastn_keepers;

      try{ #coresponds to levels 5-6 in mpi_maker
	 #-blastn search the file against ESTs
	 $blastn_keepers = Shared_Functions::blastn($chunk,
						    $transcripts,
						    $the_void,
						    $seq_out_name,
						    $CTL_OPTIONS{blastn},
						    $CTL_OPTIONS{eval_blastn},
						    $CTL_OPTIONS{bit_blastn},
						    $CTL_OPTIONS{percov_blastn},
						    $CTL_OPTIONS{percid_blastn},
						    $CTL_OPTIONS{split_hit},
						    $CTL_OPTIONS{cpus},
						    $OPT{f},
						    $LOG
						   );
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at blastn of ESTs!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";
	 
	 print $DS_FH "$seq_id\t$out_dir\tDIED\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
      
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #variables that are persistent outside of try block
      my $blastx_keepers;

      try{ #coresponds to levels 7-8 in mpi_maker
	 #-blastx search the masked input file
	 $blastx_keepers = Shared_Functions::blastx($chunk, 
						    $proteins,
						    $the_void,
						    $seq_out_name,
						    $CTL_OPTIONS{blastx},
						    $CTL_OPTIONS{eval_blastx},
						    $CTL_OPTIONS{bit_blastx},
						    $CTL_OPTIONS{percov_blastx},
						    $CTL_OPTIONS{percid_blastx},
						    $CTL_OPTIONS{split_hit},
						    $CTL_OPTIONS{cpus},
						    $OPT{f},
						    $LOG
						   );
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at blastx of proteins!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";
	 
	 print $DS_FH "$seq_id\t$out_dir\tDIED\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
      
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #variables that are persistent outside of try block
      my $tblastx_keepers = [];

      try{ #coresponds to levels 9-10 in mpi_maker
         #-tblastx search the masked input file
         $tblastx_keepers = Shared_Functions::tblastx($chunk,
						      $alt_ests,
						      $the_void,
						      $seq_out_name,
						      $CTL_OPTIONS{tblastx},
						      $CTL_OPTIONS{eval_tblastx},
						      $CTL_OPTIONS{bit_tblastx},
						      $CTL_OPTIONS{percov_tblastx},
						      $CTL_OPTIONS{percid_tblastx},
						      $CTL_OPTIONS{split_hit},
						      $CTL_OPTIONS{cpus},
						      $OPT{f},
						      $LOG
						    ) if $alt_ests;
     }
      catch Error::Simple with{
	  my $E = shift;

	  print STDERR $E->{-text};
	  print STDERR "\n\nMaker failed at tblastx of alternate ests!!\n";
	  print STDERR "FAILED CONTIG:$seq_id\n\n";

	  print $DS_FH "$seq_id\t$out_dir\tDIED\n";

	  my $die_count = $LOG->get_die_count();
	  $die_count++;

	  $LOG->add_entry("DIED","RANK","non_mpi");
	  $LOG->add_entry("DIED","COUNT",$die_count);
	  $failed_contig = 1;
	  push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #variables that are persistent outside of try block
      my $pred_command;
      my $preds_on_chunk;

      try{ #coresponds to level 11 in mpi_maker
	 #-- decide which gene finder to use to build annotations 

	 if ($CTL_OPTIONS{predictor} eq 'augustus') {
	    $pred_command = $CTL_OPTIONS{augustus} .' --species='.$CTL_OPTIONS{augustus_species};
	    $preds_on_chunk = Shared_Functions::get_preds_on_chunk($augus,
								   $chunk
								  );
	 }
	 elsif ($CTL_OPTIONS{predictor} eq 'snap') {
	    $pred_command = $CTL_OPTIONS{snap}.' '.$CTL_OPTIONS{snaphmm};
	    $preds_on_chunk = Shared_Functions::get_preds_on_chunk($snaps,
								   $chunk
								  );
	 }
	 elsif ($CTL_OPTIONS{predictor} eq 'est2genome') {
	    $pred_command = '';
	    $preds_on_chunk = [];
	 }
	 else {
	    die "ERROR: invalid predictor type: $CTL_OPTIONS{predictor}\n";
	 }

	 #==merge heldover Phathits from last round
	 #reviews heldover hits, then merges and reblasts them if they cross the divide
	 if ($chunk->number != 0) { #if not first chunk
	    ($blastn_keepers,
	     $blastx_keepers,
	     $tblastx_keepers) = Shared_Functions::merge_and_resolve_hits($masked_fasta,
									  $fasta_t_index,
									  $fasta_p_index,
									  $fasta_a_index,
									  $blastn_keepers,
									  $blastx_keepers,
									  $tblastx_keepers,
									  $holdover_blastn,
									  $holdover_blastx,
									  $holdover_tblastx,
									  $the_void,
									  \%CTL_OPTIONS,
									  $OPT{f},
									  $LOG
									 );
	 }
	 
	 #==PROCESS HITS CLOSE TOO CHUNK DIVISIONS
	 #holdover hits that are too close to the divide for review with next chunk
	 if (not $chunk->is_last) { #if not last chunk
	    ($holdover_blastn,
	     $holdover_blastx,
	     $holdover_tblastx,
	     $holdover_preds,
	     $blastn_keepers,
	     $blastx_keepers,
	     $tblastx_keepers,
	     $preds_on_chunk) = Shared_Functions::process_the_chunk_divide($chunk,
									   $CTL_OPTIONS{'split_hit'},
									   $blastn_keepers,
									   $blastx_keepers,
									   $tblastx_keepers,
									   $preds_on_chunk
									  );
	 }
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed while proccessing the chunk divide!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 print $DS_FH "$seq_id\t$out_dir\tDIED\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #==EXONERATE HERE

      #variables that are persistent outside of try block
      my $blastx_data;
      my $exonerate_p_data;

      try{ #coresponds to level 12 in mpi_maker
	 #-cluster the blastx hits
	 print STDERR "cleaning blastx...\n" unless $main::quiet;
	 
	 my $blastx_clusters = cluster::clean_and_cluster($blastx_keepers,
							  $query_seq,
							  10
							 );
	 
	 undef $blastx_keepers; #free up memory
	 
	 #-make a multi-fasta of the seqs in the blastx_clusters 
	 #-polish the blastx hits with exonerate
	 
	 my $exonerate_p_clusters = Shared_Functions::polish_exonerate($fasta,
								       $blastx_clusters,
								       $fasta_p_index,
								       $the_void,
								       5,
								       'p',
								       $CTL_OPTIONS{exonerate},
								       $CTL_OPTIONS{percov_blastx},
								       $CTL_OPTIONS{percid_blastx},
								       $CTL_OPTIONS{ep_score_limit},
								       $CTL_OPTIONS{ep_matrix},
								       $OPT{f},
								       $LOG
								      );
	 
	 $blastx_data      = Shared_Functions::flatten($blastx_clusters);
	 $exonerate_p_data = Shared_Functions::flatten($exonerate_p_clusters, 'exonerate:p');
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at exonerate against proteins!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 print $DS_FH "$seq_id\t$out_dir\tDIED\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #variables that are persistent outside of try block
      my $blastn_data;
      my $tblastx_data;
      my $exonerate_e_data;

      try{ #coresponds to levels 13 in mpi_maker
	 #-cluster the tblastx hits
	 print STDERR "cleaning tblastx...\n" unless $main::quiet;
	 my $tblastx_clusters = cluster::clean_and_cluster($tblastx_keepers,
							   $query_seq,
							   10
							  );
	 
	 undef $tblastx_keepers; #free up memory
	 $tblastx_data      = Shared_Functions::flatten($tblastx_clusters);


	 #-cluster the blastn hits
	 print STDERR "cleaning blastn...\n" unless $main::quiet;
	 my $blastn_clusters = cluster::clean_and_cluster($blastn_keepers,
							  $query_seq,
							  10
							 );
	 
	 undef $blastn_keepers; #free up memory
	 
	 #-polish blastn hits with exonerate
	 my $exonerate_e_clusters = Shared_Functions::polish_exonerate($fasta,
								       $blastn_clusters,
								       $fasta_t_index,
								       $the_void,
								       5,
								       'e',
								       $CTL_OPTIONS{exonerate},
								       $CTL_OPTIONS{percov_blastn},
								       $CTL_OPTIONS{percid_blastn},
								       $CTL_OPTIONS{en_score_limit},
								       $CTL_OPTIONS{en_matrix},
								       $OPT{f},
								       $LOG
								      ); 
	 
	 $blastn_data      = Shared_Functions::flatten($blastn_clusters);
	 $exonerate_e_data = Shared_Functions::flatten($exonerate_e_clusters, 'exonerate:e');
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at exonerate against transcripts!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 print $DS_FH "$seq_id\t$out_dir\tDIED\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      #####working here###########
      #==MAKER annotations built here

      #variables that are persistent outside of try block
      my $annotations;

      try{ #coresponds to level 14 in mpi_maker
	 #-auto-annotate the input file
	 $annotations = maker::auto_annotator::annotate($fasta,
							$$masked_fasta,
							$chunk->number(),
							$exonerate_p_data,
							$exonerate_e_data,
							$blastx_data,
							$preds_on_chunk,
							$the_void,
							$pred_command,
							$CTL_OPTIONS{snap_flank},
							$CTL_OPTIONS{'single_exon'},
							$OPT{f},
							$OPT{PREDS},
							$CTL_OPTIONS{predictor},
							$LOG,
							\%CTL_OPTIONS,
						       );
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at annotation generation!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 print $DS_FH "$seq_id\t$out_dir\tDIED\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);

      try{ #coresponds to levels 15 in mpi_maker
	 #==OUTPUT DATA HERE
	 
	 #--- GFF3      
	 $GFF3->genes($annotations);
	 $GFF3->phat_hits($blastx_data);
	 $GFF3->phat_hits($blastn_data);
	 $GFF3->phat_hits($tblastx_data);
	 $GFF3->phat_hits($exonerate_p_data);
	 $GFF3->phat_hits($exonerate_e_data);
	 
	 #--- GAME XML output was removed and the module is broken

	 
	 #---quality indices
	 
	 #my @quality_indices;
	 #foreach my $an (@$annotations) {
	 #   my $g_name     = $an->{g_name};
	 #   my $g_s        = $an->{g_start};
	 #   my $g_e        = $an->{g_end};
	 #   my $g_strand   = $an->{g_strand};
	 #
	 #   my @temp_ant;
	 #   foreach my $a (@{$an->{t_structs}}) {
	 #       push(@quality_indices, [$a->{t_name}, $a->{t_qi}]);
	 #
	 #       my ($p_fasta, $t_fasta) = get_p_and_t_fastas($a);
	 #
	 #       $t_fastas .= $$t_fasta;
	 #       $p_fastas .= $$p_fasta;
	 #
	 #       push (@temp_ant,$a) if defined($a->{hit});
	 #   }
	 #}
	 #Write the quality index of the mRNAs to a separate file.
	 #write_quality_data(\@quality_indices, $seq_id);
	 
	 #--- building fastas for annotations (grows with itteration)
	 my ($p_fasta, $t_fasta) = Shared_Functions::get_maker_p_and_t_fastas($annotations);
	 $p_fastas .= $p_fasta;
	 $t_fastas .= $t_fasta;
      }
      catch Error::Simple with{
	 my $E = shift;
      
	 print STDERR $E->{-text};
	 print STDERR "\n\nMaker failed at processing annotations on chunk!!\n";
	 print STDERR "FAILED CONTIG:$seq_id\n\n";

	 print $DS_FH "$seq_id\t$out_dir\tDIED\n";

	 my $die_count = $LOG->get_die_count();
	 $die_count++;
	 
	 $LOG->add_entry("DIED","RANK","non_mpi");
	 $LOG->add_entry("DIED","COUNT",$die_count);
	 $failed_contig = 1;
	 push(@failed, $fasta);
      };

      next CONTIG if ($failed_contig);
   }				#END CONTIG

   try{	#coresponds to levels 16 in mpi_maker
      #--- building fastas of predictions
      my ($p_snap_fastas, $t_snap_fastas) =
           Shared_Functions::get_snap_p_and_t_fastas($query_seq, $snaps);
      my ($p_augus_fastas, $t_augus_fastas) =
           Shared_Functions::get_snap_p_and_t_fastas($query_seq, $augus);
      
      #--Write fasta files now that all chunks are finished
      FastaFile::writeFile(\$p_fastas ,"$out_dir/$seq_out_name.maker.proteins.fasta");
      FastaFile::writeFile(\$t_fastas ,"$out_dir/$seq_out_name.maker.transcripts.fasta");
      if ($CTL_OPTIONS{'snap'}) {
	  FastaFile::writeFile(\$p_snap_fastas ,"$out_dir/$seq_out_name.maker.snap.proteins.fasta");
	    FastaFile::writeFile(\$t_snap_fastas ,"$out_dir/$seq_out_name.maker.snap.transcript.fasta");
      }
      if ($CTL_OPTIONS{'augustus'}) {
	 FastaFile::writeFile(\$p_augus_fastas,"$out_dir/$seq_out_name.maker.augus.proteins.fasta");
	 FastaFile::writeFile(\$t_augus_fastas,"$out_dir/$seq_out_name.maker.augus.transcript.fasta");
      }
      
      #--- add predictions to GFF and write
      $GFF3->predictions($snaps);
      $GFF3->predictions($augus);
      $GFF3->print($out_dir."/".$seq_out_name.".gff");
      
      #--cleanup maker files created with each fasta sequence
      File::Path::rmtree ($the_void) if $CTL_OPTIONS{clean_up};	#rm temp directory
   }
   catch Error::Simple with{
      my $E = shift;
      
      print STDERR $E->{-text};
      print STDERR "\n\nMaker failed while writing final data!!\n";
      print STDERR "FAILED CONTIG:$seq_id\n\n";

      print $DS_FH "$seq_id\t$out_dir\tDIED\n";

      my $die_count = $LOG->get_die_count();
      $die_count++;
	 
      $LOG->add_entry("DIED","RANK","non_mpi");
      $LOG->add_entry("DIED","COUNT",$die_count);
      $failed_contig = 1;
      push(@failed, $fasta);
   };

   next CONTIG if ($failed_contig);

   #-- write to dsindex the finished files
   if($OPT{d}){
       print $DS_FH "$seq_id\t$out_dir\tFINISHED\n";;
   }

   #--- clear the log variable
   $LOG = undef;
}

#lets me know when maker is finished
print STDERR "\n\nMaker is now finished!!!\n\n";

exit(0);

#-----------------------------------------------------------------------------
#----------------------------------- SUBS ------------------------------------
#-----------------------------------------------------------------------------
