#! /usr/bin/perl -w
use strict "vars";
use strict "refs";

use Dumper::GFF::GFFV3;
use Dumper::XML::Game;
use Data::Dumper;
use Getopt::Std;
use FileHandle;
use PostData;
use Cwd;
use Fasta;
use Iterator::Fasta;
use FastaChunker;
use Widget::RepeatMasker;
use Widget::blastx;
use Widget::tblastx;
use Widget::blastn;
use Widget::snap; 
use PhatHit_utils;
use Shadower;
use Bio::DB::Fasta;
use polisher::exonerate::protein;
use polisher::exonerate::est;
use maker::auto_annotator;
use cluster;
use repeat_mask_seq;
use maker::sens_spec;

$|  = 1;

use vars qw($opt_h $opt_a $opt_R $opt_f %CTL_OPTIONS $IOG $IOX $GFF3);

getopts("hRfa:");


my $usage = "
Usage:

        maker [options] <genome_file> <maker_opts.ctl> <maker_bopts.ctl> <maker_exe.ctl>

        If you already specified the location for the genome file in the user control files
        you can ommit the first argument, <genome_file>.  The genome file must be in fasta
        format.  Maker only works with one fasta sequence at a time, so if your genome_file
        contains a multifasta, use multifasa_maker to iterate over the sequences.

        The last three arguments are user control files that specify how maker should behave.
        Please see maker documentation to learn more about control file format.  The program
        will automatically try and locate the user control files in the current working
        directory if these arguments are supplied when initializing maker.

        It is important to note that maker does not try and recalculated data that it has
        already calculated.  For example, if you run an analysis twice on the same fasta file
        you will notice that maker does not rerun any of the blast analyses but instead uses
        the blast analyses stored from the previous run.  To force maker to rerun all
        analyses, use the -f flag.

Options:

        -R Turns repeat masking off (* See Warning)
        -f Forces maker to rerun all analyses
        -h Help

Warning:
      
        *When using the -R flag, maker expects that the input genome file is already masked.
         This means that if your genome file contains lower case characters, maker will
         consider those characers to be soft masked.

";

if ($opt_h) {die $usage;}

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------
set_default();
my $infile = '';
if ($#ARGV > 2 || $#ARGV == 0) {
	$infile = shift @ARGV;
}
my @ctlfiles = @ARGV;
if (not @ctlfiles) {
	@ctlfiles = ("maker_opts.ctl","maker_bopts.ctl","maker_exe.ctl");
}
foreach my $ctlfile (@ctlfiles) {
	open CTL, "<$ctlfile" or die "$usage";
	while (my $line = <CTL>) {
		chomp($line);
		if ($line !~ m/^\s*$/ ) {
			my @l = split(/\:/, (split(/\s+\#/, $line))[0]);
			$CTL_OPTIONS{$l[0]} = $l[1];
		}
	}
}
if ($infile) {
	$CTL_OPTIONS{'genome'} = $infile;
}
$CTL_OPTIONS{'out'} = (split(/\./, $CTL_OPTIONS{'genome'}))[0];
my $dir = cwd();
if ($CTL_OPTIONS{'use_seq_dir'}) {
    my @file_struct = split(/\//, $CTL_OPTIONS{'genome'});
    pop @file_struct;
    $dir = join("/", @file_struct);
}
if (not $dir) {
    die "No working directory, check your use_seq_dir option";
}

check_control_files();
create_blastdb($CTL_OPTIONS{'protein'},$CTL_OPTIONS{'est'}, $CTL_OPTIONS{'repeat_protein'},$CTL_OPTIONS{'alt_est'});

my $run_id = $opt_a || 0;

my $fasta_iterator = new Iterator::Fasta($CTL_OPTIONS{'genome'});

my $fasta     = $fasta_iterator->nextEntry();

my $query_def = Fasta::getDef($fasta);

#residues
my $query_seq = Fasta::getSeq($fasta);

my ($seq_id)  = $query_def =~ /^>(\S+)/;


my $the_void  = build_the_void($seq_id, $run_id);

my $masked_fasta = \$fasta;
my $rm_keepers = [];

if (not $opt_R){
    #-- repeatmask the input file 
    my ($temp_masked_fasta, $rma_keepers) = repeatmask($fasta, 
						       $the_void,
						       length($$query_seq),
						       $CTL_OPTIONS{'max_dna_len'},
						       $seq_id,
						      );


    #-- blastx agains a repeat library (for better masking)
    my $repeat_blastx_keepers = blastx($temp_masked_fasta,
				       $CTL_OPTIONS{'repeat_protein'},
				       $the_void,
				       length($$query_seq),
				       $CTL_OPTIONS{'max_dna_len'},
				       $seq_id,
				      );

 
    #-- now use the repeatmasker data + the blastx repeat data 
    #-- to generate a better masked fasta

    (my $masked_seq, $rm_keepers) = repeat_mask_seq::process($query_seq, 
							     $rma_keepers, 
							     $repeat_blastx_keepers,
							    );
   
    $masked_fasta = Fasta::toFasta($query_def.' masked', \$masked_seq);
}
else{
    print STDERR "Repeatmasking skipped!!\n";
}

FastaFile::writeFile($masked_fasta ,$the_void."/query.masked.fasta");

#$IOG= new Dumper::GFF::GFF3->init(FastaFile=>$CTL_OPTIONS{'genome'},
#				  WriteFile=>$CTL_OPTIONS{'out'}.".gff");

$IOX= new Dumper::XML::Game->init(FastaFile=>$CTL_OPTIONS{'genome'},
				  WriteFile=>$CTL_OPTIONS{'out'}.".xml");
my $i=0;
my $j=0;

#--add repeat masked hits to be included
$IOX->add_hits($rm_keepers);

my $proteins = $CTL_OPTIONS{'protein'};
my $transcripts = $CTL_OPTIONS{'est'};
my $cests = $CTL_OPTIONS{'alt_est'};

#-- build an index of the databases
my $fasta_p_index     = build_fasta_index($proteins);
my $fasta_t_index     = build_fasta_index($transcripts);

#-- blastx search  the masked input file
my $blastx_keepers = blastx($$masked_fasta, 
	                    $proteins,
	                    $the_void,
	                    length($$query_seq),
                            $CTL_OPTIONS{'max_dna_len'},
                            $seq_id,
			    );

my $tblastx_keepers = [];
if ($cests) {
	$tblastx_keepers = tblastx($$masked_fasta, 
				  $cests,
				  $the_void,
				  length($$query_seq),
				  $CTL_OPTIONS{'max_dna_len'},
				  $seq_id,
				  );
}

#-- blastn search the file against ESTs
my $blastn_keepers = blastn($$masked_fasta,
                            $transcripts,
                            $the_void,
                            length($$query_seq),
                            $CTL_OPTIONS{'max_dna_len'},
                            $seq_id,
			    );

#--add blastx and blastn hits 
$IOX->add_hits($blastx_keepers);
$IOX->add_hits($tblastx_keepers);
$IOX->add_hits($blastn_keepers);

#-- cluster the blastx hits
print STDERR "cleaning blastx...\n";

my $blastx_clusters = cluster::clean_and_cluster($blastx_keepers,
                                                 $query_seq,
                                                 10);


#-- make a multi-fasta of the seqs in the blastx_clusters 
#-- polish the blastx hits with exonerate

my $exonerate_p_clusters = polish_exonerate($fasta,
					    $blastx_clusters,
					    $fasta_p_index,
					    $the_void,
					    5,
					   'p',
					    ); 


#--add hits
foreach my $pp(@$exonerate_p_clusters){
	$IOX->add_hits($pp);
}
#-- cluster the tblastx hits
print STDERR "cleaning blastx...\n";

my $tblastx_clusters = cluster::clean_and_cluster($tblastx_keepers,
						  $query_seq,
						  10);


#-- make a multi-fasta of the seqs in the tblastx_clusters 
#-- polish the tblastx hits with exonerate

#####There is no exonerate with Tblastx#####

#-- Cluster the blastn hits
print STDERR "cleaning blastn...\n";
my $blastn_clusters = cluster::clean_and_cluster($blastn_keepers,
                                                 $query_seq,
                                                 10);

#-- polish blastn hits with exonerate
my $exonerate_e_clusters = polish_exonerate($fasta,
                                            $blastn_clusters,
                                            $fasta_t_index,
                                            $the_void,
                                            5,
					    'e',
					    );


#--add hits
foreach my $ee(@$exonerate_e_clusters){
	$IOX->add_hits($ee);
}
#####working here###########
#-- gene_find the input file
my $snaps = snap($$masked_fasta, $the_void, length($$masked_fasta), $CTL_OPTIONS{'max_dna_len'}, $seq_id);

$IOX->add_hits($snaps);

#-- auto-annotate the input file
my $snap_command = $CTL_OPTIONS{snap}.' '.$CTL_OPTIONS{snaphmm};
my $snap_flank   = $CTL_OPTIONS{snap_flank};

my $annotations = auto_annotate($fasta,
			        $$masked_fasta,
				$exonerate_p_clusters,
		                $exonerate_e_clusters,
				$blastx_clusters,
				$snaps,
				$the_void,
				$snap_command,
				$snap_flank,
				);



#--- new GFF3

my $blastx_data      = flatten($blastx_clusters);
my $blastn_data      = flatten($blastn_clusters);
my $tblastx_data      = flatten($tblastx_clusters);
my $exonerate_p_data = flatten($exonerate_p_clusters, 'exonerate:p');
my $exonerate_e_data = flatten($exonerate_e_clusters, 'exonerate:e');

$GFF3 = new Dumper::GFF::GFFV3();

$GFF3->seq($query_seq);
$GFF3->seq_id($seq_id);


$GFF3->genes($annotations);
$GFF3->phat_hits($rm_keepers);
$GFF3->phat_hits($blastx_data);
$GFF3->phat_hits($blastn_data);
$GFF3->phat_hits($tblastx_data);
$GFF3->phat_hits($exonerate_p_data);
$GFF3->phat_hits($exonerate_e_data);
$GFF3->predictions($snaps);
$GFF3->print($CTL_OPTIONS{'out'}.".gff");
#$GFF3->print('foo.gff');


#--adding auto annotations
my $p_fastas = '';
my $t_fastas = '';
my @quality_indices;
foreach my $an (@$annotations){
	my $g_name     = $an->{g_name};
	my $g_s        = $an->{g_start};
	my $g_e        = $an->{g_end};
	my $g_strand   = $an->{g_strand};
	
	#$IOG->add_auto_gene($an);
	my @temp_ant;
	foreach my $a (@{$an->{t_structs}}){
		push(@quality_indices, [$a->{t_name}, $a->{t_qi}]);
		
		my ($p_fasta, $t_fasta) = get_p_and_t_fastas($a);
		
		$t_fastas .= $$t_fasta;
		$p_fastas .= $$p_fasta;
		
		#$IOG->add_autoant($a) if defined($a->{hit});
		push (@temp_ant,$a) if defined($a->{hit});
		$IOX->add_autoant($a) if defined($a->{hit});
	}
	#$IOG->add_autoant(\@temp_ant); 
}
#Write the quality index of the mRNAs to a separate file.
#write_quality_data(\@quality_indices, $seq_id);

FastaFile::writeFile(\$p_fastas ,"$dir\/$seq_id\.maker.proteins.fasta");
FastaFile::writeFile(\$t_fastas ,"$dir\/$seq_id\.maker.transcripts.fasta");

#$IOG->GFF3();
$IOX->Game();

my ($p_snap_fastas, $t_snap_fastas) = get_snap_p_and_t_fastas($query_seq, $snaps);

FastaFile::writeFile(\$p_snap_fastas ,"$dir\/$seq_id\.maker.snap.proteins.fasta");
FastaFile::writeFile(\$t_snap_fastas ,"$dir\/$seq_id\.maker.snap.transcript.fasta");

system("rm -r $dir\/theVoid*") if $CTL_OPTIONS{clean_up}; #rm temp directory
exit(0);
#-----------------------------------------------------------------------------
#----------------------------------- SUBS ------------------------------------
#-----------------------------------------------------------------------------
sub write_quality_data {
	my $quality_indices = shift;
	my $seq_id          = shift;

	my $out_file = $seq_id.'.maker.transcripts.qi';
	my $fh = new FileHandle();
	   $fh->open(">$out_file");

	print $fh "genomic_seq\ttranscript\tquality_index\n";

	while (my $d = shift(@{quality_indices})){
		my $t_name = $d->[0];
		my $t_qi   = $d->[1];
	
		print $fh "$seq_id\t$t_name\t$t_qi\n";
	}
	$fh->close();
}
#-----------------------------------------------------------------------------
sub get_snap_p_and_t_fastas {
	my $seq   = shift;
	my $snaps = shift;
	
	my $p_fastas = '';
	my $t_fastas = '';
	foreach my $hit (@{$snaps}){
		my $t_name = $hit->name(); # note this is being set in GFFV3::pred_data
		my $t_seq  = maker::auto_annotator::get_transcript_seq($hit, $seq);	
		
		my ($p_seq, $offset, $end) = 
		    maker::auto_annotator::get_translation_seq($t_seq);
		
		my $score = 0;
		foreach my $hsp ($hit->hsps){
			$score += $hsp->score();
		}
		
		my $p_def = '>'.$t_name.' protein score:'.$score;
        	my $t_def = '>'.$t_name.' snap.transcript offset:'.$offset;
		$t_def.= ' score:'.$score; 
		
		my $p_fasta = Fasta::toFasta($p_def, \$p_seq);
		my $t_fasta = Fasta::toFasta($t_def, \$t_seq);
		
		$p_fastas .= $$p_fasta;
		$t_fastas .= $$t_fasta;
		
	}
	return ($p_fastas, $t_fastas);
}
#-----------------------------------------------------------------------------
sub get_p_and_t_fastas {
	my $t_struct = shift;
	
	my $t_seq  = $t_struct->{t_seq};
	my $p_seq  = $t_struct->{p_seq};
	my $t_off  = $t_struct->{t_offset};
	my $t_name = $t_struct->{t_name};
	
	my $p_def = '>'.$t_name.' protein'; 
	my $t_def = '>'.$t_name.' transcript offset:'.$t_off;
	
	my $p_fasta = Fasta::toFasta($p_def, \$p_seq);
	my $t_fasta = Fasta::toFasta($t_def, \$t_seq);
	
	return($p_fasta, $t_fasta);
}
#----------------------------------------------------------------------------
sub create_blastdb {
	my $p = shift @_;
	my $d = shift @_;
	my $r = shift @_;
	my $c = shift @_;
	if (not `ls $p\.a*`) {
		system($CTL_OPTIONS{setdb}." $p");
	}if (not `ls $d\.n*`) {
		system($CTL_OPTIONS{pressdb}. " $d");
	}if (not `ls $r\.a*`) {
		system($CTL_OPTIONS{setdb}." $r");
	}if ($c && not `ls $c\.n*`) {
		system($CTL_OPTIONS{pressdb}. " $c");
	}
}
#----------------------------------------------------------------------------
sub load_anno_hsps {
	my $annotations = shift;
	my @coors;
	my $i = @{$annotations};
	foreach my $an (@$annotations){
		foreach my $a(@{$an->[0]}){
			my $hit = $a->{hit};
			foreach my $hsp ($hit->hsps()){
				push(@coors, [$hsp->nB('query'),
					      $hsp->nE('query'),
					      ]);
			}
		}
	}
	return (\@coors, $i);;
}
#-----------------------------------------------------------------------------
sub load_clust_hsps {
	my $clusters = shift;
	my @coors;
	my $i = @{$clusters};
	foreach my $c (@$clusters){
		foreach my $hit (@{$c}){
			foreach my $hsp ($hit->hsps()){
				push(@coors, [$hsp->nB('query'),
					      $hsp->nE('query'),
					      ]);
	    }
		}
	}
	return (\@coors, $i);
}
#-----------------------------------------------------------------------------
sub load_snap_hsps {
	my $snaps = shift;
	my @coors;
	my $i = @{$snaps};
	foreach my $hit (@{$snaps}){
		foreach my $hsp ($hit->hsps()){
			push(@coors, [$hsp->nB('query'),
			  $hsp->nE('query'),
				      ]);
		}
	}
	return (\@coors, $i);
}
#-----------------------------------------------------------------------------
sub auto_annotate {
	my $virgin_fasta         = shift;
	my $masked_fasta         = shift;
	my $exonerate_p_clusters = shift;
	my $exonerate_e_clusters = shift;
	my $blastx_clusters      = shift;
	my $snaps                = shift;
	my $the_void             = shift;
	my $snap_command         = shift;
	my $snap_flank           = shift;

	my $blastx_hits      = flatten($blastx_clusters);
	my $exonerate_p_hits = flatten($exonerate_p_clusters, 'exonerate:p');
	my $exonerate_e_hits = flatten($exonerate_e_clusters, 'exonerate:e');

	
	my $annotations = maker::auto_annotator::annotate($virgin_fasta,
							  $masked_fasta,
							  $exonerate_p_hits,
							  $exonerate_e_hits,
							  $blastx_hits,
							  $snaps,
							  $the_void,
							  $snap_command,
							  $snap_flank,
							  $CTL_OPTIONS{'single_exon'}
							  );
}
#-----------------------------------------------------------------------------
sub flatten {
	my $clusters = shift;
	my $type     = shift;
	my @hits;
	foreach my $c (@{$clusters}){
		foreach my $hit (@{$c}){
			$hit->type($type) if defined($type);
			push(@hits, $hit);
		}
	}
	return \@hits;
}
#-----------------------------------------------------------------------------
sub snap {
	my $fasta      = shift;
	my $the_void   = shift;
	my $q_length   = shift;
	my $chunk_size = shift;
	my $seq_id     = shift;
	
	my $fasta_chunker = new FastaChunker();
	$fasta_chunker->parent_fasta($fasta);
	$fasta_chunker->chunk_size($chunk_size);
	$fasta_chunker->load_chunks();
	
	my %params;
	my $snap_keepers = [];
	my $i = 0;
	while (my $chunk = $fasta_chunker->get_chunk($i)){
		my $chunk_number = $chunk->number();
		my $file_name = "$the_void/$seq_id\.$chunk_number";
		my $o_file    = "$the_void/$seq_id\.$chunk_number\.snap";

		$chunk->write_file($file_name);
		
		runSnap($file_name, $o_file);
		
		$params{min_exon_score}  = -100000; #-10000;
		$params{min_gene_score}  = -100000; #0;
		
		my $chunk_keepers =
		    Widget::snap::parse($o_file,
					\%params,
					$file_name,
			       );
		PhatHit_utils::add_offset($chunk_keepers,
					  $chunk->offset(),
					  );
		PhatHit_utils::merge_hits($snap_keepers,
					  $chunk_keepers,
					  10000,
					  );
		$chunk->erase_file();
		$i++;
	}
	return $snap_keepers;
}
#-----------------------------------------------------------------------------
sub runSnap {
	my $q_file   = shift;
	my $out_file = shift;
	
	my $command  = $CTL_OPTIONS{snap};
	$command .= " $CTL_OPTIONS{'snaphmm'}";
	$command .= " $q_file";
	$command .= " > $out_file";
	
	my $w = new Widget::snap();
	
	if (-e $out_file && ! $opt_f){
		print STDERR "re reading snap report.\n";
		print STDERR "$out_file\n";
	}
	else {
		print STDERR "running  snap.\n";
		$w->run($command);
	}
}
#-----------------------------------------------------------------------------
sub polish_exonerate {
	my $g_fasta           = shift;
	my $phat_hit_clusters = shift;
	my $db_index          = shift;
	my $the_void          = shift;
	my $depth             = shift;
	my $type              = shift;

	my $def = Fasta::getDef($g_fasta);
	my $seq = Fasta::getSeq($g_fasta);
	
	my $exe = $CTL_OPTIONS{exonerate};
	
	
	my @exonerate_clusters;
	my $i = 0;
	foreach my $c (@{$phat_hit_clusters}){
		my $n = 0;
		my $got_some = 0;
		foreach my $hit (@{$c}){
			last if $n == $depth;

			if ($type eq 'e'){
				next if $hit->pAh < $CTL_OPTIONS{'percov_blastn'};
				next if $hit->hsp('best')->frac_identical < $CTL_OPTIONS{'percid_blastn'};
			}
			elsif ($type eq 'p'){
				next if $hit->pAh < $CTL_OPTIONS{'percov_blastx'};
				next if $hit->hsp('best')->frac_identical < $CTL_OPTIONS{'percid_blastx'};
	    		}
			my ($nB, $nE) =
			    PhatHit_utils::get_span_of_hit($hit,'query');
			my @coors = [$nB, $nE];
			my $p = Shadower::getPieces($seq, \@coors, 50);
			my $p_def = $def." ".$p->[0]->{b}." ".$p->[0]->{e};
			my $p_fasta = Fasta::toFasta($p_def, \$p->[0]->{piece});
	    		my ($name) = $p_def =~ />(.*)/;
			$name =~ s/\s+/_/g; 
			$name =~ s/\|/_/g;
			$name .= '.fasta';
			my $d_file = $the_void."/".$name.'.'.$i.'.'.$n;
			FastaFile::writeFile($p_fasta, $d_file);
			my $offset = $p->[0]->{b};
			my $id  = $hit->name();
			$id =~ s/\s+/_/g;
			$id =~ s/\|/_/g;
			my $fastaObj = $db_index->get_Seq_by_id($hit->name);
			if (not $fastaObj) {
				print "stop here:".$hit->name."\n";
				die;
			}
			my $seq      = $fastaObj->seq();
			my $def      = $db_index->header($hit->name);
			$def =~ s/\|/_/g;
			my $fasta    = Fasta::toFasta('>'.$def, \$seq);
			my $t_file    = $the_void."/".$id.'.'.$i.'.'.$n.'.fasta';
			my $ext = "$i\.$n";
			FastaFile::writeFile($fasta, $t_file);
			my $exonerate_hits = to_polisher($d_file,
							$t_file,
							$the_void,
							$offset,
							$type,
							$ext,
							$exe,
							);


			foreach my $exonerate_hit (@{$exonerate_hits}){
				if (defined($exonerate_hit) && exonerate_okay($exonerate_hit)){
					$n++;
					push(@{$exonerate_clusters[$i]}, $exonerate_hit);
					$got_some = 1;
				}
			}
		}
		$i++ if $got_some;
	}
	return \@exonerate_clusters;
}
#-----------------------------------------------------------------------------
sub exonerate_okay {
	my $hit  = shift;

	my $i = 0;
	foreach my $hsp ($hit->hsps()){
		return 0 unless defined($hsp->nB('query'));
		return 0 unless defined($hsp->nE('query'));
		return 0 unless defined($hsp->nB('hit'));
		return 0 unless defined($hsp->nE('hit'));
		return 0 unless defined($hsp->strand('query'));
		return 0 unless defined($hsp->strand('query'));
		return 0 unless defined($hsp->strand('hit'));
		return 0 unless defined($hsp->strand('hit'));

		my $q_str = $hsp->query_string();
		my $h_str = $hsp->hit_string();
		
		if ($h_str =~ /Target Intron/){
			print STDERR "BADDD EXONERATE!\n";
			sleep 4;
			return 0;
		}elsif ($q_str =~ /Target Intron/){
			print STDERR "BADDD EXONERATE!\n";
			sleep 4;
			return 0;
		}
		$i++;
	}

	return 1 
    }
#-----------------------------------------------------------------------------
sub to_polisher {
	my $d_file   = shift;
	my $t_file   = shift;
	my $the_void = shift;
	my $offset   = shift;
	my $type     = shift;
	my $ext      = shift;
	my $exe      = shift;
	
	if ($type eq 'p'){
		return polisher::exonerate::protein::polish($d_file,
						            $t_file,
							    $the_void,
							    $offset,
							    $ext,
							    $exe,
							    $CTL_OPTIONS{'ep_score_limit'},
							    $CTL_OPTIONS{'ep_matrix'}
							    );
	}elsif ($type eq 'e'){
		return polisher::exonerate::est::polish($d_file,
							$t_file,
							$the_void,
							$offset,
							$ext,
							$exe,
							$CTL_OPTIONS{'en_score_limit'},
							$CTL_OPTIONS{'en_matrix'}
							);
	}else {
		die "unknown type:$type in sub to_polisher.\n";
	}
}
#-----------------------------------------------------------------------------
sub make_multi_fasta {
	my $index    = shift;
	my $clusters = shift;;
	my $fastas = '';
    foreach my $c (@{$clusters}){
	    foreach my $hit (@{$c}){
		    my $id = $hit->name();
		    my $fastaObj = $index->get_Seq_by_id($id);
		    my $seq      = $fastaObj->seq(); 
		    my $def      = $index->header($id);
		    my $fasta    = Fasta::toFasta('>'.$def, \$seq);
		    $fastas     .= $$fasta; 
	    }
    }
	return \$fastas;
}
#-----------------------------------------------------------------------------
sub build_fasta_index {
	my $db = shift;
	my $index = new Bio::DB::Fasta($db);
	return $index;
}
#-----------------------------------------------------------------------------
sub repeatmask {
	my $fasta      = shift;
	my $theVoid    = shift;
	my $q_length   = shift;
	my $chunk_size = shift;
	my $seq_id     = shift;
	
	my $fasta_chunker = new FastaChunker();
	$fasta_chunker->parent_fasta($fasta);
	$fasta_chunker->chunk_size($chunk_size);
	$fasta_chunker->load_chunks();
	
	my $rm_keepers = [];
	my $i = 0;
	while (my $chunk = $fasta_chunker->get_chunk($i)){

		my $chunk_number = $chunk->number();
		my $file_name = "$the_void/$seq_id\.$chunk_number";
		my $o_file    = "$the_void/$seq_id\.$chunk_number\.out";
		$chunk->write_file($file_name);
		
		runRepeatMasker($file_name, 
				$CTL_OPTIONS{'model_org'}, 
				$the_void, 
				$o_file, 
				); # -no_low
		
		my $rm_chunk_keepers = 
		    Widget::RepeatMasker::parse($o_file, 
						$seq_id, 
						$q_length,
						);
		PhatHit_utils::add_offset($rm_chunk_keepers, 
					  $chunk->offset(),
					  );
		PhatHit_utils::merge_hits($rm_keepers,  
					  $rm_chunk_keepers, 
					  20,
					  );
		$chunk->erase_file();
		$i++;
	}
	
	my ($tes, $lcs) = repeat_mask_seq::seperate_types($rm_keepers);
	
	my $masked_seq = repeat_mask_seq::mask_seq($query_seq, $tes, $lcs);
	
	my $masked_fasta = Fasta::toFasta($query_def.' masked', \$masked_seq);
	
	return ($$masked_fasta, $rm_keepers);
}
#-----------------------------------------------------------------------------
sub blastn {
	my $fasta      = shift;
	my $db         = shift;
	my $theVoid    = shift;
	my $q_length   = shift;
	my $chunk_size = shift;
	my $seq_id     = shift;
	my ($db_n) = $db =~ /([^\/]+)$/;
	$db_n  =~ s/\.fasta$//;
	
	my $fasta_chunker = new FastaChunker();
	$fasta_chunker->parent_fasta($fasta);
	$fasta_chunker->chunk_size($chunk_size);
	$fasta_chunker->load_chunks();
	
    my $blastn_keepers = [];
	my $i = 0;
	while (my $chunk = $fasta_chunker->get_chunk($i)){
		my $chunk_number = $chunk->number();
		my $file_name = "$the_void/$seq_id\.$chunk_number";
		my $o_file    = "$the_void/$seq_id\.$chunk_number\.$db_n\.blastn";
		
		$chunk->write_file($file_name);
		runBlastn($file_name,
			  $db,
			  $o_file,
			  );
		my %params;
		$params{significance}  = $CTL_OPTIONS{'eval_blastn'};
		$params{hsp_bit_min}   = $CTL_OPTIONS{'bit_blastn'};
		my $chunk_keepers =
		    Widget::blastn::parse($o_file,
				  \%params,
					  );
		PhatHit_utils::add_offset($chunk_keepers,
					  $chunk->offset(),
					  );
		PhatHit_utils::merge_hits($blastn_keepers,
					  $chunk_keepers,
				  10000,
					  );
		$chunk->erase_file();
		$i++;
	}
	my @purge;
	foreach my $hit (@{$blastn_keepers}){
		next unless $hit->pAh > $CTL_OPTIONS{'percov_blastn'};
		next unless $hit->hsp('best')->frac_identical() > $CTL_OPTIONS{'percid_blastn'};
		next unless PhatHit_utils::is_contigous($hit);
		push(@purge, $hit);
	}
	my $a = @{$blastn_keepers};
	my $b = @purge;
	my $diff = $a - $b;
	print STDERR "purging blastns deleted $diff hits!\n";
	sleep 1;
	return \@purge;
}
#-----------------------------------------------------------------------------
sub runBlastn {
	my $q_file   = shift;
	my $db       = shift;
	my $out_file = shift;
	
	my $command  = $CTL_OPTIONS{blastn};
	$command .= " $db $q_file B=10000 V=10000 E=$CTL_OPTIONS{'eval_blastn'}";
	$command .= " wordmask=seg";
	$command .= " R=3";
	$command .= " W=15";
	$command .= " M=1";
	$command .= " N=-3";
	$command .= " Q=3";
	$command .= " Z=128000000";
	$command .= " cpus=$CTL_OPTIONS{'cpus'}";	
	$command .= " topcomboN=1";
	$command .= " hspmax=100";
	$command .= " gspmax=100";
	$command .= " hspsepqmax=10000";
	$command .= " lcmask";
	$command .= " filter=seg";
	$command .= " > $out_file";
	
	my $w = new Widget::blastn();
	if (-e $out_file && ! $opt_f){
		print STDERR "re reading blast report.\n";
		print STDERR "$out_file\n";
	}
	else {
		print STDERR "running  blast search.\n";
		$w->run($command);
	}

}
#-----------------------------------------------------------------------------
sub blastx {
	my $fasta      = shift;
	my $db         = shift;
	my $theVoid    = shift;
	my $q_length   = shift;
	my $chunk_size = shift;
	my $seq_id     = shift;
	
	my ($db_n) = $db =~ /([^\/]+)$/;
	$db_n  =~ s/\.fasta$//;
	
	my $fasta_chunker = new FastaChunker();
	$fasta_chunker->parent_fasta($fasta);
	$fasta_chunker->chunk_size($chunk_size);
	$fasta_chunker->load_chunks();
	
	my $blastx_keepers = [];
	my $i = 0;
	while (my $chunk = $fasta_chunker->get_chunk($i)){
		my $chunk_number = $chunk->number();
		
		my $file_name = "$the_void/$seq_id\.$chunk_number";
		my $o_file    = "$the_void/$seq_id\.$chunk_number\.$db_n\.blastx";
		
		$chunk->write_file($file_name);
		runBlastx($file_name,
			  $db,
			  $o_file,
			  );
		my %params;
		$params{significance} = $CTL_OPTIONS{'eval_blastx'};
		$params{hsp_bit_min}  = $CTL_OPTIONS{'bit_blastx'};
		
		my $chunk_keepers =
		    Widget::blastx::parse($o_file,
					  \%params,
					  );
		PhatHit_utils::add_offset($chunk_keepers,
					  $chunk->offset(),
					  );
		PhatHit_utils::merge_hits($blastx_keepers,
				  $chunk_keepers,
					  10000,
					  );
		$chunk->erase_file();
		$i++;
	}
	my @purge;
	foreach my $hit (@{$blastx_keepers}){
		#my $new_hit = PhatHit_utils::normalize($hit, 'hit');
		my $split_hits = PhatHit_utils::split_hit($hit, $CTL_OPTIONS{'split_hit'});
							  
		foreach my $s_hit (@{$split_hits}){
			push(@purge, $s_hit);
		}
							  
							  
		#if (!PhatHit_utils::is_contigous($hit)){
		#	my $shatter_hits = PhatHit_utils::shatter_hit($hit);
		#	push(@purge, @{$shatter_hits});
		#}
		#else {
		#	push(@purge, $hit);
		#}
    }
	my $a = @{$blastx_keepers};
	my $b = @purge;
	my $diff = $a - $b;
	print STDERR "purging blastxs deleted $diff hits!\n";
	sleep 1;
	return \@purge;
}

#-----------------------------------------------------------------------------
sub runBlastx {
    my $q_file   = shift;
    my $db       = shift;
    my $out_file = shift;

    my $command  = $CTL_OPTIONS{blastx};
    $command .= " $db $q_file B=10000 V=10000 E=$CTL_OPTIONS{'eval_blastx'}";
    $command .= " wordmask=seg";
    #$command .= " T=20";
    #$command .= " W=5";
    #$command .= " wink=5";
    $command .= " Z=300";
    $command .= " Y=500000000";
    $command .= " hspmax=100";
    $command .= " cpus=$CTL_OPTIONS{'cpus'}";
    $command .= " gspmax=100";
    $command .= " hspsepqmax=10000";
    $command .= " lcfilter";
    $command .= " filter=seg";
    $command .= " > $out_file";
    my $w = new Widget::blastx();
    if (-e $out_file  && ! $opt_f){
	print STDERR "re reading blast report.\n";
	print STDERR "$out_file\n";
    }
    else {
	print STDERR "running  blast search.\n";
	$w->run($command);
    }
}
#-----------------------------------------------------------------------------
sub runRepeatMasker {
	my $q_file   = shift;
	my $species  = shift;
	my $dir      = shift;
	my $o_file   = shift;
	my $no_low   = shift;
	
	my $command  = $CTL_OPTIONS{'RepeatMasker'};
	my $rlib     = $CTL_OPTIONS{'rmlib'};
	if ($rlib) {
		$command .= " $q_file -lib $rlib -dir $dir ";    
	}else {
		$command .= " $q_file -species $species -dir $dir ";
	}
	$command .= " -nolow" if defined($no_low);
	
	my $w = new Widget::RepeatMasker();
	if (-e $o_file && ! $opt_f){
		print STDERR "re reading repeat masker report.\n";
		print STDERR "$o_file\n";
	}
	else {
		print STDERR "running  repeat masker.\n";
		$w->run($command);
	}
}
#-----------------------------------------------------------------------------
sub build_the_void {
	my $seq_id  = shift;
	my $run_id  = shift;
	my $the_void = "$dir/theVoid\.$seq_id\.$run_id";
	system("mkdir $the_void")  unless -d $the_void;
	return $the_void;
}
#-----------------------------------------------------------------------------

sub check_control_files {
	my @infiles = ('genome', 'protein', 'est','setdb','pressdb',
		       'blastn','blastx','snap','RepeatMasker', 'exonerate');
	foreach my $in (@infiles) {
		if (not $CTL_OPTIONS{$in}){
			die "You have failed to provide the name and location of the $in file\n;"
		    }
		unless (-e $CTL_OPTIONS{$in}) {
			die "The file $in $CTL_OPTIONS{$in} doesn't exist.
Please check your control files: maker_opts.ctl or maker_exe.ctl\n";
		}
	}
	if (not $CTL_OPTIONS{'model_org'}) {
		warn "There is no model for RepeatMasker in maker_opts.ctl.\n
I am using fly instead.\n";
		$CTL_OPTIONS{'model_org'} = "drosophila";
	}
	if (not $CTL_OPTIONS{'snaphmm'}) {
		warn "There is no model for RepeatMasker in maker_opts.ctl.\n
I am using fly instead.\n";
		$CTL_OPTIONS{'snaphmm'} = "fly";
	}
}
#-----------------------------------------------------------------------------
sub set_default {
	$CTL_OPTIONS{'clean_up'} = 0;
	$CTL_OPTIONS{'max_dna_len'} = 100000;
	$CTL_OPTIONS{'percov_blastn'} = 0.80;
	$CTL_OPTIONS{'percid_blastn'} = 0.85;
	$CTL_OPTIONS{'eval_blastn'} = 1e-10;
	$CTL_OPTIONS{'bit_blastn'} = 40;
	$CTL_OPTIONS{'percov_blastx'} = 0.50;
	$CTL_OPTIONS{'percid_blastx'} = 0.40;
	$CTL_OPTIONS{'eval_blastx'} = 1e-6;
	$CTL_OPTIONS{'bit_blastx'} = 30;
	$CTL_OPTIONS{'percov_tblastx'} = 0.50;
	$CTL_OPTIONS{'percid_tblastx'} = 0.40;
	$CTL_OPTIONS{'eval_tblastx'} = 1e-6;
	$CTL_OPTIONS{'bit_tblastx'} = 30;
	$CTL_OPTIONS{'e_perc_cov'} = 50;
}
#-----------------------------------------------------------------------------
sub tblastx {
	my $fasta      = shift;
	my $db         = shift;
	my $theVoid    = shift;
	my $q_length   = shift;
	my $chunk_size = shift;
	my $seq_id     = shift;
	
	my ($db_n) = $db =~ /([^\/]+)$/;
	$db_n  =~ s/\.fasta$//;
	
	my $fasta_chunker = new FastaChunker();
	$fasta_chunker->parent_fasta($fasta);
	$fasta_chunker->chunk_size($chunk_size);
	$fasta_chunker->load_chunks();
	
	my $tblastx_keepers = [];
	my $i = 0;
	while (my $chunk = $fasta_chunker->get_chunk($i)){
		my $chunk_number = $chunk->number();
		
		my $file_name = "$the_void/$seq_id\.$chunk_number";
		my $o_file    = "$the_void/$seq_id\.$chunk_number\.$db_n\.tblastx";
		
		$chunk->write_file($file_name);
		runTblastx($file_name,
			  $db,
			  $o_file,
			  );
		my %params;
		$params{significance} = $CTL_OPTIONS{'eval_tblastx'};
		$params{hsp_bit_min}  = $CTL_OPTIONS{'bit_tblastx'};
		
		my $chunk_keepers =
		    Widget::tblastx::parse($o_file,
					  \%params,
					  );
		PhatHit_utils::add_offset($chunk_keepers,
					  $chunk->offset(),
					  );
		PhatHit_utils::merge_hits($tblastx_keepers,
				  $chunk_keepers,
					  10000,
					  );
		$chunk->erase_file();
		$i++;
	}
	my @purge;
	foreach my $hit (@{$tblastx_keepers}){
	if (!PhatHit_utils::is_contigous($hit)){
		my $shatter_hits = PhatHit_utils::shatter_hit($hit);
		push(@purge, @{$shatter_hits});
	}
	else {
		push(@purge, $hit);
	}
    }
	my $a = @{$tblastx_keepers};
	my $b = @purge;
	my $diff = $a - $b;
	print STDERR "purging tblastxs deleted $diff hits!\n";
	sleep 1;
	return \@purge;
}

#-----------------------------------------------------------------------------
sub runTblastx {
    my $q_file   = shift;
    my $db       = shift;
    my $out_file = shift;

    my $command  = $CTL_OPTIONS{tblastx};
    $command .= " $db $q_file B=10000 V=10000 E=$CTL_OPTIONS{'eval_tblastx'}";
    $command .= " wordmask=seg";
    #$command .= " T=20";
    #$command .= " W=5";
    #$command .= " wink=5";
    $command .= " Z=300";
    $command .= " Y=500000000";
    $command .= " hspmax=100";
    $command .= " cpus=$CTL_OPTIONS{'cpus'}";
    $command .= " gspmax=100";
    $command .= " hspsepqmax=10000";
    $command .= " lcfilter";
    $command .= " filter=seg";
    $command .= " > $out_file";
    my $w = new Widget::tblastx();
    if (-e $out_file && ! $opt_f){
	print STDERR "re reading blast report.\n";
	print STDERR "$out_file\n";
    }
    else {
	print STDERR "running  blast search.\n";
	$w->run($command);
    }
}
#-----------------------------------------------------------------------------
