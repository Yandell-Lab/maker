#! /usr/bin/perl -w

use strict "vars";
use strict "refs";

use FindBin;
use lib "$FindBin::Bin/../lib";

BEGIN{
    $ENV{CGL_SO_SOURCE} = "$FindBin::Bin/../lib/CGL/so.obo" if not ($ENV{CGL_SO_SOURCE});
    $ENV{CGL_GO_SOURCE} = "$FindBin::Bin/../lib/CGL/gene_ontology.obo" if not ($ENV{CGL_GO_SOURCE});

    $SIG{'__WARN__'} =
	sub {
	    warn $_[0] if ( $_[0] !~ /Not a CODE reference/ &&
			    $_[0] !~ /Can\'t store item CODE/
			    );
	    }
}

use Process::MakerChunk;
use Process::MakerTiers;
use Storable qw (freeze thaw);
use File::Temp qw(tempfile tempdir);
use Parallel::MPIcar qw(:all);
use Datastore::MD5;
use File::Path;
use Getopt::Long;
use FileHandle;
use Cwd qw(cwd abs_path);
use Bio::DB::Fasta;
use Iterator::Fasta;
use threads;

#--MPI_Init requires there to be arguments on @ARGV
#--This is a logic problem by the Package Authors
#--This is a hack to solve the problem
if (not @ARGV){
    push (@ARGV, 'null');
    MPI_Init();			#initiate the MPI
    shift @ARGV;
}
else {
    MPI_Init();                 #initiate the MPI
}

$| = 1;

my $usage = "
Usage:

        mpi_maker [options] <genome_file> <maker_opts.ctl> <maker_bopts.ctl> <maker_exe.ctl>

        mpi_maker is to be used on mpi campatable systems only.  All MPI batches should be
        run on more than 2 processors to see any kind of performance benefit over standard
        maker (i.e. mpi_run -n 4 mpi_maker).

        If you already specified the location for the genome file in the user control files
        you can ommit the first argument, <genome_file>.  The genome file must be in fasta
        format.

        The last three arguments are user control files that specify how maker should behave.
        Please see maker documentation to learn more about control file format.  The program
        will automatically try and locate the user control files in the current working
        directory if these arguments are not supplied when initializing maker.

        It is important to note that maker does not try and recalculated data that it has
        already calculated.  For example, if you run an analysis twice on the same fasta file
        you will notice that maker does not rerun any of the blast analyses but instead uses
        the blast analyses stored from the previous run.  To force maker to rerun all
        analyses, use the -f flag.

Options:

        -R Turns repeat masking off (* See Warning)
        -f Forces maker to rerun all analyses
        -d Causes output to be written using datastore.  This option is automatically enabled
           if there are more than 1000 fasta entries in the input file.  Output is then
           accessed using the datastore_index file created by the program.
        -h Help

Warning:
      
        *When using the -R flag, maker expects that the input genome file is already masked.
         If your genome file contains lower case characters, maker will consider those
         characers to be soft masked.

";

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

#------INITIATE MPI VARIABLES------
my $rank = MPI_Comm_rank(MPI_COMM_WORLD); #my proccess number
my $size = MPI_Comm_size(MPI_COMM_WORLD); #how many proccesses

#--mpi message tags
my $give_me_data           = 1111;
my $data_type              = 2222;
my $data_available         = 3333;
my $mpi_data               = 4444;
my $message_length         = 5555;
my $mpi_error              = 6666;
my $results_available      = 7777;
my $new_chunks_available   = 8888;
my $result_chunk_available = 9999;

#--data_types signals
my $chunk_type = 1;
my $tier_type  = 2;

#--data_available signals
my $tier_available  = 1;
my $no_tiers        = 2;
my $chunk_available = 3;
my $no_chunks       = 4;
my $terminate       = 6;
my $initiate        = 7;

#--results_available signals
my $no_results  = 0;
my $got_results = 1;

#--new_chunk_available signals
my $no_new_chunks  = 0;
my $got_new_chunks = 1;

#--result_chunk_available signals
my $no_result_chunk  = 0;
my $got_result_chunk = 1;

#---------PRIMARY MPI PROCCESS---------
my %OPT;

if ($rank == 0) {
    $OPT{a} = 0;

    GetOptions("RM_off|R" => \$OPT{R},
	       "force|f" => \$OPT{f},
	       "datastore|d" => \$OPT{d},
	       "a=s" => \$OPT{a},
	       "help|?" => sub {die $usage;}
	      );

    #get arguments off the command line
    my $infile = '';

    if (@ARGV > 3 || @ARGV == 1) {
	$infile = shift @ARGV;
    }

    my @ctlfiles = @ARGV;

    if ((not @ctlfiles) && (-e "maker_opts.ctl" && -e "maker_bopts.ctl" && -e "maker_exe.ctl")) {
	@ctlfiles = ("maker_opts.ctl","maker_bopts.ctl","maker_exe.ctl");
    }
    else {
	die $usage;
    }

    if ($size < 2) {
        system ("perl $FindBin::Bin/maker " . join (" ", @ARGV));
        exit;
    }

    #set up control options from control files
    my %CTL_OPTIONS = load_control_files($infile, @ctlfiles);

    #load genome fasta file
    my $fasta_iterator = new Iterator::Fasta($CTL_OPTIONS{'genome'});

    if ($fasta_iterator->number_of_entries() == 0) {
        die "ERROR:  The genome file $CTL_OPTIONS{'genome'} contains no fasta sequences\n";
    }

    #decide whether to use datastore 
    my $DS_FH; #datastore file handle
    if ($fasta_iterator->number_of_entries() > 1000) {
	print STDERR "\n\n".
	"WARNING:  There are more than 1000 entries in the multi-fasta file.\n".
	"Datastore will be used to avoid overloading the data structure of\n".
	"the output directory.\n\n";

	$OPT{d} = 1;
    }

    if ($OPT{d}) {
	%CTL_OPTIONS = build_datastore(\%CTL_OPTIONS); #alter control options to use datastore
	$DS_FH = new FileHandle();
	$DS_FH->open("> $CTL_OPTIONS{'dsindex'}");
        $DS_FH->autoflush(1);
    }

    #set up blast databases for analyisis
    %CTL_OPTIONS = create_blastdb(\%CTL_OPTIONS);

    #build fasta indexes
    my $thread = threads->create(\&build_all_indexes, $CTL_OPTIONS{old_protein}, $CTL_OPTIONS{old_est});
    $thread->detach();
    
    #---main code for distribution of mpi data here
    my @chunks;
    my @active;
    my %RESULTS;
    my $go_mpi_flag = 1;
    
    while ($go_mpi_flag) {
        my $recv;
        my $type;
	my $new_chunk_status;
	my $result_chunk_status;
    
	MPI_Recv(\$recv, 1, MPI_INT, -2, $give_me_data, MPI_COMM_WORLD); #check to see who asks for a file
        MPI_Recv(\$type, 1, MPI_INT, $recv, $data_type, MPI_COMM_WORLD); #check request type
       	MPI_Recv(\$result_chunk_status, 1, MPI_INT, $recv, $result_chunk_available, MPI_COMM_WORLD); #receive result chunk status

        if($result_chunk_status == $got_result_chunk){
            my $result_chunk;
            MPI_RecvII(\$result_chunk, $recv, $mpi_data, MPI_COMM_WORLD);
            my ($node_id, $level_id, $chunk_num) = split(':', $result_chunk->id());
            push(@{$RESULTS{$node_id}}, $result_chunk);
        }

       	MPI_Recv(\$new_chunk_status, 1, MPI_INT, $recv, $new_chunks_available, MPI_COMM_WORLD); #receive new chunk status

        if($new_chunk_status == $got_new_chunks){
            my $new_chunks;
            MPI_RecvII(\$new_chunks, $recv, $mpi_data, MPI_COMM_WORLD);
            push(@chunks, @{$new_chunks});
        }

        my $result_status = (defined $RESULTS{$recv}) ? $got_results: $no_results;
        MPI_Send(\$result_status, 1, MPI_INT, $recv, $results_available, MPI_COMM_WORLD); #send result status

        if ($result_status == $got_results){
            MPI_SendII(\$RESULTS{$recv}, $recv, $mpi_data, MPI_COMM_WORLD); #send back chunks with results
            $RESULTS{$recv} = undef;
        }
	    
	if ($type == $tier_type) {
            if (my $fasta = $fasta_iterator->nextEntry()){
                my $tier = Process::MakerTiers->new($fasta,\%CTL_OPTIONS, \%OPT, $recv, $DS_FH);
                MPI_Send(\$tier_available, 1, MPI_INT, $recv, $data_available, MPI_COMM_WORLD); #send data status
                MPI_SendII(\$tier, $recv, $mpi_data, MPI_COMM_WORLD); #send tier
                $active[$recv] = 1;
            }
            else{
                MPI_Send(\$no_tiers, 1, MPI_INT, $recv, $data_available, MPI_COMM_WORLD); #send data status
                $active[$recv] = 0;
            }
        }
        elsif($type == $chunk_type){
            if (my $chunk = shift @chunks){
                MPI_Send(\$chunk_available, 1, MPI_INT, $recv, $data_available, MPI_COMM_WORLD); #send data ststus
                MPI_SendII(\$chunk, $recv, $mpi_data, MPI_COMM_WORLD); #send chunk
            }
            else{
                MPI_Send(\$no_chunks, 1, MPI_INT, $recv, $data_available, MPI_COMM_WORLD); #send data status
            }
        }

        my $inactive_count = 0;

        foreach my $node_status (@active){
            $inactive_count++ if (defined $node_status && $node_status == 0);
        }
        
        if ($inactive_count >= $size - 1){
            $go_mpi_flag = 0;
        }
    }

    #---tell mpi nodes there is no data left
    for (my $i = 1; $i < $size; $i++) {
	my $recv;
	my $type;
        my $result_chunk_status;
        my $new_chunk_status;

        MPI_Recv(\$recv, 1, MPI_INT, -2, $give_me_data, MPI_COMM_WORLD); #check to see who asks for a file
        MPI_Recv(\$type, 1, MPI_INT, $recv, $data_type, MPI_COMM_WORLD); #check request type

        MPI_Recv(\$result_chunk_status, 1, MPI_INT, $recv, $result_chunk_available, MPI_COMM_WORLD); #receive result chunk status
        if ($result_chunk_status == $got_result_chunk){
            die "ERROR:  You are terminating MPI proccesses that have results\n" ;
        }

        MPI_Recv(\$new_chunk_status, 1, MPI_INT, $recv, $new_chunks_available, MPI_COMM_WORLD); #receive new chunk status
        if ($result_chunk_status == $got_result_chunk){
            die "ERROR:  You are terminating MPI proccesses that have chunks\n";
        }

        MPI_Send(\$no_results, 1, MPI_INT, $recv, $results_available, MPI_COMM_WORLD); #send chunk result status
        MPI_Send(\$terminate, 1, MPI_INT, $recv, $data_available, MPI_COMM_WORLD); #send data status
    }

}
#------SECONDARY MPI PROCESSES------
else {
    my $data_status = $initiate;
    my $end_tiers_flag = 0;
    my $tier;
    my @chunks;
    my $result_chunk;

    while($data_status != $terminate) {
	MPI_Send(\$rank, 1, MPI_INT, 0, $give_me_data, MPI_COMM_WORLD); #request data from primary process
        
        my $type = (!$end_tiers_flag && (!$tier || $tier->terminated())) ? $tier_type : $chunk_type;
	MPI_Send(\$type, 1, MPI_INT, 0, $data_type, MPI_COMM_WORLD); #tell primary proccess the data type needed	

        my $result_chunk_status = ($result_chunk) ? $got_result_chunk : $no_result_chunk;
        MPI_Send(\$result_chunk_status, 1, MPI_INT, 0, $result_chunk_available, MPI_COMM_WORLD); #send result chunk status
        if ($result_chunk_status == $got_result_chunk){
            MPI_SendII(\$result_chunk, 0, $mpi_data, MPI_COMM_WORLD); #send result chunk
            $result_chunk = undef;
        }

        my $new_chunk_status = (@chunks) ? $got_new_chunks : $no_new_chunks;
        MPI_Send(\$new_chunk_status, 1, MPI_INT, 0, $new_chunks_available, MPI_COMM_WORLD); #send new chunk status
        if($new_chunk_status == $got_new_chunks){
            my $chunks_ref = \@chunks;
            MPI_SendII(\$chunks_ref, 0, $mpi_data, MPI_COMM_WORLD); #send new chunk
            @chunks = undef;
        }

        my $result_status;
        MPI_Recv(\$result_status, 1, MPI_INT, 0, $results_available, MPI_COMM_WORLD); #receive result status
        if($result_status == $got_results){
            my $results;
            MPI_RecvII(\$results, 0, $mpi_data, MPI_COMM_WORLD); #receive results
            
            foreach my $res (@{$results}){
                $tier->update_chunk($res);
            }
        }
	
        my $data_status;
        MPI_Recv(\$data_status, 1, MPI_INT, 0, $data_available, MPI_COMM_WORLD); #receive staus of tier or chunk data

        if ($data_status == $tier_available){
            MPI_RecvII(\$tier, 0, $mpi_data, MPI_COMM_WORLD);  #receive new tier
        }
        elsif($data_status == $chunk_available){
            my $chunk;
            MPI_RecvII(\$chunk, 0, $mpi_data, MPI_COMM_WORLD);  #receive new chunk
            $chunk->run($rank);
            $result_chunk = $chunk;
        }
        elsif($data_status == $no_tiers){
            $end_tiers_flag = 1;
        }
        elsif($data_status == $no_chunks){
            
        }
        elsif($data_status == $terminate){
            last;
        }

        next if ($end_tiers_flag || $tier->terminated);

        @chunks = get_chunks($tier); #only get chunks if there are more than 1 in that level
    }
}

#-----------------------------------
MPI_Finalize();			#terminate MPI

#-----------------------------------------------------------------------------
#----------------------------------- SUBS ------------------------------------
#-----------------------------------------------------------------------------
sub get_chunks{ #runs chunks unless there is more than 1 in a level
    my $tier = shift;
    my @chunks;

    while(my $chunk = $tier->next_chunk()){
        push (@chunks, $chunk);
    }

    if (@chunks == 1){
        $chunks[0]->run($rank);
        $tier->update_chunk($chunks[0]);
        return get_chunks($tier); 
    }
    else{
        return @chunks;
    }
}
#-----------------------------------------------------------------------------
sub build_datastore {
    my %CTL_OPTIONS = %{shift @_};

    $CTL_OPTIONS{'dsroot'} = "$CTL_OPTIONS{'out_base'}/$CTL_OPTIONS{'out_name'}_datastore";
    $CTL_OPTIONS{'dsindex'} = "$CTL_OPTIONS{'out_base'}/$CTL_OPTIONS{'out_name'}_master_datastore.index";

    print STDERR "A data structure will now be created for you at:\n".
    "$CTL_OPTIONS{'dsroot'}\n\n".
    "To access files for individual sequences use the datastore index:\n".
    "$CTL_OPTIONS{'dsindex'}\n\n";
    
    $CTL_OPTIONS{'datastore'} = new Datastore::MD5('root' => $CTL_OPTIONS{'dsroot'}, 'depth' => 2);

    return %CTL_OPTIONS;
}
#----------------------------------------------------------------------------
sub create_blastdb {
    my %CTL_OPTIONS = %{shift @_};

    $CTL_OPTIONS{'old_protein'}        = $CTL_OPTIONS{'protein'};
    $CTL_OPTIONS{'old_est'}            = $CTL_OPTIONS{'est'};
    $CTL_OPTIONS{'old_repeat_protein'} = $CTL_OPTIONS{'repeat_protein'};
    $CTL_OPTIONS{'old_alt_est'}        = $CTL_OPTIONS{'alt_est'};
    
    $CTL_OPTIONS{'protein'} = split_db($CTL_OPTIONS{'protein'});
    $CTL_OPTIONS{'est'} = split_db($CTL_OPTIONS{'est'});
    $CTL_OPTIONS{'repeat_protein'} = split_db($CTL_OPTIONS{'repeat_protein'}) unless($OPT{R});
    $CTL_OPTIONS{'alt_est'} = split_db($CTL_OPTIONS{'alt_est'}) if ($CTL_OPTIONS{'alt_est'});

    return %CTL_OPTIONS;
}
#----------------------------------------------------------------------------
sub split_db {
    my $file = shift @_;
    
    my $fasta_iterator = new Iterator::Fasta($file);
    my $db_size = $fasta_iterator->number_of_entries();
    my $bins = $size - 1;
    $bins = $db_size if ($db_size < $bins);

    my @fhs;
    my @db_files;

    if ($bins == 1){
	push (@db_files, $file);
	
	return \@db_files;
    }
    
    my $dir = tempdir("dbXXXXX", DIR => cwd(), CLEANUP => 1);

    for (my $i = 0; $i < $bins; $i++){
	my ($fh, $name) = tempfile("dbXXXXX",DIR => $dir, SUFFIX => '.fasta', UNLINK => 1);
	push (@fhs, $fh);
	push (@db_files, $name);
    }

    while (my $fasta = $fasta_iterator->nextEntry()){
	my $fh = shift @fhs;
	print $fh "$fasta\n";
	push (@fhs, $fh);
    }

    foreach my $fh (@fhs){
	close ($fh);
    }

    return \@db_files;
}
#----------------------------------------------------------------------------
sub load_control_files {
    my $infile= shift @_;
    my @ctlfiles = @_;
    my %CTL_OPTIONS;
    my %OK_FIELDS;

    my @MAKER_OPTS_PARAMS = ('genome',
			     'protein',
			     'est',
			     'alt_est',
			     'repeat_protein',
			     'clean_up',
			     'rmlib',
			     'use_seq_dir',
			     'split_hit',
			     'snap_flank',
			     'te_remove',
			     'single_exon'
			    );
    
    my @MAKER_BOPTS_PARAMS = ('max_dna_len',
			      'percov_blastn',
			      'percid_blastn',
			      'eval_blastn',
			      'bit_blastn',
			      'percov_blastx',
			      'percid_blastx',
			      'eval_blastx',
			      'bit_blastx',
			      'e_perc_cov',
			      'ep_score_limit',
			      'en_score_limit',
			      'model_org',
			      'snaphmm',
			     );

    my @MAKER_EXE_PARAMS = ('setdb',
			    'pressdb',
			    'blastn',
			    'blastx',
			    'tblastx',
			    'snap',
			    'RepeatMasker',
			    'exonerate',
			    'cpus',
			   );
    
    foreach my $attr (@MAKER_OPTS_PARAMS, @MAKER_BOPTS_PARAMS, @MAKER_EXE_PARAMS) {
	$OK_FIELDS{$attr}++;
    }

    #set default values for certain control options
    $CTL_OPTIONS{'clean_up'} = 0;
    $CTL_OPTIONS{'max_dna_len'} = 100000;
    $CTL_OPTIONS{'percov_blastn'} = 0.80;
    $CTL_OPTIONS{'percid_blastn'} = 0.85;
    $CTL_OPTIONS{'eval_blastn'} = 1e-10;
    $CTL_OPTIONS{'bit_blastn'} = 40;
    $CTL_OPTIONS{'percov_blastx'} = 0.50;
    $CTL_OPTIONS{'percid_blastx'} = 0.40;
    $CTL_OPTIONS{'eval_blastx'} = 1e-6;
    $CTL_OPTIONS{'bit_blastx'} = 30;
    $CTL_OPTIONS{'percov_tblastx'} = 0.50;
    $CTL_OPTIONS{'percid_tblastx'} = 0.40;
    $CTL_OPTIONS{'eval_tblastx'} = 1e-6;
    $CTL_OPTIONS{'bit_tblastx'} = 30;
    $CTL_OPTIONS{'e_perc_cov'} = 50;

    #load values from control files
    foreach my $ctlfile (@ctlfiles) {
	open (CTL, "< $ctlfile") or die "ERROR: Could not open control files.\n$usage";
	
	while (my $line = <CTL>) {
	    chomp($line);
	    
	    if ($line !~ /^\s\t\n/ && $line =~ /^([^\:]+)\:([^\s\t\n]+)/) {
		my $key = $1;
                my $value = $2;
                if (exists $OK_FIELDS{$key}){
		    if ($value =~ /\$/){
			$value = `echo $value`;
			chomp($value);
		    }
                    $CTL_OPTIONS{$key} = $value unless (not defined $value);
                }
		else {
		    warn "ERROR: Invalid option \"$key\" in control file $ctlfile\n";
		}
	    }
	}
    }

    $CTL_OPTIONS{'genome'} = $infile if ($infile);
    $CTL_OPTIONS{'genome'} = abs_path($CTL_OPTIONS{'genome'});
    

    #validate required values from control files
    my @infiles = ('genome','protein', 'est','setdb','pressdb','blastn',
		   'blastx','snap','exonerate'
		  );

    push (@infiles, 'RepeatMasker') unless($OPT{R});
    
    foreach my $in (@infiles) {
	if (not $CTL_OPTIONS{$in}) {
	    die "You have failed to provide the name and location of the $in file\n;"
	}

	if (not -e $CTL_OPTIONS{$in}) {
	    die "The $in file $CTL_OPTIONS{$in} does not exist.".
	    "Please check your control files: maker_opts.ctl or maker_exe.ctl\n";
	}
    }

    if (! $OPT{R} && ! $CTL_OPTIONS{'model_org'}) {
	warn "There is no model specified for RepeatMasker in maker_opts.ctl : model_org.\n".
	"As a result the default (drosophila) will be used.\n";
	$CTL_OPTIONS{'model_org'} = "drosophila";
    }
    if (not $CTL_OPTIONS{'snaphmm'}) {
	warn "There is no model specified for for Snap in maker_opts.ctl : snaphmm.\n".
	"As a result, te default (fly) will be used.\n";
	$CTL_OPTIONS{'snaphmm'} = "fly";
    }

    #set values for datastructure    
    $CTL_OPTIONS{'genome'} =~ /([^\/]+)$/;
    $CTL_OPTIONS{'out_name'} = $1;
    $CTL_OPTIONS{'out_name'} =~ s/\.[^\.]+$//;
    $CTL_OPTIONS{'out_base'} = cwd();

    if ($CTL_OPTIONS{'use_seq_dir'}) {
	my @file_struct = split(/\//, $CTL_OPTIONS{'genome'});
	pop @file_struct;
	$CTL_OPTIONS{'out_base'} = join("/", @file_struct);
    }
    
    if (not $CTL_OPTIONS{'out_base'}) {
	die "No working directory, check your use_seq_dir option\n";
    }

    return %CTL_OPTIONS;
}
#----------------------------------------------------------------------------
sub totemp{
    my $data = shift @_;

    my ($fh, $name) = tempfile();
    print $fh $data;
    close ($fh);

    return $name;
}
#----------------------------------------------------------------------------
sub MPI_SendII{
    my $msg = shift @_;
    my $target = shift @_;
    my $tag = shift @_;
    my $communicator = shift @_;

    my $send = freeze($msg);
    my $length = length($send);

    MPI_Send(\$length, 1, MPI_INT, $target, $message_length, $communicator);
    MPI_Send(\$send, $length, MPI_CHAR, $target, $tag, $communicator);

}
#----------------------------------------------------------------------------
sub MPI_RecvII{
    my $ref = shift @_;
    my $source = shift @_;
    my $tag = shift @_;
    my $communicator = shift @_;

    my $length;
    my $recv;


    MPI_Recv(\$length, 1, MPI_INT, $source, $message_length, $communicator);
    MPI_Recv(\$recv, $length, MPI_CHAR, $source, $tag, $communicator); #receive line

    ${$ref} = ${thaw($recv)};
}
#-----------------------------------------------------------------------------
sub build_all_indexes {
    my @dbs = @_;

    foreach my $db (@dbs){
	my $index = new Bio::DB::Fasta($db);
    }
}
